/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@emurgo/cardano-serialization-lib-browser/cardano_serialization_lib_bg.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@emurgo/cardano-serialization-lib-browser/cardano_serialization_lib_bg.js ***!
  \************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__) => {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"make_daedalus_bootstrap_witness\": () => (/* binding */ make_daedalus_bootstrap_witness),\n/* harmony export */   \"make_icarus_bootstrap_witness\": () => (/* binding */ make_icarus_bootstrap_witness),\n/* harmony export */   \"make_vkey_witness\": () => (/* binding */ make_vkey_witness),\n/* harmony export */   \"hash_auxiliary_data\": () => (/* binding */ hash_auxiliary_data),\n/* harmony export */   \"hash_transaction\": () => (/* binding */ hash_transaction),\n/* harmony export */   \"hash_plutus_data\": () => (/* binding */ hash_plutus_data),\n/* harmony export */   \"hash_script_data\": () => (/* binding */ hash_script_data),\n/* harmony export */   \"get_implicit_input\": () => (/* binding */ get_implicit_input),\n/* harmony export */   \"get_deposit\": () => (/* binding */ get_deposit),\n/* harmony export */   \"min_ada_required\": () => (/* binding */ min_ada_required),\n/* harmony export */   \"encode_json_str_to_native_script\": () => (/* binding */ encode_json_str_to_native_script),\n/* harmony export */   \"encode_arbitrary_bytes_as_metadatum\": () => (/* binding */ encode_arbitrary_bytes_as_metadatum),\n/* harmony export */   \"decode_arbitrary_bytes_from_metadatum\": () => (/* binding */ decode_arbitrary_bytes_from_metadatum),\n/* harmony export */   \"encode_json_str_to_metadatum\": () => (/* binding */ encode_json_str_to_metadatum),\n/* harmony export */   \"decode_metadatum_to_json_str\": () => (/* binding */ decode_metadatum_to_json_str),\n/* harmony export */   \"encrypt_with_password\": () => (/* binding */ encrypt_with_password),\n/* harmony export */   \"decrypt_with_password\": () => (/* binding */ decrypt_with_password),\n/* harmony export */   \"min_fee\": () => (/* binding */ min_fee),\n/* harmony export */   \"CertificateKind\": () => (/* binding */ CertificateKind),\n/* harmony export */   \"MIRPot\": () => (/* binding */ MIRPot),\n/* harmony export */   \"MIRKind\": () => (/* binding */ MIRKind),\n/* harmony export */   \"RelayKind\": () => (/* binding */ RelayKind),\n/* harmony export */   \"NativeScriptKind\": () => (/* binding */ NativeScriptKind),\n/* harmony export */   \"ScriptHashNamespace\": () => (/* binding */ ScriptHashNamespace),\n/* harmony export */   \"NetworkIdKind\": () => (/* binding */ NetworkIdKind),\n/* harmony export */   \"StakeCredKind\": () => (/* binding */ StakeCredKind),\n/* harmony export */   \"LanguageKind\": () => (/* binding */ LanguageKind),\n/* harmony export */   \"PlutusDataKind\": () => (/* binding */ PlutusDataKind),\n/* harmony export */   \"RedeemerTagKind\": () => (/* binding */ RedeemerTagKind),\n/* harmony export */   \"ScriptSchema\": () => (/* binding */ ScriptSchema),\n/* harmony export */   \"TransactionMetadatumKind\": () => (/* binding */ TransactionMetadatumKind),\n/* harmony export */   \"MetadataJsonSchema\": () => (/* binding */ MetadataJsonSchema),\n/* harmony export */   \"CoinSelectionStrategyCIP2\": () => (/* binding */ CoinSelectionStrategyCIP2),\n/* harmony export */   \"Address\": () => (/* binding */ Address),\n/* harmony export */   \"AssetName\": () => (/* binding */ AssetName),\n/* harmony export */   \"AssetNames\": () => (/* binding */ AssetNames),\n/* harmony export */   \"Assets\": () => (/* binding */ Assets),\n/* harmony export */   \"AuxiliaryData\": () => (/* binding */ AuxiliaryData),\n/* harmony export */   \"AuxiliaryDataHash\": () => (/* binding */ AuxiliaryDataHash),\n/* harmony export */   \"AuxiliaryDataSet\": () => (/* binding */ AuxiliaryDataSet),\n/* harmony export */   \"BaseAddress\": () => (/* binding */ BaseAddress),\n/* harmony export */   \"BigInt\": () => (/* binding */ BigInt),\n/* harmony export */   \"BigNum\": () => (/* binding */ BigNum),\n/* harmony export */   \"Bip32PrivateKey\": () => (/* binding */ Bip32PrivateKey),\n/* harmony export */   \"Bip32PublicKey\": () => (/* binding */ Bip32PublicKey),\n/* harmony export */   \"Block\": () => (/* binding */ Block),\n/* harmony export */   \"BlockHash\": () => (/* binding */ BlockHash),\n/* harmony export */   \"BootstrapWitness\": () => (/* binding */ BootstrapWitness),\n/* harmony export */   \"BootstrapWitnesses\": () => (/* binding */ BootstrapWitnesses),\n/* harmony export */   \"ByronAddress\": () => (/* binding */ ByronAddress),\n/* harmony export */   \"Certificate\": () => (/* binding */ Certificate),\n/* harmony export */   \"Certificates\": () => (/* binding */ Certificates),\n/* harmony export */   \"ConstrPlutusData\": () => (/* binding */ ConstrPlutusData),\n/* harmony export */   \"CostModel\": () => (/* binding */ CostModel),\n/* harmony export */   \"Costmdls\": () => (/* binding */ Costmdls),\n/* harmony export */   \"DNSRecordAorAAAA\": () => (/* binding */ DNSRecordAorAAAA),\n/* harmony export */   \"DNSRecordSRV\": () => (/* binding */ DNSRecordSRV),\n/* harmony export */   \"DataHash\": () => (/* binding */ DataHash),\n/* harmony export */   \"Ed25519KeyHash\": () => (/* binding */ Ed25519KeyHash),\n/* harmony export */   \"Ed25519KeyHashes\": () => (/* binding */ Ed25519KeyHashes),\n/* harmony export */   \"Ed25519Signature\": () => (/* binding */ Ed25519Signature),\n/* harmony export */   \"EnterpriseAddress\": () => (/* binding */ EnterpriseAddress),\n/* harmony export */   \"ExUnitPrices\": () => (/* binding */ ExUnitPrices),\n/* harmony export */   \"ExUnits\": () => (/* binding */ ExUnits),\n/* harmony export */   \"GeneralTransactionMetadata\": () => (/* binding */ GeneralTransactionMetadata),\n/* harmony export */   \"GenesisDelegateHash\": () => (/* binding */ GenesisDelegateHash),\n/* harmony export */   \"GenesisHash\": () => (/* binding */ GenesisHash),\n/* harmony export */   \"GenesisHashes\": () => (/* binding */ GenesisHashes),\n/* harmony export */   \"GenesisKeyDelegation\": () => (/* binding */ GenesisKeyDelegation),\n/* harmony export */   \"Header\": () => (/* binding */ Header),\n/* harmony export */   \"HeaderBody\": () => (/* binding */ HeaderBody),\n/* harmony export */   \"Int\": () => (/* binding */ Int),\n/* harmony export */   \"Ipv4\": () => (/* binding */ Ipv4),\n/* harmony export */   \"Ipv6\": () => (/* binding */ Ipv6),\n/* harmony export */   \"KESSignature\": () => (/* binding */ KESSignature),\n/* harmony export */   \"KESVKey\": () => (/* binding */ KESVKey),\n/* harmony export */   \"Language\": () => (/* binding */ Language),\n/* harmony export */   \"Languages\": () => (/* binding */ Languages),\n/* harmony export */   \"LegacyDaedalusPrivateKey\": () => (/* binding */ LegacyDaedalusPrivateKey),\n/* harmony export */   \"LinearFee\": () => (/* binding */ LinearFee),\n/* harmony export */   \"MIRToStakeCredentials\": () => (/* binding */ MIRToStakeCredentials),\n/* harmony export */   \"MetadataList\": () => (/* binding */ MetadataList),\n/* harmony export */   \"MetadataMap\": () => (/* binding */ MetadataMap),\n/* harmony export */   \"Mint\": () => (/* binding */ Mint),\n/* harmony export */   \"MintAssets\": () => (/* binding */ MintAssets),\n/* harmony export */   \"MoveInstantaneousReward\": () => (/* binding */ MoveInstantaneousReward),\n/* harmony export */   \"MoveInstantaneousRewardsCert\": () => (/* binding */ MoveInstantaneousRewardsCert),\n/* harmony export */   \"MultiAsset\": () => (/* binding */ MultiAsset),\n/* harmony export */   \"MultiHostName\": () => (/* binding */ MultiHostName),\n/* harmony export */   \"NativeScript\": () => (/* binding */ NativeScript),\n/* harmony export */   \"NativeScripts\": () => (/* binding */ NativeScripts),\n/* harmony export */   \"NetworkId\": () => (/* binding */ NetworkId),\n/* harmony export */   \"NetworkInfo\": () => (/* binding */ NetworkInfo),\n/* harmony export */   \"Nonce\": () => (/* binding */ Nonce),\n/* harmony export */   \"OperationalCert\": () => (/* binding */ OperationalCert),\n/* harmony export */   \"PlutusData\": () => (/* binding */ PlutusData),\n/* harmony export */   \"PlutusList\": () => (/* binding */ PlutusList),\n/* harmony export */   \"PlutusMap\": () => (/* binding */ PlutusMap),\n/* harmony export */   \"PlutusScript\": () => (/* binding */ PlutusScript),\n/* harmony export */   \"PlutusScripts\": () => (/* binding */ PlutusScripts),\n/* harmony export */   \"Pointer\": () => (/* binding */ Pointer),\n/* harmony export */   \"PointerAddress\": () => (/* binding */ PointerAddress),\n/* harmony export */   \"PoolMetadata\": () => (/* binding */ PoolMetadata),\n/* harmony export */   \"PoolMetadataHash\": () => (/* binding */ PoolMetadataHash),\n/* harmony export */   \"PoolParams\": () => (/* binding */ PoolParams),\n/* harmony export */   \"PoolRegistration\": () => (/* binding */ PoolRegistration),\n/* harmony export */   \"PoolRetirement\": () => (/* binding */ PoolRetirement),\n/* harmony export */   \"PrivateKey\": () => (/* binding */ PrivateKey),\n/* harmony export */   \"ProposedProtocolParameterUpdates\": () => (/* binding */ ProposedProtocolParameterUpdates),\n/* harmony export */   \"ProtocolParamUpdate\": () => (/* binding */ ProtocolParamUpdate),\n/* harmony export */   \"ProtocolVersion\": () => (/* binding */ ProtocolVersion),\n/* harmony export */   \"ProtocolVersions\": () => (/* binding */ ProtocolVersions),\n/* harmony export */   \"PublicKey\": () => (/* binding */ PublicKey),\n/* harmony export */   \"PublicKeys\": () => (/* binding */ PublicKeys),\n/* harmony export */   \"Redeemer\": () => (/* binding */ Redeemer),\n/* harmony export */   \"RedeemerTag\": () => (/* binding */ RedeemerTag),\n/* harmony export */   \"Redeemers\": () => (/* binding */ Redeemers),\n/* harmony export */   \"Relay\": () => (/* binding */ Relay),\n/* harmony export */   \"Relays\": () => (/* binding */ Relays),\n/* harmony export */   \"RewardAddress\": () => (/* binding */ RewardAddress),\n/* harmony export */   \"RewardAddresses\": () => (/* binding */ RewardAddresses),\n/* harmony export */   \"ScriptAll\": () => (/* binding */ ScriptAll),\n/* harmony export */   \"ScriptAny\": () => (/* binding */ ScriptAny),\n/* harmony export */   \"ScriptDataHash\": () => (/* binding */ ScriptDataHash),\n/* harmony export */   \"ScriptHash\": () => (/* binding */ ScriptHash),\n/* harmony export */   \"ScriptHashes\": () => (/* binding */ ScriptHashes),\n/* harmony export */   \"ScriptNOfK\": () => (/* binding */ ScriptNOfK),\n/* harmony export */   \"ScriptPubkey\": () => (/* binding */ ScriptPubkey),\n/* harmony export */   \"SingleHostAddr\": () => (/* binding */ SingleHostAddr),\n/* harmony export */   \"SingleHostName\": () => (/* binding */ SingleHostName),\n/* harmony export */   \"StakeCredential\": () => (/* binding */ StakeCredential),\n/* harmony export */   \"StakeCredentials\": () => (/* binding */ StakeCredentials),\n/* harmony export */   \"StakeDelegation\": () => (/* binding */ StakeDelegation),\n/* harmony export */   \"StakeDeregistration\": () => (/* binding */ StakeDeregistration),\n/* harmony export */   \"StakeRegistration\": () => (/* binding */ StakeRegistration),\n/* harmony export */   \"Strings\": () => (/* binding */ Strings),\n/* harmony export */   \"TimelockExpiry\": () => (/* binding */ TimelockExpiry),\n/* harmony export */   \"TimelockStart\": () => (/* binding */ TimelockStart),\n/* harmony export */   \"Transaction\": () => (/* binding */ Transaction),\n/* harmony export */   \"TransactionBodies\": () => (/* binding */ TransactionBodies),\n/* harmony export */   \"TransactionBody\": () => (/* binding */ TransactionBody),\n/* harmony export */   \"TransactionBuilder\": () => (/* binding */ TransactionBuilder),\n/* harmony export */   \"TransactionBuilderConfig\": () => (/* binding */ TransactionBuilderConfig),\n/* harmony export */   \"TransactionBuilderConfigBuilder\": () => (/* binding */ TransactionBuilderConfigBuilder),\n/* harmony export */   \"TransactionHash\": () => (/* binding */ TransactionHash),\n/* harmony export */   \"TransactionInput\": () => (/* binding */ TransactionInput),\n/* harmony export */   \"TransactionInputs\": () => (/* binding */ TransactionInputs),\n/* harmony export */   \"TransactionMetadatum\": () => (/* binding */ TransactionMetadatum),\n/* harmony export */   \"TransactionMetadatumLabels\": () => (/* binding */ TransactionMetadatumLabels),\n/* harmony export */   \"TransactionOutput\": () => (/* binding */ TransactionOutput),\n/* harmony export */   \"TransactionOutputs\": () => (/* binding */ TransactionOutputs),\n/* harmony export */   \"TransactionUnspentOutput\": () => (/* binding */ TransactionUnspentOutput),\n/* harmony export */   \"TransactionUnspentOutputs\": () => (/* binding */ TransactionUnspentOutputs),\n/* harmony export */   \"TransactionWitnessSet\": () => (/* binding */ TransactionWitnessSet),\n/* harmony export */   \"TransactionWitnessSets\": () => (/* binding */ TransactionWitnessSets),\n/* harmony export */   \"URL\": () => (/* binding */ URL),\n/* harmony export */   \"UnitInterval\": () => (/* binding */ UnitInterval),\n/* harmony export */   \"Update\": () => (/* binding */ Update),\n/* harmony export */   \"VRFCert\": () => (/* binding */ VRFCert),\n/* harmony export */   \"VRFKeyHash\": () => (/* binding */ VRFKeyHash),\n/* harmony export */   \"VRFVKey\": () => (/* binding */ VRFVKey),\n/* harmony export */   \"Value\": () => (/* binding */ Value),\n/* harmony export */   \"Vkey\": () => (/* binding */ Vkey),\n/* harmony export */   \"Vkeys\": () => (/* binding */ Vkeys),\n/* harmony export */   \"Vkeywitness\": () => (/* binding */ Vkeywitness),\n/* harmony export */   \"Vkeywitnesses\": () => (/* binding */ Vkeywitnesses),\n/* harmony export */   \"Withdrawals\": () => (/* binding */ Withdrawals),\n/* harmony export */   \"__wbindgen_object_drop_ref\": () => (/* binding */ __wbindgen_object_drop_ref),\n/* harmony export */   \"__wbindgen_string_new\": () => (/* binding */ __wbindgen_string_new),\n/* harmony export */   \"__wbg_getRandomValues_98117e9a7e993920\": () => (/* binding */ __wbg_getRandomValues_98117e9a7e993920),\n/* harmony export */   \"__wbg_randomFillSync_64cc7d048f228ca8\": () => (/* binding */ __wbg_randomFillSync_64cc7d048f228ca8),\n/* harmony export */   \"__wbg_process_2f24d6544ea7b200\": () => (/* binding */ __wbg_process_2f24d6544ea7b200),\n/* harmony export */   \"__wbindgen_is_object\": () => (/* binding */ __wbindgen_is_object),\n/* harmony export */   \"__wbg_versions_6164651e75405d4a\": () => (/* binding */ __wbg_versions_6164651e75405d4a),\n/* harmony export */   \"__wbg_node_4b517d861cbcb3bc\": () => (/* binding */ __wbg_node_4b517d861cbcb3bc),\n/* harmony export */   \"__wbg_crypto_98fc271021c7d2ad\": () => (/* binding */ __wbg_crypto_98fc271021c7d2ad),\n/* harmony export */   \"__wbg_msCrypto_a2cdb043d2bfe57f\": () => (/* binding */ __wbg_msCrypto_a2cdb043d2bfe57f),\n/* harmony export */   \"__wbg_modulerequire_3440a4bcf44437db\": () => (/* binding */ __wbg_modulerequire_3440a4bcf44437db),\n/* harmony export */   \"__wbg_newnoargs_9fdd8f3961dd1bee\": () => (/* binding */ __wbg_newnoargs_9fdd8f3961dd1bee),\n/* harmony export */   \"__wbg_call_ba36642bd901572b\": () => (/* binding */ __wbg_call_ba36642bd901572b),\n/* harmony export */   \"__wbg_self_bb69a836a72ec6e9\": () => (/* binding */ __wbg_self_bb69a836a72ec6e9),\n/* harmony export */   \"__wbg_window_3304fc4b414c9693\": () => (/* binding */ __wbg_window_3304fc4b414c9693),\n/* harmony export */   \"__wbg_globalThis_e0d21cabc6630763\": () => (/* binding */ __wbg_globalThis_e0d21cabc6630763),\n/* harmony export */   \"__wbg_global_8463719227271676\": () => (/* binding */ __wbg_global_8463719227271676),\n/* harmony export */   \"__wbindgen_is_undefined\": () => (/* binding */ __wbindgen_is_undefined),\n/* harmony export */   \"__wbg_buffer_9e184d6f785de5ed\": () => (/* binding */ __wbg_buffer_9e184d6f785de5ed),\n/* harmony export */   \"__wbg_new_e8101319e4cf95fc\": () => (/* binding */ __wbg_new_e8101319e4cf95fc),\n/* harmony export */   \"__wbg_set_e8ae7b27314e8b98\": () => (/* binding */ __wbg_set_e8ae7b27314e8b98),\n/* harmony export */   \"__wbg_length_2d56cb37075fcfb1\": () => (/* binding */ __wbg_length_2d56cb37075fcfb1),\n/* harmony export */   \"__wbg_newwithlength_a8d1dbcbe703a5c6\": () => (/* binding */ __wbg_newwithlength_a8d1dbcbe703a5c6),\n/* harmony export */   \"__wbg_subarray_901ede8318da52a6\": () => (/* binding */ __wbg_subarray_901ede8318da52a6),\n/* harmony export */   \"__wbindgen_object_clone_ref\": () => (/* binding */ __wbindgen_object_clone_ref),\n/* harmony export */   \"__wbg_new_3a746f2619705add\": () => (/* binding */ __wbg_new_3a746f2619705add),\n/* harmony export */   \"__wbg_call_f54d3a6dadb199ca\": () => (/* binding */ __wbg_call_f54d3a6dadb199ca),\n/* harmony export */   \"__wbindgen_jsval_eq\": () => (/* binding */ __wbindgen_jsval_eq),\n/* harmony export */   \"__wbg_self_ac379e780a0d8b94\": () => (/* binding */ __wbg_self_ac379e780a0d8b94),\n/* harmony export */   \"__wbg_crypto_1e4302b85d4f64a2\": () => (/* binding */ __wbg_crypto_1e4302b85d4f64a2),\n/* harmony export */   \"__wbg_getRandomValues_1b4ba144162a5c9e\": () => (/* binding */ __wbg_getRandomValues_1b4ba144162a5c9e),\n/* harmony export */   \"__wbg_require_6461b1e9a0d7c34a\": () => (/* binding */ __wbg_require_6461b1e9a0d7c34a),\n/* harmony export */   \"__wbg_randomFillSync_1b52c8482374c55b\": () => (/* binding */ __wbg_randomFillSync_1b52c8482374c55b),\n/* harmony export */   \"__wbg_getRandomValues_1ef11e888e5228e9\": () => (/* binding */ __wbg_getRandomValues_1ef11e888e5228e9),\n/* harmony export */   \"__wbindgen_is_string\": () => (/* binding */ __wbindgen_is_string),\n/* harmony export */   \"__wbindgen_string_get\": () => (/* binding */ __wbindgen_string_get),\n/* harmony export */   \"__wbindgen_debug_string\": () => (/* binding */ __wbindgen_debug_string),\n/* harmony export */   \"__wbindgen_throw\": () => (/* binding */ __wbindgen_throw),\n/* harmony export */   \"__wbindgen_rethrow\": () => (/* binding */ __wbindgen_rethrow),\n/* harmony export */   \"__wbindgen_memory\": () => (/* binding */ __wbindgen_memory)\n/* harmony export */ });\n/* harmony import */ var _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cardano_serialization_lib_bg.wasm */ \"./node_modules/@emurgo/cardano-serialization-lib-browser/cardano_serialization_lib_bg.wasm\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__]);\n_cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? await __webpack_async_dependencies__ : __webpack_async_dependencies__)[0];\n\n\nconst heap = new Array(32).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nfunction getObject(idx) { return heap[idx]; }\n\nlet heap_next = heap.length;\n\nfunction dropObject(idx) {\n    if (idx < 36) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n\nlet cachedTextDecoder = new TextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n\ncachedTextDecoder.decode();\n\nlet cachegetUint8Memory0 = null;\nfunction getUint8Memory0() {\n    if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.memory.buffer) {\n        cachegetUint8Memory0 = new Uint8Array(_cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.memory.buffer);\n    }\n    return cachegetUint8Memory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nlet cachedTextEncoder = new TextEncoder('utf-8');\n\nconst encodeString = (typeof cachedTextEncoder.encodeInto === 'function'\n    ? function (arg, view) {\n    return cachedTextEncoder.encodeInto(arg, view);\n}\n    : function (arg, view) {\n    const buf = cachedTextEncoder.encode(arg);\n    view.set(buf);\n    return {\n        read: arg.length,\n        written: buf.length\n    };\n});\n\nfunction passStringToWasm0(arg, malloc, realloc) {\n\n    if (realloc === undefined) {\n        const buf = cachedTextEncoder.encode(arg);\n        const ptr = malloc(buf.length);\n        getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);\n        WASM_VECTOR_LEN = buf.length;\n        return ptr;\n    }\n\n    let len = arg.length;\n    let ptr = malloc(len);\n\n    const mem = getUint8Memory0();\n\n    let offset = 0;\n\n    for (; offset < len; offset++) {\n        const code = arg.charCodeAt(offset);\n        if (code > 0x7F) break;\n        mem[ptr + offset] = code;\n    }\n\n    if (offset !== len) {\n        if (offset !== 0) {\n            arg = arg.slice(offset);\n        }\n        ptr = realloc(ptr, len, len = offset + arg.length * 3);\n        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);\n        const ret = encodeString(arg, view);\n\n        offset += ret.written;\n    }\n\n    WASM_VECTOR_LEN = offset;\n    return ptr;\n}\n\nfunction isLikeNone(x) {\n    return x === undefined || x === null;\n}\n\nlet cachegetInt32Memory0 = null;\nfunction getInt32Memory0() {\n    if (cachegetInt32Memory0 === null || cachegetInt32Memory0.buffer !== _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.memory.buffer) {\n        cachegetInt32Memory0 = new Int32Array(_cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.memory.buffer);\n    }\n    return cachegetInt32Memory0;\n}\n\nfunction debugString(val) {\n    // primitive types\n    const type = typeof val;\n    if (type == 'number' || type == 'boolean' || val == null) {\n        return  `${val}`;\n    }\n    if (type == 'string') {\n        return `\"${val}\"`;\n    }\n    if (type == 'symbol') {\n        const description = val.description;\n        if (description == null) {\n            return 'Symbol';\n        } else {\n            return `Symbol(${description})`;\n        }\n    }\n    if (type == 'function') {\n        const name = val.name;\n        if (typeof name == 'string' && name.length > 0) {\n            return `Function(${name})`;\n        } else {\n            return 'Function';\n        }\n    }\n    // objects\n    if (Array.isArray(val)) {\n        const length = val.length;\n        let debug = '[';\n        if (length > 0) {\n            debug += debugString(val[0]);\n        }\n        for(let i = 1; i < length; i++) {\n            debug += ', ' + debugString(val[i]);\n        }\n        debug += ']';\n        return debug;\n    }\n    // Test for built-in\n    const builtInMatches = /\\[object ([^\\]]+)\\]/.exec(toString.call(val));\n    let className;\n    if (builtInMatches.length > 1) {\n        className = builtInMatches[1];\n    } else {\n        // Failed to match the standard '[object ClassName]'\n        return toString.call(val);\n    }\n    if (className == 'Object') {\n        // we're a user defined class or Object\n        // JSON.stringify avoids problems with cycles, and is generally much\n        // easier than looping through ownProperties of `val`.\n        try {\n            return 'Object(' + JSON.stringify(val) + ')';\n        } catch (_) {\n            return 'Object';\n        }\n    }\n    // errors\n    if (val instanceof Error) {\n        return `${val.name}: ${val.message}\\n${val.stack}`;\n    }\n    // TODO we could test for more things here, like `Set`s and `Map`s.\n    return className;\n}\n\nfunction getArrayU8FromWasm0(ptr, len) {\n    return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);\n}\n\nfunction passArray8ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 1);\n    getUint8Memory0().set(arg, ptr / 1);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nfunction _assertClass(instance, klass) {\n    if (!(instance instanceof klass)) {\n        throw new Error(`expected instance of ${klass.name}`);\n    }\n    return instance.ptr;\n}\n\nlet cachegetUint32Memory0 = null;\nfunction getUint32Memory0() {\n    if (cachegetUint32Memory0 === null || cachegetUint32Memory0.buffer !== _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.memory.buffer) {\n        cachegetUint32Memory0 = new Uint32Array(_cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.memory.buffer);\n    }\n    return cachegetUint32Memory0;\n}\n\nfunction getArrayU32FromWasm0(ptr, len) {\n    return getUint32Memory0().subarray(ptr / 4, ptr / 4 + len);\n}\n\nfunction passArray32ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 4);\n    getUint32Memory0().set(arg, ptr / 4);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n/**\n* @param {TransactionHash} tx_body_hash\n* @param {ByronAddress} addr\n* @param {LegacyDaedalusPrivateKey} key\n* @returns {BootstrapWitness}\n*/\nfunction make_daedalus_bootstrap_witness(tx_body_hash, addr, key) {\n    _assertClass(tx_body_hash, TransactionHash);\n    _assertClass(addr, ByronAddress);\n    _assertClass(key, LegacyDaedalusPrivateKey);\n    var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.make_daedalus_bootstrap_witness(tx_body_hash.ptr, addr.ptr, key.ptr);\n    return BootstrapWitness.__wrap(ret);\n}\n\n/**\n* @param {TransactionHash} tx_body_hash\n* @param {ByronAddress} addr\n* @param {Bip32PrivateKey} key\n* @returns {BootstrapWitness}\n*/\nfunction make_icarus_bootstrap_witness(tx_body_hash, addr, key) {\n    _assertClass(tx_body_hash, TransactionHash);\n    _assertClass(addr, ByronAddress);\n    _assertClass(key, Bip32PrivateKey);\n    var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.make_icarus_bootstrap_witness(tx_body_hash.ptr, addr.ptr, key.ptr);\n    return BootstrapWitness.__wrap(ret);\n}\n\n/**\n* @param {TransactionHash} tx_body_hash\n* @param {PrivateKey} sk\n* @returns {Vkeywitness}\n*/\nfunction make_vkey_witness(tx_body_hash, sk) {\n    _assertClass(tx_body_hash, TransactionHash);\n    _assertClass(sk, PrivateKey);\n    var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.make_vkey_witness(tx_body_hash.ptr, sk.ptr);\n    return Vkeywitness.__wrap(ret);\n}\n\n/**\n* @param {AuxiliaryData} auxiliary_data\n* @returns {AuxiliaryDataHash}\n*/\nfunction hash_auxiliary_data(auxiliary_data) {\n    _assertClass(auxiliary_data, AuxiliaryData);\n    var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.hash_auxiliary_data(auxiliary_data.ptr);\n    return AuxiliaryDataHash.__wrap(ret);\n}\n\n/**\n* @param {TransactionBody} tx_body\n* @returns {TransactionHash}\n*/\nfunction hash_transaction(tx_body) {\n    _assertClass(tx_body, TransactionBody);\n    var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.hash_transaction(tx_body.ptr);\n    return TransactionHash.__wrap(ret);\n}\n\n/**\n* @param {PlutusData} plutus_data\n* @returns {DataHash}\n*/\nfunction hash_plutus_data(plutus_data) {\n    _assertClass(plutus_data, PlutusData);\n    var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.hash_plutus_data(plutus_data.ptr);\n    return DataHash.__wrap(ret);\n}\n\n/**\n* @param {Redeemers} redeemers\n* @param {Costmdls} cost_models\n* @param {PlutusList | undefined} datums\n* @returns {ScriptDataHash}\n*/\nfunction hash_script_data(redeemers, cost_models, datums) {\n    _assertClass(redeemers, Redeemers);\n    _assertClass(cost_models, Costmdls);\n    let ptr0 = 0;\n    if (!isLikeNone(datums)) {\n        _assertClass(datums, PlutusList);\n        ptr0 = datums.ptr;\n        datums.ptr = 0;\n    }\n    var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.hash_script_data(redeemers.ptr, cost_models.ptr, ptr0);\n    return ScriptDataHash.__wrap(ret);\n}\n\n/**\n* @param {TransactionBody} txbody\n* @param {BigNum} pool_deposit\n* @param {BigNum} key_deposit\n* @returns {Value}\n*/\nfunction get_implicit_input(txbody, pool_deposit, key_deposit) {\n    _assertClass(txbody, TransactionBody);\n    _assertClass(pool_deposit, BigNum);\n    _assertClass(key_deposit, BigNum);\n    var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.get_implicit_input(txbody.ptr, pool_deposit.ptr, key_deposit.ptr);\n    return Value.__wrap(ret);\n}\n\n/**\n* @param {TransactionBody} txbody\n* @param {BigNum} pool_deposit\n* @param {BigNum} key_deposit\n* @returns {BigNum}\n*/\nfunction get_deposit(txbody, pool_deposit, key_deposit) {\n    _assertClass(txbody, TransactionBody);\n    _assertClass(pool_deposit, BigNum);\n    _assertClass(key_deposit, BigNum);\n    var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.get_deposit(txbody.ptr, pool_deposit.ptr, key_deposit.ptr);\n    return BigNum.__wrap(ret);\n}\n\n/**\n* @param {Value} assets\n* @param {boolean} has_data_hash\n* @param {BigNum} coins_per_utxo_word\n* @returns {BigNum}\n*/\nfunction min_ada_required(assets, has_data_hash, coins_per_utxo_word) {\n    _assertClass(assets, Value);\n    _assertClass(coins_per_utxo_word, BigNum);\n    var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.min_ada_required(assets.ptr, has_data_hash, coins_per_utxo_word.ptr);\n    return BigNum.__wrap(ret);\n}\n\n/**\n* Receives a script JSON string\n* and returns a NativeScript.\n* Cardano Wallet and Node styles are supported.\n*\n* * wallet: https://github.com/input-output-hk/cardano-wallet/blob/master/specifications/api/swagger.yaml\n* * node: https://github.com/input-output-hk/cardano-node/blob/master/doc/reference/simple-scripts.md\n*\n* self_xpub is expected to be a Bip32PublicKey as hex-encoded bytes\n* @param {string} json\n* @param {string} self_xpub\n* @param {number} schema\n* @returns {NativeScript}\n*/\nfunction encode_json_str_to_native_script(json, self_xpub, schema) {\n    var ptr0 = passStringToWasm0(json, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_realloc);\n    var len0 = WASM_VECTOR_LEN;\n    var ptr1 = passStringToWasm0(self_xpub, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_realloc);\n    var len1 = WASM_VECTOR_LEN;\n    var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.encode_json_str_to_native_script(ptr0, len0, ptr1, len1, schema);\n    return NativeScript.__wrap(ret);\n}\n\n/**\n* @param {Uint8Array} bytes\n* @returns {TransactionMetadatum}\n*/\nfunction encode_arbitrary_bytes_as_metadatum(bytes) {\n    var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n    var len0 = WASM_VECTOR_LEN;\n    var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.encode_arbitrary_bytes_as_metadatum(ptr0, len0);\n    return TransactionMetadatum.__wrap(ret);\n}\n\n/**\n* @param {TransactionMetadatum} metadata\n* @returns {Uint8Array}\n*/\nfunction decode_arbitrary_bytes_from_metadatum(metadata) {\n    try {\n        const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n        _assertClass(metadata, TransactionMetadatum);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.decode_arbitrary_bytes_from_metadatum(retptr, metadata.ptr);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var v0 = getArrayU8FromWasm0(r0, r1).slice();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n        return v0;\n    } finally {\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {string} json\n* @param {number} schema\n* @returns {TransactionMetadatum}\n*/\nfunction encode_json_str_to_metadatum(json, schema) {\n    var ptr0 = passStringToWasm0(json, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_realloc);\n    var len0 = WASM_VECTOR_LEN;\n    var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.encode_json_str_to_metadatum(ptr0, len0, schema);\n    return TransactionMetadatum.__wrap(ret);\n}\n\n/**\n* @param {TransactionMetadatum} metadatum\n* @param {number} schema\n* @returns {string}\n*/\nfunction decode_metadatum_to_json_str(metadatum, schema) {\n    try {\n        const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n        _assertClass(metadatum, TransactionMetadatum);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.decode_metadatum_to_json_str(retptr, metadatum.ptr, schema);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        return getStringFromWasm0(r0, r1);\n    } finally {\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1);\n    }\n}\n\n/**\n* @param {string} password\n* @param {string} salt\n* @param {string} nonce\n* @param {string} data\n* @returns {string}\n*/\nfunction encrypt_with_password(password, salt, nonce, data) {\n    try {\n        const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n        var ptr0 = passStringToWasm0(password, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ptr1 = passStringToWasm0(salt, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_realloc);\n        var len1 = WASM_VECTOR_LEN;\n        var ptr2 = passStringToWasm0(nonce, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_realloc);\n        var len2 = WASM_VECTOR_LEN;\n        var ptr3 = passStringToWasm0(data, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_realloc);\n        var len3 = WASM_VECTOR_LEN;\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.encrypt_with_password(retptr, ptr0, len0, ptr1, len1, ptr2, len2, ptr3, len3);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        return getStringFromWasm0(r0, r1);\n    } finally {\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1);\n    }\n}\n\n/**\n* @param {string} password\n* @param {string} data\n* @returns {string}\n*/\nfunction decrypt_with_password(password, data) {\n    try {\n        const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n        var ptr0 = passStringToWasm0(password, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ptr1 = passStringToWasm0(data, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_realloc);\n        var len1 = WASM_VECTOR_LEN;\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.decrypt_with_password(retptr, ptr0, len0, ptr1, len1);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        return getStringFromWasm0(r0, r1);\n    } finally {\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1);\n    }\n}\n\n/**\n* @param {Transaction} tx\n* @param {LinearFee} linear_fee\n* @returns {BigNum}\n*/\nfunction min_fee(tx, linear_fee) {\n    _assertClass(tx, Transaction);\n    _assertClass(linear_fee, LinearFee);\n    var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.min_fee(tx.ptr, linear_fee.ptr);\n    return BigNum.__wrap(ret);\n}\n\nfunction handleError(f, args) {\n    try {\n        return f.apply(this, args);\n    } catch (e) {\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_exn_store(addHeapObject(e));\n    }\n}\n/**\n*/\nconst CertificateKind = Object.freeze({ StakeRegistration:0,\"0\":\"StakeRegistration\",StakeDeregistration:1,\"1\":\"StakeDeregistration\",StakeDelegation:2,\"2\":\"StakeDelegation\",PoolRegistration:3,\"3\":\"PoolRegistration\",PoolRetirement:4,\"4\":\"PoolRetirement\",GenesisKeyDelegation:5,\"5\":\"GenesisKeyDelegation\",MoveInstantaneousRewardsCert:6,\"6\":\"MoveInstantaneousRewardsCert\", });\n/**\n*/\nconst MIRPot = Object.freeze({ Reserves:0,\"0\":\"Reserves\",Treasury:1,\"1\":\"Treasury\", });\n/**\n*/\nconst MIRKind = Object.freeze({ ToOtherPot:0,\"0\":\"ToOtherPot\",ToStakeCredentials:1,\"1\":\"ToStakeCredentials\", });\n/**\n*/\nconst RelayKind = Object.freeze({ SingleHostAddr:0,\"0\":\"SingleHostAddr\",SingleHostName:1,\"1\":\"SingleHostName\",MultiHostName:2,\"2\":\"MultiHostName\", });\n/**\n*/\nconst NativeScriptKind = Object.freeze({ ScriptPubkey:0,\"0\":\"ScriptPubkey\",ScriptAll:1,\"1\":\"ScriptAll\",ScriptAny:2,\"2\":\"ScriptAny\",ScriptNOfK:3,\"3\":\"ScriptNOfK\",TimelockStart:4,\"4\":\"TimelockStart\",TimelockExpiry:5,\"5\":\"TimelockExpiry\", });\n/**\n* Each new language uses a different namespace for hashing its script\n* This is because you could have a language where the same bytes have different semantics\n* So this avoids scripts in different languages mapping to the same hash\n* Note that the enum value here is different than the enum value for deciding the cost model of a script\n*/\nconst ScriptHashNamespace = Object.freeze({ NativeScript:0,\"0\":\"NativeScript\", });\n/**\n*/\nconst NetworkIdKind = Object.freeze({ Testnet:0,\"0\":\"Testnet\",Mainnet:1,\"1\":\"Mainnet\", });\n/**\n*/\nconst StakeCredKind = Object.freeze({ Key:0,\"0\":\"Key\",Script:1,\"1\":\"Script\", });\n/**\n*/\nconst LanguageKind = Object.freeze({ PlutusV1:0,\"0\":\"PlutusV1\", });\n/**\n*/\nconst PlutusDataKind = Object.freeze({ ConstrPlutusData:0,\"0\":\"ConstrPlutusData\",Map:1,\"1\":\"Map\",List:2,\"2\":\"List\",Integer:3,\"3\":\"Integer\",Bytes:4,\"4\":\"Bytes\", });\n/**\n*/\nconst RedeemerTagKind = Object.freeze({ Spend:0,\"0\":\"Spend\",Mint:1,\"1\":\"Mint\",Cert:2,\"2\":\"Cert\",Reward:3,\"3\":\"Reward\", });\n/**\n* Used to choosed the schema for a script JSON string\n*/\nconst ScriptSchema = Object.freeze({ Wallet:0,\"0\":\"Wallet\",Node:1,\"1\":\"Node\", });\n/**\n*/\nconst TransactionMetadatumKind = Object.freeze({ MetadataMap:0,\"0\":\"MetadataMap\",MetadataList:1,\"1\":\"MetadataList\",Int:2,\"2\":\"Int\",Bytes:3,\"3\":\"Bytes\",Text:4,\"4\":\"Text\", });\n/**\n*/\nconst MetadataJsonSchema = Object.freeze({ NoConversions:0,\"0\":\"NoConversions\",BasicConversions:1,\"1\":\"BasicConversions\",DetailedSchema:2,\"2\":\"DetailedSchema\", });\n/**\n*/\nconst CoinSelectionStrategyCIP2 = Object.freeze({ LargestFirst:0,\"0\":\"LargestFirst\",RandomImprove:1,\"1\":\"RandomImprove\", });\n/**\n*/\nclass Address {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Address.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_address_free(ptr);\n    }\n    /**\n    * @param {Uint8Array} data\n    * @returns {Address}\n    */\n    static from_bytes(data) {\n        var ptr0 = passArray8ToWasm0(data, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.address_from_bytes(ptr0, len0);\n        return Address.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.address_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string | undefined} prefix\n    * @returns {string}\n    */\n    to_bech32(prefix) {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = isLikeNone(prefix) ? 0 : passStringToWasm0(prefix, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.address_to_bech32(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} bech_str\n    * @returns {Address}\n    */\n    static from_bech32(bech_str) {\n        var ptr0 = passStringToWasm0(bech_str, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.address_from_bech32(ptr0, len0);\n        return Address.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    network_id() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.address_network_id(this.ptr);\n        return ret;\n    }\n}\n/**\n*/\nclass AssetName {\n\n    static __wrap(ptr) {\n        const obj = Object.create(AssetName.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_assetname_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.assetname_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {AssetName}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.assetname_from_bytes(ptr0, len0);\n        return AssetName.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} name\n    * @returns {AssetName}\n    */\n    static new(name) {\n        var ptr0 = passArray8ToWasm0(name, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.assetname_new(ptr0, len0);\n        return AssetName.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    name() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.assetname_name(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nclass AssetNames {\n\n    static __wrap(ptr) {\n        const obj = Object.create(AssetNames.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_assetnames_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.assetnames_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {AssetNames}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.assetnames_from_bytes(ptr0, len0);\n        return AssetNames.__wrap(ret);\n    }\n    /**\n    * @returns {AssetNames}\n    */\n    static new() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.assetnames_new();\n        return AssetNames.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.assetnames_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {AssetName}\n    */\n    get(index) {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.assetnames_get(this.ptr, index);\n        return AssetName.__wrap(ret);\n    }\n    /**\n    * @param {AssetName} elem\n    */\n    add(elem) {\n        _assertClass(elem, AssetName);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.assetnames_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nclass Assets {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Assets.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_assets_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.assets_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Assets}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.assets_from_bytes(ptr0, len0);\n        return Assets.__wrap(ret);\n    }\n    /**\n    * @returns {Assets}\n    */\n    static new() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.assets_new();\n        return Assets.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.assets_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {AssetName} key\n    * @param {BigNum} value\n    * @returns {BigNum | undefined}\n    */\n    insert(key, value) {\n        _assertClass(key, AssetName);\n        _assertClass(value, BigNum);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.assets_insert(this.ptr, key.ptr, value.ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @param {AssetName} key\n    * @returns {BigNum | undefined}\n    */\n    get(key) {\n        _assertClass(key, AssetName);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.assets_get(this.ptr, key.ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {AssetNames}\n    */\n    keys() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.assets_keys(this.ptr);\n        return AssetNames.__wrap(ret);\n    }\n}\n/**\n*/\nclass AuxiliaryData {\n\n    static __wrap(ptr) {\n        const obj = Object.create(AuxiliaryData.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_auxiliarydata_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.auxiliarydata_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {AuxiliaryData}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.auxiliarydata_from_bytes(ptr0, len0);\n        return AuxiliaryData.__wrap(ret);\n    }\n    /**\n    * @returns {AuxiliaryData}\n    */\n    static new() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.auxiliarydata_new();\n        return AuxiliaryData.__wrap(ret);\n    }\n    /**\n    * @returns {GeneralTransactionMetadata | undefined}\n    */\n    metadata() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.auxiliarydata_metadata(this.ptr);\n        return ret === 0 ? undefined : GeneralTransactionMetadata.__wrap(ret);\n    }\n    /**\n    * @param {GeneralTransactionMetadata} metadata\n    */\n    set_metadata(metadata) {\n        _assertClass(metadata, GeneralTransactionMetadata);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.auxiliarydata_set_metadata(this.ptr, metadata.ptr);\n    }\n    /**\n    * @returns {NativeScripts | undefined}\n    */\n    native_scripts() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.auxiliarydata_native_scripts(this.ptr);\n        return ret === 0 ? undefined : NativeScripts.__wrap(ret);\n    }\n    /**\n    * @param {NativeScripts} native_scripts\n    */\n    set_native_scripts(native_scripts) {\n        _assertClass(native_scripts, NativeScripts);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.auxiliarydata_set_native_scripts(this.ptr, native_scripts.ptr);\n    }\n    /**\n    * @returns {PlutusScripts | undefined}\n    */\n    plutus_scripts() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.auxiliarydata_plutus_scripts(this.ptr);\n        return ret === 0 ? undefined : PlutusScripts.__wrap(ret);\n    }\n    /**\n    * @param {PlutusScripts} plutus_scripts\n    */\n    set_plutus_scripts(plutus_scripts) {\n        _assertClass(plutus_scripts, PlutusScripts);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.auxiliarydata_set_plutus_scripts(this.ptr, plutus_scripts.ptr);\n    }\n}\n/**\n*/\nclass AuxiliaryDataHash {\n\n    static __wrap(ptr) {\n        const obj = Object.create(AuxiliaryDataHash.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_auxiliarydatahash_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.auxiliarydatahash_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} prefix\n    * @returns {string}\n    */\n    to_bech32(prefix) {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(prefix, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.auxiliarydatahash_to_bech32(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} bech_str\n    * @returns {AuxiliaryDataHash}\n    */\n    static from_bech32(bech_str) {\n        var ptr0 = passStringToWasm0(bech_str, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.auxiliarydatahash_from_bech32(ptr0, len0);\n        return AuxiliaryDataHash.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {AuxiliaryDataHash}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.auxiliarydatahash_from_bytes(ptr0, len0);\n        return AuxiliaryDataHash.__wrap(ret);\n    }\n}\n/**\n*/\nclass AuxiliaryDataSet {\n\n    static __wrap(ptr) {\n        const obj = Object.create(AuxiliaryDataSet.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_auxiliarydataset_free(ptr);\n    }\n    /**\n    * @returns {AuxiliaryDataSet}\n    */\n    static new() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.auxiliarydataset_new();\n        return AuxiliaryDataSet.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.auxiliarydataset_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} tx_index\n    * @param {AuxiliaryData} data\n    * @returns {AuxiliaryData | undefined}\n    */\n    insert(tx_index, data) {\n        _assertClass(data, AuxiliaryData);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.auxiliarydataset_insert(this.ptr, tx_index, data.ptr);\n        return ret === 0 ? undefined : AuxiliaryData.__wrap(ret);\n    }\n    /**\n    * @param {number} tx_index\n    * @returns {AuxiliaryData | undefined}\n    */\n    get(tx_index) {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.auxiliarydataset_get(this.ptr, tx_index);\n        return ret === 0 ? undefined : AuxiliaryData.__wrap(ret);\n    }\n    /**\n    * @returns {Uint32Array}\n    */\n    indices() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.auxiliarydataset_indices(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU32FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 4);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nclass BaseAddress {\n\n    static __wrap(ptr) {\n        const obj = Object.create(BaseAddress.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_baseaddress_free(ptr);\n    }\n    /**\n    * @param {number} network\n    * @param {StakeCredential} payment\n    * @param {StakeCredential} stake\n    * @returns {BaseAddress}\n    */\n    static new(network, payment, stake) {\n        _assertClass(payment, StakeCredential);\n        _assertClass(stake, StakeCredential);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.baseaddress_new(network, payment.ptr, stake.ptr);\n        return BaseAddress.__wrap(ret);\n    }\n    /**\n    * @returns {StakeCredential}\n    */\n    payment_cred() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.baseaddress_payment_cred(this.ptr);\n        return StakeCredential.__wrap(ret);\n    }\n    /**\n    * @returns {StakeCredential}\n    */\n    stake_cred() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.baseaddress_stake_cred(this.ptr);\n        return StakeCredential.__wrap(ret);\n    }\n    /**\n    * @returns {Address}\n    */\n    to_address() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.baseaddress_to_address(this.ptr);\n        return Address.__wrap(ret);\n    }\n    /**\n    * @param {Address} addr\n    * @returns {BaseAddress | undefined}\n    */\n    static from_address(addr) {\n        _assertClass(addr, Address);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.baseaddress_from_address(addr.ptr);\n        return ret === 0 ? undefined : BaseAddress.__wrap(ret);\n    }\n}\n/**\n*/\nclass BigInt {\n\n    static __wrap(ptr) {\n        const obj = Object.create(BigInt.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_bigint_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.bigint_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {BigInt}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.bigint_from_bytes(ptr0, len0);\n        return BigInt.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum | undefined}\n    */\n    as_u64() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.bigint_as_u64(this.ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @param {string} text\n    * @returns {BigInt}\n    */\n    static from_str(text) {\n        var ptr0 = passStringToWasm0(text, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.bigint_from_str(ptr0, len0);\n        return BigInt.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_str() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.bigint_to_str(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1);\n        }\n    }\n}\n/**\n*/\nclass BigNum {\n\n    static __wrap(ptr) {\n        const obj = Object.create(BigNum.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_bignum_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.bignum_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {BigNum}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.bignum_from_bytes(ptr0, len0);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @param {string} string\n    * @returns {BigNum}\n    */\n    static from_str(string) {\n        var ptr0 = passStringToWasm0(string, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.bignum_from_str(ptr0, len0);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_str() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.bignum_to_str(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {BigNum}\n    */\n    static zero() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.bignum_zero();\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {boolean}\n    */\n    is_zero() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.bignum_is_zero(this.ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {BigNum} other\n    * @returns {BigNum}\n    */\n    checked_mul(other) {\n        _assertClass(other, BigNum);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.bignum_checked_mul(this.ptr, other.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} other\n    * @returns {BigNum}\n    */\n    checked_add(other) {\n        _assertClass(other, BigNum);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.bignum_checked_add(this.ptr, other.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} other\n    * @returns {BigNum}\n    */\n    checked_sub(other) {\n        _assertClass(other, BigNum);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.bignum_checked_sub(this.ptr, other.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * returns 0 if it would otherwise underflow\n    * @param {BigNum} other\n    * @returns {BigNum}\n    */\n    clamped_sub(other) {\n        _assertClass(other, BigNum);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.bignum_clamped_sub(this.ptr, other.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} rhs_value\n    * @returns {number}\n    */\n    compare(rhs_value) {\n        _assertClass(rhs_value, BigNum);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.bignum_compare(this.ptr, rhs_value.ptr);\n        return ret;\n    }\n}\n/**\n*/\nclass Bip32PrivateKey {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Bip32PrivateKey.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_bip32privatekey_free(ptr);\n    }\n    /**\n    * derive this private key with the given index.\n    *\n    * # Security considerations\n    *\n    * * hard derivation index cannot be soft derived with the public key\n    *\n    * # Hard derivation vs Soft derivation\n    *\n    * If you pass an index below 0x80000000 then it is a soft derivation.\n    * The advantage of soft derivation is that it is possible to derive the\n    * public key too. I.e. derivation the private key with a soft derivation\n    * index and then retrieving the associated public key is equivalent to\n    * deriving the public key associated to the parent private key.\n    *\n    * Hard derivation index does not allow public key derivation.\n    *\n    * This is why deriving the private key should not fail while deriving\n    * the public key may fail (if the derivation index is invalid).\n    * @param {number} index\n    * @returns {Bip32PrivateKey}\n    */\n    derive(index) {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.bip32privatekey_derive(this.ptr, index);\n        return Bip32PrivateKey.__wrap(ret);\n    }\n    /**\n    * 128-byte xprv a key format in Cardano that some software still uses or requires\n    * the traditional 96-byte xprv is simply encoded as\n    * prv | chaincode\n    * however, because some software may not know how to compute a public key from a private key,\n    * the 128-byte inlines the public key in the following format\n    * prv | pub | chaincode\n    * so be careful if you see the term \"xprv\" as it could refer to either one\n    * our library does not require the pub (instead we compute the pub key when needed)\n    * @param {Uint8Array} bytes\n    * @returns {Bip32PrivateKey}\n    */\n    static from_128_xprv(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.bip32privatekey_from_128_xprv(ptr0, len0);\n        return Bip32PrivateKey.__wrap(ret);\n    }\n    /**\n    * see from_128_xprv\n    * @returns {Uint8Array}\n    */\n    to_128_xprv() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.bip32privatekey_to_128_xprv(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Bip32PrivateKey}\n    */\n    static generate_ed25519_bip32() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.bip32privatekey_generate_ed25519_bip32();\n        return Bip32PrivateKey.__wrap(ret);\n    }\n    /**\n    * @returns {PrivateKey}\n    */\n    to_raw_key() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.bip32privatekey_to_raw_key(this.ptr);\n        return PrivateKey.__wrap(ret);\n    }\n    /**\n    * @returns {Bip32PublicKey}\n    */\n    to_public() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.bip32privatekey_to_public(this.ptr);\n        return Bip32PublicKey.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Bip32PrivateKey}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.bip32privatekey_from_bytes(ptr0, len0);\n        return Bip32PrivateKey.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    as_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.bip32privatekey_as_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} bech32_str\n    * @returns {Bip32PrivateKey}\n    */\n    static from_bech32(bech32_str) {\n        var ptr0 = passStringToWasm0(bech32_str, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.bip32privatekey_from_bech32(ptr0, len0);\n        return Bip32PrivateKey.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_bech32() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.bip32privatekey_to_bech32(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {Uint8Array} entropy\n    * @param {Uint8Array} password\n    * @returns {Bip32PrivateKey}\n    */\n    static from_bip39_entropy(entropy, password) {\n        var ptr0 = passArray8ToWasm0(entropy, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ptr1 = passArray8ToWasm0(password, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len1 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.bip32privatekey_from_bip39_entropy(ptr0, len0, ptr1, len1);\n        return Bip32PrivateKey.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    chaincode() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.bip32privatekey_chaincode(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nclass Bip32PublicKey {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Bip32PublicKey.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_bip32publickey_free(ptr);\n    }\n    /**\n    * derive this public key with the given index.\n    *\n    * # Errors\n    *\n    * If the index is not a soft derivation index (< 0x80000000) then\n    * calling this method will fail.\n    *\n    * # Security considerations\n    *\n    * * hard derivation index cannot be soft derived with the public key\n    *\n    * # Hard derivation vs Soft derivation\n    *\n    * If you pass an index below 0x80000000 then it is a soft derivation.\n    * The advantage of soft derivation is that it is possible to derive the\n    * public key too. I.e. derivation the private key with a soft derivation\n    * index and then retrieving the associated public key is equivalent to\n    * deriving the public key associated to the parent private key.\n    *\n    * Hard derivation index does not allow public key derivation.\n    *\n    * This is why deriving the private key should not fail while deriving\n    * the public key may fail (if the derivation index is invalid).\n    * @param {number} index\n    * @returns {Bip32PublicKey}\n    */\n    derive(index) {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.bip32publickey_derive(this.ptr, index);\n        return Bip32PublicKey.__wrap(ret);\n    }\n    /**\n    * @returns {PublicKey}\n    */\n    to_raw_key() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.bip32publickey_to_raw_key(this.ptr);\n        return PublicKey.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Bip32PublicKey}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.bip32publickey_from_bytes(ptr0, len0);\n        return Bip32PublicKey.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    as_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.bip32publickey_as_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} bech32_str\n    * @returns {Bip32PublicKey}\n    */\n    static from_bech32(bech32_str) {\n        var ptr0 = passStringToWasm0(bech32_str, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.bip32publickey_from_bech32(ptr0, len0);\n        return Bip32PublicKey.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_bech32() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.bip32publickey_to_bech32(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    chaincode() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.bip32publickey_chaincode(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nclass Block {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Block.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_block_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.block_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Block}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.block_from_bytes(ptr0, len0);\n        return Block.__wrap(ret);\n    }\n    /**\n    * @returns {Header}\n    */\n    header() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.block_header(this.ptr);\n        return Header.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionBodies}\n    */\n    transaction_bodies() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.block_transaction_bodies(this.ptr);\n        return TransactionBodies.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionWitnessSets}\n    */\n    transaction_witness_sets() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.block_transaction_witness_sets(this.ptr);\n        return TransactionWitnessSets.__wrap(ret);\n    }\n    /**\n    * @returns {AuxiliaryDataSet}\n    */\n    auxiliary_data_set() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.block_auxiliary_data_set(this.ptr);\n        return AuxiliaryDataSet.__wrap(ret);\n    }\n    /**\n    * @returns {Uint32Array}\n    */\n    invalid_transactions() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.block_invalid_transactions(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU32FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 4);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Header} header\n    * @param {TransactionBodies} transaction_bodies\n    * @param {TransactionWitnessSets} transaction_witness_sets\n    * @param {AuxiliaryDataSet} auxiliary_data_set\n    * @param {Uint32Array} invalid_transactions\n    * @returns {Block}\n    */\n    static new(header, transaction_bodies, transaction_witness_sets, auxiliary_data_set, invalid_transactions) {\n        _assertClass(header, Header);\n        _assertClass(transaction_bodies, TransactionBodies);\n        _assertClass(transaction_witness_sets, TransactionWitnessSets);\n        _assertClass(auxiliary_data_set, AuxiliaryDataSet);\n        var ptr0 = passArray32ToWasm0(invalid_transactions, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.block_new(header.ptr, transaction_bodies.ptr, transaction_witness_sets.ptr, auxiliary_data_set.ptr, ptr0, len0);\n        return Block.__wrap(ret);\n    }\n}\n/**\n*/\nclass BlockHash {\n\n    static __wrap(ptr) {\n        const obj = Object.create(BlockHash.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_blockhash_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.blockhash_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} prefix\n    * @returns {string}\n    */\n    to_bech32(prefix) {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(prefix, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.blockhash_to_bech32(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} bech_str\n    * @returns {BlockHash}\n    */\n    static from_bech32(bech_str) {\n        var ptr0 = passStringToWasm0(bech_str, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.blockhash_from_bech32(ptr0, len0);\n        return BlockHash.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {BlockHash}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.blockhash_from_bytes(ptr0, len0);\n        return BlockHash.__wrap(ret);\n    }\n}\n/**\n*/\nclass BootstrapWitness {\n\n    static __wrap(ptr) {\n        const obj = Object.create(BootstrapWitness.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_bootstrapwitness_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.bootstrapwitness_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {BootstrapWitness}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.bootstrapwitness_from_bytes(ptr0, len0);\n        return BootstrapWitness.__wrap(ret);\n    }\n    /**\n    * @returns {Vkey}\n    */\n    vkey() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.bootstrapwitness_vkey(this.ptr);\n        return Vkey.__wrap(ret);\n    }\n    /**\n    * @returns {Ed25519Signature}\n    */\n    signature() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.bootstrapwitness_signature(this.ptr);\n        return Ed25519Signature.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    chain_code() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.bootstrapwitness_chain_code(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    attributes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.bootstrapwitness_attributes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Vkey} vkey\n    * @param {Ed25519Signature} signature\n    * @param {Uint8Array} chain_code\n    * @param {Uint8Array} attributes\n    * @returns {BootstrapWitness}\n    */\n    static new(vkey, signature, chain_code, attributes) {\n        _assertClass(vkey, Vkey);\n        _assertClass(signature, Ed25519Signature);\n        var ptr0 = passArray8ToWasm0(chain_code, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ptr1 = passArray8ToWasm0(attributes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len1 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.bootstrapwitness_new(vkey.ptr, signature.ptr, ptr0, len0, ptr1, len1);\n        return BootstrapWitness.__wrap(ret);\n    }\n}\n/**\n*/\nclass BootstrapWitnesses {\n\n    static __wrap(ptr) {\n        const obj = Object.create(BootstrapWitnesses.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_bootstrapwitnesses_free(ptr);\n    }\n    /**\n    * @returns {BootstrapWitnesses}\n    */\n    static new() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.bootstrapwitnesses_new();\n        return BootstrapWitnesses.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.bootstrapwitnesses_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {BootstrapWitness}\n    */\n    get(index) {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.bootstrapwitnesses_get(this.ptr, index);\n        return BootstrapWitness.__wrap(ret);\n    }\n    /**\n    * @param {BootstrapWitness} elem\n    */\n    add(elem) {\n        _assertClass(elem, BootstrapWitness);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.bootstrapwitnesses_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nclass ByronAddress {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ByronAddress.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_byronaddress_free(ptr);\n    }\n    /**\n    * @returns {string}\n    */\n    to_base58() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.byronaddress_to_base58(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.byronaddress_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ByronAddress}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.byronaddress_from_bytes(ptr0, len0);\n        return ByronAddress.__wrap(ret);\n    }\n    /**\n    * returns the byron protocol magic embedded in the address, or mainnet id if none is present\n    * note: for bech32 addresses, you need to use network_id instead\n    * @returns {number}\n    */\n    byron_protocol_magic() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.byronaddress_byron_protocol_magic(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    attributes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.byronaddress_attributes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {number}\n    */\n    network_id() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.byronaddress_network_id(this.ptr);\n        return ret;\n    }\n    /**\n    * @param {string} s\n    * @returns {ByronAddress}\n    */\n    static from_base58(s) {\n        var ptr0 = passStringToWasm0(s, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.byronaddress_from_base58(ptr0, len0);\n        return ByronAddress.__wrap(ret);\n    }\n    /**\n    * @param {Bip32PublicKey} key\n    * @param {number} protocol_magic\n    * @returns {ByronAddress}\n    */\n    static icarus_from_key(key, protocol_magic) {\n        _assertClass(key, Bip32PublicKey);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.byronaddress_icarus_from_key(key.ptr, protocol_magic);\n        return ByronAddress.__wrap(ret);\n    }\n    /**\n    * @param {string} s\n    * @returns {boolean}\n    */\n    static is_valid(s) {\n        var ptr0 = passStringToWasm0(s, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.byronaddress_is_valid(ptr0, len0);\n        return ret !== 0;\n    }\n    /**\n    * @returns {Address}\n    */\n    to_address() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.byronaddress_to_address(this.ptr);\n        return Address.__wrap(ret);\n    }\n    /**\n    * @param {Address} addr\n    * @returns {ByronAddress | undefined}\n    */\n    static from_address(addr) {\n        _assertClass(addr, Address);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.byronaddress_from_address(addr.ptr);\n        return ret === 0 ? undefined : ByronAddress.__wrap(ret);\n    }\n}\n/**\n*/\nclass Certificate {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Certificate.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_certificate_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.certificate_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Certificate}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.certificate_from_bytes(ptr0, len0);\n        return Certificate.__wrap(ret);\n    }\n    /**\n    * @param {StakeRegistration} stake_registration\n    * @returns {Certificate}\n    */\n    static new_stake_registration(stake_registration) {\n        _assertClass(stake_registration, StakeRegistration);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.certificate_new_stake_registration(stake_registration.ptr);\n        return Certificate.__wrap(ret);\n    }\n    /**\n    * @param {StakeDeregistration} stake_deregistration\n    * @returns {Certificate}\n    */\n    static new_stake_deregistration(stake_deregistration) {\n        _assertClass(stake_deregistration, StakeDeregistration);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.certificate_new_stake_deregistration(stake_deregistration.ptr);\n        return Certificate.__wrap(ret);\n    }\n    /**\n    * @param {StakeDelegation} stake_delegation\n    * @returns {Certificate}\n    */\n    static new_stake_delegation(stake_delegation) {\n        _assertClass(stake_delegation, StakeDelegation);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.certificate_new_stake_delegation(stake_delegation.ptr);\n        return Certificate.__wrap(ret);\n    }\n    /**\n    * @param {PoolRegistration} pool_registration\n    * @returns {Certificate}\n    */\n    static new_pool_registration(pool_registration) {\n        _assertClass(pool_registration, PoolRegistration);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.certificate_new_pool_registration(pool_registration.ptr);\n        return Certificate.__wrap(ret);\n    }\n    /**\n    * @param {PoolRetirement} pool_retirement\n    * @returns {Certificate}\n    */\n    static new_pool_retirement(pool_retirement) {\n        _assertClass(pool_retirement, PoolRetirement);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.certificate_new_pool_retirement(pool_retirement.ptr);\n        return Certificate.__wrap(ret);\n    }\n    /**\n    * @param {GenesisKeyDelegation} genesis_key_delegation\n    * @returns {Certificate}\n    */\n    static new_genesis_key_delegation(genesis_key_delegation) {\n        _assertClass(genesis_key_delegation, GenesisKeyDelegation);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.certificate_new_genesis_key_delegation(genesis_key_delegation.ptr);\n        return Certificate.__wrap(ret);\n    }\n    /**\n    * @param {MoveInstantaneousRewardsCert} move_instantaneous_rewards_cert\n    * @returns {Certificate}\n    */\n    static new_move_instantaneous_rewards_cert(move_instantaneous_rewards_cert) {\n        _assertClass(move_instantaneous_rewards_cert, MoveInstantaneousRewardsCert);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.certificate_new_move_instantaneous_rewards_cert(move_instantaneous_rewards_cert.ptr);\n        return Certificate.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    kind() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.certificate_kind(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {StakeRegistration | undefined}\n    */\n    as_stake_registration() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.certificate_as_stake_registration(this.ptr);\n        return ret === 0 ? undefined : StakeRegistration.__wrap(ret);\n    }\n    /**\n    * @returns {StakeDeregistration | undefined}\n    */\n    as_stake_deregistration() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.certificate_as_stake_deregistration(this.ptr);\n        return ret === 0 ? undefined : StakeDeregistration.__wrap(ret);\n    }\n    /**\n    * @returns {StakeDelegation | undefined}\n    */\n    as_stake_delegation() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.certificate_as_stake_delegation(this.ptr);\n        return ret === 0 ? undefined : StakeDelegation.__wrap(ret);\n    }\n    /**\n    * @returns {PoolRegistration | undefined}\n    */\n    as_pool_registration() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.certificate_as_pool_registration(this.ptr);\n        return ret === 0 ? undefined : PoolRegistration.__wrap(ret);\n    }\n    /**\n    * @returns {PoolRetirement | undefined}\n    */\n    as_pool_retirement() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.certificate_as_pool_retirement(this.ptr);\n        return ret === 0 ? undefined : PoolRetirement.__wrap(ret);\n    }\n    /**\n    * @returns {GenesisKeyDelegation | undefined}\n    */\n    as_genesis_key_delegation() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.certificate_as_genesis_key_delegation(this.ptr);\n        return ret === 0 ? undefined : GenesisKeyDelegation.__wrap(ret);\n    }\n    /**\n    * @returns {MoveInstantaneousRewardsCert | undefined}\n    */\n    as_move_instantaneous_rewards_cert() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.certificate_as_move_instantaneous_rewards_cert(this.ptr);\n        return ret === 0 ? undefined : MoveInstantaneousRewardsCert.__wrap(ret);\n    }\n}\n/**\n*/\nclass Certificates {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Certificates.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_certificates_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.certificates_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Certificates}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.certificates_from_bytes(ptr0, len0);\n        return Certificates.__wrap(ret);\n    }\n    /**\n    * @returns {Certificates}\n    */\n    static new() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.certificates_new();\n        return Certificates.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.certificates_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {Certificate}\n    */\n    get(index) {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.certificates_get(this.ptr, index);\n        return Certificate.__wrap(ret);\n    }\n    /**\n    * @param {Certificate} elem\n    */\n    add(elem) {\n        _assertClass(elem, Certificate);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.certificates_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nclass ConstrPlutusData {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ConstrPlutusData.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_constrplutusdata_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.constrplutusdata_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ConstrPlutusData}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.constrplutusdata_from_bytes(ptr0, len0);\n        return ConstrPlutusData.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum}\n    */\n    alternative() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.constrplutusdata_alternative(this.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {PlutusList}\n    */\n    data() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.constrplutusdata_data(this.ptr);\n        return PlutusList.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} alternative\n    * @param {PlutusList} data\n    * @returns {ConstrPlutusData}\n    */\n    static new(alternative, data) {\n        _assertClass(alternative, BigNum);\n        _assertClass(data, PlutusList);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.constrplutusdata_new(alternative.ptr, data.ptr);\n        return ConstrPlutusData.__wrap(ret);\n    }\n}\n/**\n*/\nclass CostModel {\n\n    static __wrap(ptr) {\n        const obj = Object.create(CostModel.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_costmodel_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.costmodel_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {CostModel}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.costmodel_from_bytes(ptr0, len0);\n        return CostModel.__wrap(ret);\n    }\n    /**\n    * @returns {CostModel}\n    */\n    static new() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.costmodel_new();\n        return CostModel.__wrap(ret);\n    }\n    /**\n    * @param {number} operation\n    * @param {Int} cost\n    * @returns {Int}\n    */\n    set(operation, cost) {\n        _assertClass(cost, Int);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.costmodel_set(this.ptr, operation, cost.ptr);\n        return Int.__wrap(ret);\n    }\n    /**\n    * @param {number} operation\n    * @returns {Int}\n    */\n    get(operation) {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.costmodel_get(this.ptr, operation);\n        return Int.__wrap(ret);\n    }\n}\n/**\n*/\nclass Costmdls {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Costmdls.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_costmdls_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.costmdls_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Costmdls}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.costmdls_from_bytes(ptr0, len0);\n        return Costmdls.__wrap(ret);\n    }\n    /**\n    * @returns {Costmdls}\n    */\n    static new() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.costmdls_new();\n        return Costmdls.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.costmdls_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {Language} key\n    * @param {CostModel} value\n    * @returns {CostModel | undefined}\n    */\n    insert(key, value) {\n        _assertClass(key, Language);\n        _assertClass(value, CostModel);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.costmdls_insert(this.ptr, key.ptr, value.ptr);\n        return ret === 0 ? undefined : CostModel.__wrap(ret);\n    }\n    /**\n    * @param {Language} key\n    * @returns {CostModel | undefined}\n    */\n    get(key) {\n        _assertClass(key, Language);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.costmdls_get(this.ptr, key.ptr);\n        return ret === 0 ? undefined : CostModel.__wrap(ret);\n    }\n    /**\n    * @returns {Languages}\n    */\n    keys() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.costmdls_keys(this.ptr);\n        return Languages.__wrap(ret);\n    }\n}\n/**\n*/\nclass DNSRecordAorAAAA {\n\n    static __wrap(ptr) {\n        const obj = Object.create(DNSRecordAorAAAA.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_dnsrecordaoraaaa_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.dnsrecordaoraaaa_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {DNSRecordAorAAAA}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.dnsrecordaoraaaa_from_bytes(ptr0, len0);\n        return DNSRecordAorAAAA.__wrap(ret);\n    }\n    /**\n    * @param {string} dns_name\n    * @returns {DNSRecordAorAAAA}\n    */\n    static new(dns_name) {\n        var ptr0 = passStringToWasm0(dns_name, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.dnsrecordaoraaaa_new(ptr0, len0);\n        return DNSRecordAorAAAA.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    record() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.dnsrecordaoraaaa_record(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1);\n        }\n    }\n}\n/**\n*/\nclass DNSRecordSRV {\n\n    static __wrap(ptr) {\n        const obj = Object.create(DNSRecordSRV.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_dnsrecordsrv_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.dnsrecordsrv_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {DNSRecordSRV}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.dnsrecordsrv_from_bytes(ptr0, len0);\n        return DNSRecordSRV.__wrap(ret);\n    }\n    /**\n    * @param {string} dns_name\n    * @returns {DNSRecordSRV}\n    */\n    static new(dns_name) {\n        var ptr0 = passStringToWasm0(dns_name, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.dnsrecordsrv_new(ptr0, len0);\n        return DNSRecordSRV.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    record() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.dnsrecordsrv_record(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1);\n        }\n    }\n}\n/**\n*/\nclass DataHash {\n\n    static __wrap(ptr) {\n        const obj = Object.create(DataHash.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_datahash_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.datahash_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} prefix\n    * @returns {string}\n    */\n    to_bech32(prefix) {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(prefix, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.datahash_to_bech32(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} bech_str\n    * @returns {DataHash}\n    */\n    static from_bech32(bech_str) {\n        var ptr0 = passStringToWasm0(bech_str, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.datahash_from_bech32(ptr0, len0);\n        return DataHash.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {DataHash}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.datahash_from_bytes(ptr0, len0);\n        return DataHash.__wrap(ret);\n    }\n}\n/**\n*/\nclass Ed25519KeyHash {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Ed25519KeyHash.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_ed25519keyhash_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.ed25519keyhash_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} prefix\n    * @returns {string}\n    */\n    to_bech32(prefix) {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(prefix, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.ed25519keyhash_to_bech32(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} bech_str\n    * @returns {Ed25519KeyHash}\n    */\n    static from_bech32(bech_str) {\n        var ptr0 = passStringToWasm0(bech_str, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.ed25519keyhash_from_bech32(ptr0, len0);\n        return Ed25519KeyHash.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Ed25519KeyHash}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.ed25519keyhash_from_bytes(ptr0, len0);\n        return Ed25519KeyHash.__wrap(ret);\n    }\n}\n/**\n*/\nclass Ed25519KeyHashes {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Ed25519KeyHashes.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_ed25519keyhashes_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.ed25519keyhashes_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Ed25519KeyHashes}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.ed25519keyhashes_from_bytes(ptr0, len0);\n        return Ed25519KeyHashes.__wrap(ret);\n    }\n    /**\n    * @returns {Ed25519KeyHashes}\n    */\n    static new() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.ed25519keyhashes_new();\n        return Ed25519KeyHashes.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.ed25519keyhashes_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {Ed25519KeyHash}\n    */\n    get(index) {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.ed25519keyhashes_get(this.ptr, index);\n        return Ed25519KeyHash.__wrap(ret);\n    }\n    /**\n    * @param {Ed25519KeyHash} elem\n    */\n    add(elem) {\n        _assertClass(elem, Ed25519KeyHash);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.ed25519keyhashes_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nclass Ed25519Signature {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Ed25519Signature.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_ed25519signature_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.ed25519signature_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_bech32() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.ed25519signature_to_bech32(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.ed25519signature_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} bech32_str\n    * @returns {Ed25519Signature}\n    */\n    static from_bech32(bech32_str) {\n        var ptr0 = passStringToWasm0(bech32_str, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.ed25519signature_from_bech32(ptr0, len0);\n        return Ed25519Signature.__wrap(ret);\n    }\n    /**\n    * @param {string} input\n    * @returns {Ed25519Signature}\n    */\n    static from_hex(input) {\n        var ptr0 = passStringToWasm0(input, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.ed25519signature_from_hex(ptr0, len0);\n        return Ed25519Signature.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Ed25519Signature}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.ed25519signature_from_bytes(ptr0, len0);\n        return Ed25519Signature.__wrap(ret);\n    }\n}\n/**\n*/\nclass EnterpriseAddress {\n\n    static __wrap(ptr) {\n        const obj = Object.create(EnterpriseAddress.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_enterpriseaddress_free(ptr);\n    }\n    /**\n    * @param {number} network\n    * @param {StakeCredential} payment\n    * @returns {EnterpriseAddress}\n    */\n    static new(network, payment) {\n        _assertClass(payment, StakeCredential);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.enterpriseaddress_new(network, payment.ptr);\n        return EnterpriseAddress.__wrap(ret);\n    }\n    /**\n    * @returns {StakeCredential}\n    */\n    payment_cred() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.enterpriseaddress_payment_cred(this.ptr);\n        return StakeCredential.__wrap(ret);\n    }\n    /**\n    * @returns {Address}\n    */\n    to_address() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.enterpriseaddress_to_address(this.ptr);\n        return Address.__wrap(ret);\n    }\n    /**\n    * @param {Address} addr\n    * @returns {EnterpriseAddress | undefined}\n    */\n    static from_address(addr) {\n        _assertClass(addr, Address);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.enterpriseaddress_from_address(addr.ptr);\n        return ret === 0 ? undefined : EnterpriseAddress.__wrap(ret);\n    }\n}\n/**\n*/\nclass ExUnitPrices {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ExUnitPrices.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_exunitprices_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.exunitprices_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ExUnitPrices}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.exunitprices_from_bytes(ptr0, len0);\n        return ExUnitPrices.__wrap(ret);\n    }\n    /**\n    * @returns {UnitInterval}\n    */\n    mem_price() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.exunitprices_mem_price(this.ptr);\n        return UnitInterval.__wrap(ret);\n    }\n    /**\n    * @returns {UnitInterval}\n    */\n    step_price() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.exunitprices_step_price(this.ptr);\n        return UnitInterval.__wrap(ret);\n    }\n    /**\n    * @param {UnitInterval} mem_price\n    * @param {UnitInterval} step_price\n    * @returns {ExUnitPrices}\n    */\n    static new(mem_price, step_price) {\n        _assertClass(mem_price, UnitInterval);\n        _assertClass(step_price, UnitInterval);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.exunitprices_new(mem_price.ptr, step_price.ptr);\n        return ExUnitPrices.__wrap(ret);\n    }\n}\n/**\n*/\nclass ExUnits {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ExUnits.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_exunits_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.exunits_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ExUnits}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.exunits_from_bytes(ptr0, len0);\n        return ExUnits.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum}\n    */\n    mem() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.exunits_mem(this.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum}\n    */\n    steps() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.exunits_steps(this.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} mem\n    * @param {BigNum} steps\n    * @returns {ExUnits}\n    */\n    static new(mem, steps) {\n        _assertClass(mem, BigNum);\n        _assertClass(steps, BigNum);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.exunits_new(mem.ptr, steps.ptr);\n        return ExUnits.__wrap(ret);\n    }\n}\n/**\n*/\nclass GeneralTransactionMetadata {\n\n    static __wrap(ptr) {\n        const obj = Object.create(GeneralTransactionMetadata.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_generaltransactionmetadata_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.generaltransactionmetadata_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {GeneralTransactionMetadata}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.generaltransactionmetadata_from_bytes(ptr0, len0);\n        return GeneralTransactionMetadata.__wrap(ret);\n    }\n    /**\n    * @returns {GeneralTransactionMetadata}\n    */\n    static new() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.generaltransactionmetadata_new();\n        return GeneralTransactionMetadata.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.generaltransactionmetadata_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {BigNum} key\n    * @param {TransactionMetadatum} value\n    * @returns {TransactionMetadatum | undefined}\n    */\n    insert(key, value) {\n        _assertClass(key, BigNum);\n        _assertClass(value, TransactionMetadatum);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.generaltransactionmetadata_insert(this.ptr, key.ptr, value.ptr);\n        return ret === 0 ? undefined : TransactionMetadatum.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} key\n    * @returns {TransactionMetadatum | undefined}\n    */\n    get(key) {\n        _assertClass(key, BigNum);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.generaltransactionmetadata_get(this.ptr, key.ptr);\n        return ret === 0 ? undefined : TransactionMetadatum.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionMetadatumLabels}\n    */\n    keys() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.generaltransactionmetadata_keys(this.ptr);\n        return TransactionMetadatumLabels.__wrap(ret);\n    }\n}\n/**\n*/\nclass GenesisDelegateHash {\n\n    static __wrap(ptr) {\n        const obj = Object.create(GenesisDelegateHash.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_genesisdelegatehash_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.genesisdelegatehash_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} prefix\n    * @returns {string}\n    */\n    to_bech32(prefix) {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(prefix, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.genesisdelegatehash_to_bech32(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} bech_str\n    * @returns {GenesisDelegateHash}\n    */\n    static from_bech32(bech_str) {\n        var ptr0 = passStringToWasm0(bech_str, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.genesisdelegatehash_from_bech32(ptr0, len0);\n        return GenesisDelegateHash.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {GenesisDelegateHash}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.genesisdelegatehash_from_bytes(ptr0, len0);\n        return GenesisDelegateHash.__wrap(ret);\n    }\n}\n/**\n*/\nclass GenesisHash {\n\n    static __wrap(ptr) {\n        const obj = Object.create(GenesisHash.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_genesishash_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.genesishash_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} prefix\n    * @returns {string}\n    */\n    to_bech32(prefix) {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(prefix, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.genesishash_to_bech32(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} bech_str\n    * @returns {GenesisHash}\n    */\n    static from_bech32(bech_str) {\n        var ptr0 = passStringToWasm0(bech_str, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.genesishash_from_bech32(ptr0, len0);\n        return GenesisHash.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {GenesisHash}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.genesishash_from_bytes(ptr0, len0);\n        return GenesisHash.__wrap(ret);\n    }\n}\n/**\n*/\nclass GenesisHashes {\n\n    static __wrap(ptr) {\n        const obj = Object.create(GenesisHashes.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_genesishashes_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.genesishashes_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {GenesisHashes}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.genesishashes_from_bytes(ptr0, len0);\n        return GenesisHashes.__wrap(ret);\n    }\n    /**\n    * @returns {GenesisHashes}\n    */\n    static new() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.genesishashes_new();\n        return GenesisHashes.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.genesishashes_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {GenesisHash}\n    */\n    get(index) {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.genesishashes_get(this.ptr, index);\n        return GenesisHash.__wrap(ret);\n    }\n    /**\n    * @param {GenesisHash} elem\n    */\n    add(elem) {\n        _assertClass(elem, GenesisHash);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.genesishashes_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nclass GenesisKeyDelegation {\n\n    static __wrap(ptr) {\n        const obj = Object.create(GenesisKeyDelegation.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_genesiskeydelegation_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.genesiskeydelegation_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {GenesisKeyDelegation}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.genesiskeydelegation_from_bytes(ptr0, len0);\n        return GenesisKeyDelegation.__wrap(ret);\n    }\n    /**\n    * @returns {GenesisHash}\n    */\n    genesishash() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.genesiskeydelegation_genesishash(this.ptr);\n        return GenesisHash.__wrap(ret);\n    }\n    /**\n    * @returns {GenesisDelegateHash}\n    */\n    genesis_delegate_hash() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.genesiskeydelegation_genesis_delegate_hash(this.ptr);\n        return GenesisDelegateHash.__wrap(ret);\n    }\n    /**\n    * @returns {VRFKeyHash}\n    */\n    vrf_keyhash() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.genesiskeydelegation_vrf_keyhash(this.ptr);\n        return VRFKeyHash.__wrap(ret);\n    }\n    /**\n    * @param {GenesisHash} genesishash\n    * @param {GenesisDelegateHash} genesis_delegate_hash\n    * @param {VRFKeyHash} vrf_keyhash\n    * @returns {GenesisKeyDelegation}\n    */\n    static new(genesishash, genesis_delegate_hash, vrf_keyhash) {\n        _assertClass(genesishash, GenesisHash);\n        _assertClass(genesis_delegate_hash, GenesisDelegateHash);\n        _assertClass(vrf_keyhash, VRFKeyHash);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.genesiskeydelegation_new(genesishash.ptr, genesis_delegate_hash.ptr, vrf_keyhash.ptr);\n        return GenesisKeyDelegation.__wrap(ret);\n    }\n}\n/**\n*/\nclass Header {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Header.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_header_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.header_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Header}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.header_from_bytes(ptr0, len0);\n        return Header.__wrap(ret);\n    }\n    /**\n    * @returns {HeaderBody}\n    */\n    header_body() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.header_header_body(this.ptr);\n        return HeaderBody.__wrap(ret);\n    }\n    /**\n    * @returns {KESSignature}\n    */\n    body_signature() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.header_body_signature(this.ptr);\n        return KESSignature.__wrap(ret);\n    }\n    /**\n    * @param {HeaderBody} header_body\n    * @param {KESSignature} body_signature\n    * @returns {Header}\n    */\n    static new(header_body, body_signature) {\n        _assertClass(header_body, HeaderBody);\n        _assertClass(body_signature, KESSignature);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.header_new(header_body.ptr, body_signature.ptr);\n        return Header.__wrap(ret);\n    }\n}\n/**\n*/\nclass HeaderBody {\n\n    static __wrap(ptr) {\n        const obj = Object.create(HeaderBody.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_headerbody_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.headerbody_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {HeaderBody}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.headerbody_from_bytes(ptr0, len0);\n        return HeaderBody.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    block_number() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.headerbody_block_number(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    slot() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.headerbody_slot(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {BlockHash | undefined}\n    */\n    prev_hash() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.headerbody_prev_hash(this.ptr);\n        return ret === 0 ? undefined : BlockHash.__wrap(ret);\n    }\n    /**\n    * @returns {Vkey}\n    */\n    issuer_vkey() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.headerbody_issuer_vkey(this.ptr);\n        return Vkey.__wrap(ret);\n    }\n    /**\n    * @returns {VRFVKey}\n    */\n    vrf_vkey() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.headerbody_vrf_vkey(this.ptr);\n        return VRFVKey.__wrap(ret);\n    }\n    /**\n    * @returns {VRFCert}\n    */\n    nonce_vrf() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.headerbody_nonce_vrf(this.ptr);\n        return VRFCert.__wrap(ret);\n    }\n    /**\n    * @returns {VRFCert}\n    */\n    leader_vrf() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.headerbody_leader_vrf(this.ptr);\n        return VRFCert.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    block_body_size() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.headerbody_block_body_size(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {BlockHash}\n    */\n    block_body_hash() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.headerbody_block_body_hash(this.ptr);\n        return BlockHash.__wrap(ret);\n    }\n    /**\n    * @returns {OperationalCert}\n    */\n    operational_cert() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.headerbody_operational_cert(this.ptr);\n        return OperationalCert.__wrap(ret);\n    }\n    /**\n    * @returns {ProtocolVersion}\n    */\n    protocol_version() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.headerbody_protocol_version(this.ptr);\n        return ProtocolVersion.__wrap(ret);\n    }\n    /**\n    * @param {number} block_number\n    * @param {number} slot\n    * @param {BlockHash | undefined} prev_hash\n    * @param {Vkey} issuer_vkey\n    * @param {VRFVKey} vrf_vkey\n    * @param {VRFCert} nonce_vrf\n    * @param {VRFCert} leader_vrf\n    * @param {number} block_body_size\n    * @param {BlockHash} block_body_hash\n    * @param {OperationalCert} operational_cert\n    * @param {ProtocolVersion} protocol_version\n    * @returns {HeaderBody}\n    */\n    static new(block_number, slot, prev_hash, issuer_vkey, vrf_vkey, nonce_vrf, leader_vrf, block_body_size, block_body_hash, operational_cert, protocol_version) {\n        let ptr0 = 0;\n        if (!isLikeNone(prev_hash)) {\n            _assertClass(prev_hash, BlockHash);\n            ptr0 = prev_hash.ptr;\n            prev_hash.ptr = 0;\n        }\n        _assertClass(issuer_vkey, Vkey);\n        _assertClass(vrf_vkey, VRFVKey);\n        _assertClass(nonce_vrf, VRFCert);\n        _assertClass(leader_vrf, VRFCert);\n        _assertClass(block_body_hash, BlockHash);\n        _assertClass(operational_cert, OperationalCert);\n        _assertClass(protocol_version, ProtocolVersion);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.headerbody_new(block_number, slot, ptr0, issuer_vkey.ptr, vrf_vkey.ptr, nonce_vrf.ptr, leader_vrf.ptr, block_body_size, block_body_hash.ptr, operational_cert.ptr, protocol_version.ptr);\n        return HeaderBody.__wrap(ret);\n    }\n}\n/**\n*/\nclass Int {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Int.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_int_free(ptr);\n    }\n    /**\n    * @param {BigNum} x\n    * @returns {Int}\n    */\n    static new(x) {\n        _assertClass(x, BigNum);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.int_new(x.ptr);\n        return Int.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} x\n    * @returns {Int}\n    */\n    static new_negative(x) {\n        _assertClass(x, BigNum);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.int_new_negative(x.ptr);\n        return Int.__wrap(ret);\n    }\n    /**\n    * @param {number} x\n    * @returns {Int}\n    */\n    static new_i32(x) {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.int_new_i32(x);\n        return Int.__wrap(ret);\n    }\n    /**\n    * @returns {boolean}\n    */\n    is_positive() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.int_is_positive(this.ptr);\n        return ret !== 0;\n    }\n    /**\n    * BigNum can only contain unsigned u64 values\n    *\n    * This function will return the BigNum representation\n    * only in case the underlying i128 value is positive.\n    *\n    * Otherwise nothing will be returned (undefined).\n    * @returns {BigNum | undefined}\n    */\n    as_positive() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.int_as_positive(this.ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * BigNum can only contain unsigned u64 values\n    *\n    * This function will return the *absolute* BigNum representation\n    * only in case the underlying i128 value is negative.\n    *\n    * Otherwise nothing will be returned (undefined).\n    * @returns {BigNum | undefined}\n    */\n    as_negative() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.int_as_negative(this.ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * !!! DEPRECATED !!!\n    * Returns an i32 value in case the underlying original i128 value is within the limits.\n    * Otherwise will just return an empty value (undefined).\n    * @returns {number | undefined}\n    */\n    as_i32() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.int_as_i32(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Returns the underlying value converted to i32 if possible (within limits)\n    * Otherwise will just return an empty value (undefined).\n    * @returns {number | undefined}\n    */\n    as_i32_or_nothing() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.int_as_i32_or_nothing(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Returns the underlying value converted to i32 if possible (within limits)\n    * JsError in case of out of boundary overflow\n    * @returns {number}\n    */\n    as_i32_or_fail() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.int_as_i32_or_fail(this.ptr);\n        return ret;\n    }\n    /**\n    * Returns string representation of the underlying i128 value directly.\n    * Might contain the minus sign (-) in case of negative value.\n    * @returns {string}\n    */\n    to_str() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.int_to_str(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1);\n        }\n    }\n}\n/**\n*/\nclass Ipv4 {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Ipv4.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_ipv4_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.ipv4_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Ipv4}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.ipv4_from_bytes(ptr0, len0);\n        return Ipv4.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} data\n    * @returns {Ipv4}\n    */\n    static new(data) {\n        var ptr0 = passArray8ToWasm0(data, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.ipv4_new(ptr0, len0);\n        return Ipv4.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    ip() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.ipv4_ip(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nclass Ipv6 {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Ipv6.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_ipv6_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.ipv6_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Ipv6}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.ipv6_from_bytes(ptr0, len0);\n        return Ipv6.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} data\n    * @returns {Ipv6}\n    */\n    static new(data) {\n        var ptr0 = passArray8ToWasm0(data, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.ipv6_new(ptr0, len0);\n        return Ipv6.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    ip() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.ipv6_ip(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nclass KESSignature {\n\n    static __wrap(ptr) {\n        const obj = Object.create(KESSignature.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_kessignature_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.kessignature_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {KESSignature}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.kessignature_from_bytes(ptr0, len0);\n        return KESSignature.__wrap(ret);\n    }\n}\n/**\n*/\nclass KESVKey {\n\n    static __wrap(ptr) {\n        const obj = Object.create(KESVKey.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_kesvkey_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.kesvkey_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} prefix\n    * @returns {string}\n    */\n    to_bech32(prefix) {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(prefix, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.kesvkey_to_bech32(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} bech_str\n    * @returns {KESVKey}\n    */\n    static from_bech32(bech_str) {\n        var ptr0 = passStringToWasm0(bech_str, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.kesvkey_from_bech32(ptr0, len0);\n        return KESVKey.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {KESVKey}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.kesvkey_from_bytes(ptr0, len0);\n        return KESVKey.__wrap(ret);\n    }\n}\n/**\n*/\nclass Language {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Language.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_language_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.language_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Language}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.language_from_bytes(ptr0, len0);\n        return Language.__wrap(ret);\n    }\n    /**\n    * @returns {Language}\n    */\n    static new_plutus_v1() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.language_new_plutus_v1();\n        return Language.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    kind() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.language_kind(this.ptr);\n        return ret >>> 0;\n    }\n}\n/**\n*/\nclass Languages {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Languages.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_languages_free(ptr);\n    }\n    /**\n    * @returns {Languages}\n    */\n    static new() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.languages_new();\n        return Languages.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.languages_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {Language}\n    */\n    get(index) {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.languages_get(this.ptr, index);\n        return Language.__wrap(ret);\n    }\n    /**\n    * @param {Language} elem\n    */\n    add(elem) {\n        _assertClass(elem, Language);\n        var ptr0 = elem.ptr;\n        elem.ptr = 0;\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.languages_add(this.ptr, ptr0);\n    }\n}\n/**\n*/\nclass LegacyDaedalusPrivateKey {\n\n    static __wrap(ptr) {\n        const obj = Object.create(LegacyDaedalusPrivateKey.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_legacydaedalusprivatekey_free(ptr);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {LegacyDaedalusPrivateKey}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.legacydaedalusprivatekey_from_bytes(ptr0, len0);\n        return LegacyDaedalusPrivateKey.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    as_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.legacydaedalusprivatekey_as_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    chaincode() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.legacydaedalusprivatekey_chaincode(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nclass LinearFee {\n\n    static __wrap(ptr) {\n        const obj = Object.create(LinearFee.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_linearfee_free(ptr);\n    }\n    /**\n    * @returns {BigNum}\n    */\n    constant() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.linearfee_constant(this.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum}\n    */\n    coefficient() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.linearfee_coefficient(this.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} coefficient\n    * @param {BigNum} constant\n    * @returns {LinearFee}\n    */\n    static new(coefficient, constant) {\n        _assertClass(coefficient, BigNum);\n        _assertClass(constant, BigNum);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.linearfee_new(coefficient.ptr, constant.ptr);\n        return LinearFee.__wrap(ret);\n    }\n}\n/**\n*/\nclass MIRToStakeCredentials {\n\n    static __wrap(ptr) {\n        const obj = Object.create(MIRToStakeCredentials.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_mirtostakecredentials_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.mirtostakecredentials_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {MIRToStakeCredentials}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.mirtostakecredentials_from_bytes(ptr0, len0);\n        return MIRToStakeCredentials.__wrap(ret);\n    }\n    /**\n    * @returns {MIRToStakeCredentials}\n    */\n    static new() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.mirtostakecredentials_new();\n        return MIRToStakeCredentials.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.mirtostakecredentials_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {StakeCredential} cred\n    * @param {Int} delta\n    * @returns {Int | undefined}\n    */\n    insert(cred, delta) {\n        _assertClass(cred, StakeCredential);\n        _assertClass(delta, Int);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.mirtostakecredentials_insert(this.ptr, cred.ptr, delta.ptr);\n        return ret === 0 ? undefined : Int.__wrap(ret);\n    }\n    /**\n    * @param {StakeCredential} cred\n    * @returns {Int | undefined}\n    */\n    get(cred) {\n        _assertClass(cred, StakeCredential);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.mirtostakecredentials_get(this.ptr, cred.ptr);\n        return ret === 0 ? undefined : Int.__wrap(ret);\n    }\n    /**\n    * @returns {StakeCredentials}\n    */\n    keys() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.mirtostakecredentials_keys(this.ptr);\n        return StakeCredentials.__wrap(ret);\n    }\n}\n/**\n*/\nclass MetadataList {\n\n    static __wrap(ptr) {\n        const obj = Object.create(MetadataList.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_metadatalist_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.metadatalist_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {MetadataList}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.metadatalist_from_bytes(ptr0, len0);\n        return MetadataList.__wrap(ret);\n    }\n    /**\n    * @returns {MetadataList}\n    */\n    static new() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.metadatalist_new();\n        return MetadataList.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.metadatalist_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {TransactionMetadatum}\n    */\n    get(index) {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.metadatalist_get(this.ptr, index);\n        return TransactionMetadatum.__wrap(ret);\n    }\n    /**\n    * @param {TransactionMetadatum} elem\n    */\n    add(elem) {\n        _assertClass(elem, TransactionMetadatum);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.metadatalist_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nclass MetadataMap {\n\n    static __wrap(ptr) {\n        const obj = Object.create(MetadataMap.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_metadatamap_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.metadatamap_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {MetadataMap}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.metadatamap_from_bytes(ptr0, len0);\n        return MetadataMap.__wrap(ret);\n    }\n    /**\n    * @returns {MetadataMap}\n    */\n    static new() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.metadatamap_new();\n        return MetadataMap.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.metadatamap_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {TransactionMetadatum} key\n    * @param {TransactionMetadatum} value\n    * @returns {TransactionMetadatum | undefined}\n    */\n    insert(key, value) {\n        _assertClass(key, TransactionMetadatum);\n        _assertClass(value, TransactionMetadatum);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.metadatamap_insert(this.ptr, key.ptr, value.ptr);\n        return ret === 0 ? undefined : TransactionMetadatum.__wrap(ret);\n    }\n    /**\n    * @param {string} key\n    * @param {TransactionMetadatum} value\n    * @returns {TransactionMetadatum | undefined}\n    */\n    insert_str(key, value) {\n        var ptr0 = passStringToWasm0(key, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        _assertClass(value, TransactionMetadatum);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.metadatamap_insert_str(this.ptr, ptr0, len0, value.ptr);\n        return ret === 0 ? undefined : TransactionMetadatum.__wrap(ret);\n    }\n    /**\n    * @param {number} key\n    * @param {TransactionMetadatum} value\n    * @returns {TransactionMetadatum | undefined}\n    */\n    insert_i32(key, value) {\n        _assertClass(value, TransactionMetadatum);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.metadatamap_insert_i32(this.ptr, key, value.ptr);\n        return ret === 0 ? undefined : TransactionMetadatum.__wrap(ret);\n    }\n    /**\n    * @param {TransactionMetadatum} key\n    * @returns {TransactionMetadatum}\n    */\n    get(key) {\n        _assertClass(key, TransactionMetadatum);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.metadatamap_get(this.ptr, key.ptr);\n        return TransactionMetadatum.__wrap(ret);\n    }\n    /**\n    * @param {string} key\n    * @returns {TransactionMetadatum}\n    */\n    get_str(key) {\n        var ptr0 = passStringToWasm0(key, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.metadatamap_get_str(this.ptr, ptr0, len0);\n        return TransactionMetadatum.__wrap(ret);\n    }\n    /**\n    * @param {number} key\n    * @returns {TransactionMetadatum}\n    */\n    get_i32(key) {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.metadatamap_get_i32(this.ptr, key);\n        return TransactionMetadatum.__wrap(ret);\n    }\n    /**\n    * @param {TransactionMetadatum} key\n    * @returns {boolean}\n    */\n    has(key) {\n        _assertClass(key, TransactionMetadatum);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.metadatamap_has(this.ptr, key.ptr);\n        return ret !== 0;\n    }\n    /**\n    * @returns {MetadataList}\n    */\n    keys() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.metadatamap_keys(this.ptr);\n        return MetadataList.__wrap(ret);\n    }\n}\n/**\n*/\nclass Mint {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Mint.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_mint_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.mint_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Mint}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.mint_from_bytes(ptr0, len0);\n        return Mint.__wrap(ret);\n    }\n    /**\n    * @returns {Mint}\n    */\n    static new() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.mint_new();\n        return Mint.__wrap(ret);\n    }\n    /**\n    * @param {ScriptHash} key\n    * @param {MintAssets} value\n    * @returns {Mint}\n    */\n    static new_from_entry(key, value) {\n        _assertClass(key, ScriptHash);\n        _assertClass(value, MintAssets);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.mint_new_from_entry(key.ptr, value.ptr);\n        return Mint.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.mint_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {ScriptHash} key\n    * @param {MintAssets} value\n    * @returns {MintAssets | undefined}\n    */\n    insert(key, value) {\n        _assertClass(key, ScriptHash);\n        _assertClass(value, MintAssets);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.mint_insert(this.ptr, key.ptr, value.ptr);\n        return ret === 0 ? undefined : MintAssets.__wrap(ret);\n    }\n    /**\n    * @param {ScriptHash} key\n    * @returns {MintAssets | undefined}\n    */\n    get(key) {\n        _assertClass(key, ScriptHash);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.mint_get(this.ptr, key.ptr);\n        return ret === 0 ? undefined : MintAssets.__wrap(ret);\n    }\n    /**\n    * @returns {ScriptHashes}\n    */\n    keys() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.mint_keys(this.ptr);\n        return ScriptHashes.__wrap(ret);\n    }\n    /**\n    * Returns the multiasset where only positive (minting) entries are present\n    * @returns {MultiAsset}\n    */\n    as_positive_multiasset() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.mint_as_positive_multiasset(this.ptr);\n        return MultiAsset.__wrap(ret);\n    }\n    /**\n    * Returns the multiasset where only negative (burning) entries are present\n    * @returns {MultiAsset}\n    */\n    as_negative_multiasset() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.mint_as_negative_multiasset(this.ptr);\n        return MultiAsset.__wrap(ret);\n    }\n}\n/**\n*/\nclass MintAssets {\n\n    static __wrap(ptr) {\n        const obj = Object.create(MintAssets.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_mintassets_free(ptr);\n    }\n    /**\n    * @returns {MintAssets}\n    */\n    static new() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.mintassets_new();\n        return MintAssets.__wrap(ret);\n    }\n    /**\n    * @param {AssetName} key\n    * @param {Int} value\n    * @returns {MintAssets}\n    */\n    static new_from_entry(key, value) {\n        _assertClass(key, AssetName);\n        _assertClass(value, Int);\n        var ptr0 = value.ptr;\n        value.ptr = 0;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.mintassets_new_from_entry(key.ptr, ptr0);\n        return MintAssets.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.mintassets_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {AssetName} key\n    * @param {Int} value\n    * @returns {Int | undefined}\n    */\n    insert(key, value) {\n        _assertClass(key, AssetName);\n        _assertClass(value, Int);\n        var ptr0 = value.ptr;\n        value.ptr = 0;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.mintassets_insert(this.ptr, key.ptr, ptr0);\n        return ret === 0 ? undefined : Int.__wrap(ret);\n    }\n    /**\n    * @param {AssetName} key\n    * @returns {Int | undefined}\n    */\n    get(key) {\n        _assertClass(key, AssetName);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.mintassets_get(this.ptr, key.ptr);\n        return ret === 0 ? undefined : Int.__wrap(ret);\n    }\n    /**\n    * @returns {AssetNames}\n    */\n    keys() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.mintassets_keys(this.ptr);\n        return AssetNames.__wrap(ret);\n    }\n}\n/**\n*/\nclass MoveInstantaneousReward {\n\n    static __wrap(ptr) {\n        const obj = Object.create(MoveInstantaneousReward.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_moveinstantaneousreward_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.moveinstantaneousreward_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {MoveInstantaneousReward}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.moveinstantaneousreward_from_bytes(ptr0, len0);\n        return MoveInstantaneousReward.__wrap(ret);\n    }\n    /**\n    * @param {number} pot\n    * @param {BigNum} amount\n    * @returns {MoveInstantaneousReward}\n    */\n    static new_to_other_pot(pot, amount) {\n        _assertClass(amount, BigNum);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.moveinstantaneousreward_new_to_other_pot(pot, amount.ptr);\n        return MoveInstantaneousReward.__wrap(ret);\n    }\n    /**\n    * @param {number} pot\n    * @param {MIRToStakeCredentials} amounts\n    * @returns {MoveInstantaneousReward}\n    */\n    static new_to_stake_creds(pot, amounts) {\n        _assertClass(amounts, MIRToStakeCredentials);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.moveinstantaneousreward_new_to_stake_creds(pot, amounts.ptr);\n        return MoveInstantaneousReward.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    pot() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.moveinstantaneousreward_pot(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    kind() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.moveinstantaneousreward_kind(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {BigNum | undefined}\n    */\n    as_to_other_pot() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.moveinstantaneousreward_as_to_other_pot(this.ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {MIRToStakeCredentials | undefined}\n    */\n    as_to_stake_creds() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.moveinstantaneousreward_as_to_stake_creds(this.ptr);\n        return ret === 0 ? undefined : MIRToStakeCredentials.__wrap(ret);\n    }\n}\n/**\n*/\nclass MoveInstantaneousRewardsCert {\n\n    static __wrap(ptr) {\n        const obj = Object.create(MoveInstantaneousRewardsCert.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_moveinstantaneousrewardscert_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.moveinstantaneousrewardscert_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {MoveInstantaneousRewardsCert}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.moveinstantaneousrewardscert_from_bytes(ptr0, len0);\n        return MoveInstantaneousRewardsCert.__wrap(ret);\n    }\n    /**\n    * @returns {MoveInstantaneousReward}\n    */\n    move_instantaneous_reward() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.moveinstantaneousrewardscert_move_instantaneous_reward(this.ptr);\n        return MoveInstantaneousReward.__wrap(ret);\n    }\n    /**\n    * @param {MoveInstantaneousReward} move_instantaneous_reward\n    * @returns {MoveInstantaneousRewardsCert}\n    */\n    static new(move_instantaneous_reward) {\n        _assertClass(move_instantaneous_reward, MoveInstantaneousReward);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.moveinstantaneousrewardscert_new(move_instantaneous_reward.ptr);\n        return MoveInstantaneousRewardsCert.__wrap(ret);\n    }\n}\n/**\n*/\nclass MultiAsset {\n\n    static __wrap(ptr) {\n        const obj = Object.create(MultiAsset.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_multiasset_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.multiasset_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {MultiAsset}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.multiasset_from_bytes(ptr0, len0);\n        return MultiAsset.__wrap(ret);\n    }\n    /**\n    * @returns {MultiAsset}\n    */\n    static new() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.multiasset_new();\n        return MultiAsset.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.multiasset_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {ScriptHash} key\n    * @param {Assets} value\n    * @returns {Assets | undefined}\n    */\n    insert(key, value) {\n        _assertClass(key, ScriptHash);\n        _assertClass(value, Assets);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.multiasset_insert(this.ptr, key.ptr, value.ptr);\n        return ret === 0 ? undefined : Assets.__wrap(ret);\n    }\n    /**\n    * @param {ScriptHash} key\n    * @returns {Assets | undefined}\n    */\n    get(key) {\n        _assertClass(key, ScriptHash);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.multiasset_get(this.ptr, key.ptr);\n        return ret === 0 ? undefined : Assets.__wrap(ret);\n    }\n    /**\n    * @returns {ScriptHashes}\n    */\n    keys() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.multiasset_keys(this.ptr);\n        return ScriptHashes.__wrap(ret);\n    }\n    /**\n    * removes an asset from the list if the result is 0 or less\n    * @param {MultiAsset} rhs_ma\n    * @returns {MultiAsset}\n    */\n    sub(rhs_ma) {\n        _assertClass(rhs_ma, MultiAsset);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.multiasset_sub(this.ptr, rhs_ma.ptr);\n        return MultiAsset.__wrap(ret);\n    }\n}\n/**\n*/\nclass MultiHostName {\n\n    static __wrap(ptr) {\n        const obj = Object.create(MultiHostName.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_multihostname_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.multihostname_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {MultiHostName}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.multihostname_from_bytes(ptr0, len0);\n        return MultiHostName.__wrap(ret);\n    }\n    /**\n    * @returns {DNSRecordSRV}\n    */\n    dns_name() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.multihostname_dns_name(this.ptr);\n        return DNSRecordSRV.__wrap(ret);\n    }\n    /**\n    * @param {DNSRecordSRV} dns_name\n    * @returns {MultiHostName}\n    */\n    static new(dns_name) {\n        _assertClass(dns_name, DNSRecordSRV);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.multihostname_new(dns_name.ptr);\n        return MultiHostName.__wrap(ret);\n    }\n}\n/**\n*/\nclass NativeScript {\n\n    static __wrap(ptr) {\n        const obj = Object.create(NativeScript.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_nativescript_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.nativescript_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {NativeScript}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.nativescript_from_bytes(ptr0, len0);\n        return NativeScript.__wrap(ret);\n    }\n    /**\n    * @param {number} namespace\n    * @returns {ScriptHash}\n    */\n    hash(namespace) {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.nativescript_hash(this.ptr, namespace);\n        return ScriptHash.__wrap(ret);\n    }\n    /**\n    * @param {ScriptPubkey} script_pubkey\n    * @returns {NativeScript}\n    */\n    static new_script_pubkey(script_pubkey) {\n        _assertClass(script_pubkey, ScriptPubkey);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.nativescript_new_script_pubkey(script_pubkey.ptr);\n        return NativeScript.__wrap(ret);\n    }\n    /**\n    * @param {ScriptAll} script_all\n    * @returns {NativeScript}\n    */\n    static new_script_all(script_all) {\n        _assertClass(script_all, ScriptAll);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.nativescript_new_script_all(script_all.ptr);\n        return NativeScript.__wrap(ret);\n    }\n    /**\n    * @param {ScriptAny} script_any\n    * @returns {NativeScript}\n    */\n    static new_script_any(script_any) {\n        _assertClass(script_any, ScriptAny);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.nativescript_new_script_any(script_any.ptr);\n        return NativeScript.__wrap(ret);\n    }\n    /**\n    * @param {ScriptNOfK} script_n_of_k\n    * @returns {NativeScript}\n    */\n    static new_script_n_of_k(script_n_of_k) {\n        _assertClass(script_n_of_k, ScriptNOfK);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.nativescript_new_script_n_of_k(script_n_of_k.ptr);\n        return NativeScript.__wrap(ret);\n    }\n    /**\n    * @param {TimelockStart} timelock_start\n    * @returns {NativeScript}\n    */\n    static new_timelock_start(timelock_start) {\n        _assertClass(timelock_start, TimelockStart);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.nativescript_new_timelock_start(timelock_start.ptr);\n        return NativeScript.__wrap(ret);\n    }\n    /**\n    * @param {TimelockExpiry} timelock_expiry\n    * @returns {NativeScript}\n    */\n    static new_timelock_expiry(timelock_expiry) {\n        _assertClass(timelock_expiry, TimelockExpiry);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.nativescript_new_timelock_expiry(timelock_expiry.ptr);\n        return NativeScript.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    kind() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.nativescript_kind(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {ScriptPubkey | undefined}\n    */\n    as_script_pubkey() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.nativescript_as_script_pubkey(this.ptr);\n        return ret === 0 ? undefined : ScriptPubkey.__wrap(ret);\n    }\n    /**\n    * @returns {ScriptAll | undefined}\n    */\n    as_script_all() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.nativescript_as_script_all(this.ptr);\n        return ret === 0 ? undefined : ScriptAll.__wrap(ret);\n    }\n    /**\n    * @returns {ScriptAny | undefined}\n    */\n    as_script_any() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.nativescript_as_script_any(this.ptr);\n        return ret === 0 ? undefined : ScriptAny.__wrap(ret);\n    }\n    /**\n    * @returns {ScriptNOfK | undefined}\n    */\n    as_script_n_of_k() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.nativescript_as_script_n_of_k(this.ptr);\n        return ret === 0 ? undefined : ScriptNOfK.__wrap(ret);\n    }\n    /**\n    * @returns {TimelockStart | undefined}\n    */\n    as_timelock_start() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.nativescript_as_timelock_start(this.ptr);\n        return ret === 0 ? undefined : TimelockStart.__wrap(ret);\n    }\n    /**\n    * @returns {TimelockExpiry | undefined}\n    */\n    as_timelock_expiry() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.nativescript_as_timelock_expiry(this.ptr);\n        return ret === 0 ? undefined : TimelockExpiry.__wrap(ret);\n    }\n}\n/**\n*/\nclass NativeScripts {\n\n    static __wrap(ptr) {\n        const obj = Object.create(NativeScripts.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_nativescripts_free(ptr);\n    }\n    /**\n    * @returns {NativeScripts}\n    */\n    static new() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.nativescripts_new();\n        return NativeScripts.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.nativescripts_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {NativeScript}\n    */\n    get(index) {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.nativescripts_get(this.ptr, index);\n        return NativeScript.__wrap(ret);\n    }\n    /**\n    * @param {NativeScript} elem\n    */\n    add(elem) {\n        _assertClass(elem, NativeScript);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.nativescripts_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nclass NetworkId {\n\n    static __wrap(ptr) {\n        const obj = Object.create(NetworkId.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_networkid_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.networkid_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {NetworkId}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.networkid_from_bytes(ptr0, len0);\n        return NetworkId.__wrap(ret);\n    }\n    /**\n    * @returns {NetworkId}\n    */\n    static testnet() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.networkid_testnet();\n        return NetworkId.__wrap(ret);\n    }\n    /**\n    * @returns {NetworkId}\n    */\n    static mainnet() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.networkid_mainnet();\n        return NetworkId.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    kind() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.networkid_kind(this.ptr);\n        return ret >>> 0;\n    }\n}\n/**\n*/\nclass NetworkInfo {\n\n    static __wrap(ptr) {\n        const obj = Object.create(NetworkInfo.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_networkinfo_free(ptr);\n    }\n    /**\n    * @param {number} network_id\n    * @param {number} protocol_magic\n    * @returns {NetworkInfo}\n    */\n    static new(network_id, protocol_magic) {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.networkinfo_new(network_id, protocol_magic);\n        return NetworkInfo.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    network_id() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.networkinfo_network_id(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    protocol_magic() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.networkinfo_protocol_magic(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {NetworkInfo}\n    */\n    static testnet() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.networkinfo_testnet();\n        return NetworkInfo.__wrap(ret);\n    }\n    /**\n    * @returns {NetworkInfo}\n    */\n    static mainnet() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.networkinfo_mainnet();\n        return NetworkInfo.__wrap(ret);\n    }\n}\n/**\n*/\nclass Nonce {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Nonce.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_nonce_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.nonce_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Nonce}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.nonce_from_bytes(ptr0, len0);\n        return Nonce.__wrap(ret);\n    }\n    /**\n    * @returns {Nonce}\n    */\n    static new_identity() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.nonce_new_identity();\n        return Nonce.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} hash\n    * @returns {Nonce}\n    */\n    static new_from_hash(hash) {\n        var ptr0 = passArray8ToWasm0(hash, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.nonce_new_from_hash(ptr0, len0);\n        return Nonce.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array | undefined}\n    */\n    get_hash() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.nonce_get_hash(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getArrayU8FromWasm0(r0, r1).slice();\n                _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            }\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nclass OperationalCert {\n\n    static __wrap(ptr) {\n        const obj = Object.create(OperationalCert.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_operationalcert_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.operationalcert_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {OperationalCert}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.operationalcert_from_bytes(ptr0, len0);\n        return OperationalCert.__wrap(ret);\n    }\n    /**\n    * @returns {KESVKey}\n    */\n    hot_vkey() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.operationalcert_hot_vkey(this.ptr);\n        return KESVKey.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    sequence_number() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.operationalcert_sequence_number(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    kes_period() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.operationalcert_kes_period(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {Ed25519Signature}\n    */\n    sigma() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.operationalcert_sigma(this.ptr);\n        return Ed25519Signature.__wrap(ret);\n    }\n    /**\n    * @param {KESVKey} hot_vkey\n    * @param {number} sequence_number\n    * @param {number} kes_period\n    * @param {Ed25519Signature} sigma\n    * @returns {OperationalCert}\n    */\n    static new(hot_vkey, sequence_number, kes_period, sigma) {\n        _assertClass(hot_vkey, KESVKey);\n        _assertClass(sigma, Ed25519Signature);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.operationalcert_new(hot_vkey.ptr, sequence_number, kes_period, sigma.ptr);\n        return OperationalCert.__wrap(ret);\n    }\n}\n/**\n*/\nclass PlutusData {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PlutusData.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_plutusdata_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.plutusdata_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PlutusData}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.plutusdata_from_bytes(ptr0, len0);\n        return PlutusData.__wrap(ret);\n    }\n    /**\n    * @param {ConstrPlutusData} constr_plutus_data\n    * @returns {PlutusData}\n    */\n    static new_constr_plutus_data(constr_plutus_data) {\n        _assertClass(constr_plutus_data, ConstrPlutusData);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.plutusdata_new_constr_plutus_data(constr_plutus_data.ptr);\n        return PlutusData.__wrap(ret);\n    }\n    /**\n    * @param {PlutusMap} map\n    * @returns {PlutusData}\n    */\n    static new_map(map) {\n        _assertClass(map, PlutusMap);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.plutusdata_new_map(map.ptr);\n        return PlutusData.__wrap(ret);\n    }\n    /**\n    * @param {PlutusList} list\n    * @returns {PlutusData}\n    */\n    static new_list(list) {\n        _assertClass(list, PlutusList);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.plutusdata_new_list(list.ptr);\n        return PlutusData.__wrap(ret);\n    }\n    /**\n    * @param {BigInt} integer\n    * @returns {PlutusData}\n    */\n    static new_integer(integer) {\n        _assertClass(integer, BigInt);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.plutusdata_new_integer(integer.ptr);\n        return PlutusData.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PlutusData}\n    */\n    static new_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.plutusdata_new_bytes(ptr0, len0);\n        return PlutusData.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    kind() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.plutusdata_kind(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {ConstrPlutusData | undefined}\n    */\n    as_constr_plutus_data() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.plutusdata_as_constr_plutus_data(this.ptr);\n        return ret === 0 ? undefined : ConstrPlutusData.__wrap(ret);\n    }\n    /**\n    * @returns {PlutusMap | undefined}\n    */\n    as_map() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.plutusdata_as_map(this.ptr);\n        return ret === 0 ? undefined : PlutusMap.__wrap(ret);\n    }\n    /**\n    * @returns {PlutusList | undefined}\n    */\n    as_list() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.plutusdata_as_list(this.ptr);\n        return ret === 0 ? undefined : PlutusList.__wrap(ret);\n    }\n    /**\n    * @returns {BigInt | undefined}\n    */\n    as_integer() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.plutusdata_as_integer(this.ptr);\n        return ret === 0 ? undefined : BigInt.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array | undefined}\n    */\n    as_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.plutusdata_as_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getArrayU8FromWasm0(r0, r1).slice();\n                _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            }\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nclass PlutusList {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PlutusList.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_plutuslist_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.plutuslist_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PlutusList}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.plutuslist_from_bytes(ptr0, len0);\n        return PlutusList.__wrap(ret);\n    }\n    /**\n    * @returns {PlutusList}\n    */\n    static new() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.plutuslist_new();\n        return PlutusList.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.plutuslist_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {PlutusData}\n    */\n    get(index) {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.plutuslist_get(this.ptr, index);\n        return PlutusData.__wrap(ret);\n    }\n    /**\n    * @param {PlutusData} elem\n    */\n    add(elem) {\n        _assertClass(elem, PlutusData);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.plutuslist_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nclass PlutusMap {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PlutusMap.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_plutusmap_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.plutusmap_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PlutusMap}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.plutusmap_from_bytes(ptr0, len0);\n        return PlutusMap.__wrap(ret);\n    }\n    /**\n    * @returns {PlutusMap}\n    */\n    static new() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.plutusmap_new();\n        return PlutusMap.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.plutusmap_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {PlutusData} key\n    * @param {PlutusData} value\n    * @returns {PlutusData | undefined}\n    */\n    insert(key, value) {\n        _assertClass(key, PlutusData);\n        _assertClass(value, PlutusData);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.plutusmap_insert(this.ptr, key.ptr, value.ptr);\n        return ret === 0 ? undefined : PlutusData.__wrap(ret);\n    }\n    /**\n    * @param {PlutusData} key\n    * @returns {PlutusData | undefined}\n    */\n    get(key) {\n        _assertClass(key, PlutusData);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.plutusmap_get(this.ptr, key.ptr);\n        return ret === 0 ? undefined : PlutusData.__wrap(ret);\n    }\n    /**\n    * @returns {PlutusList}\n    */\n    keys() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.plutusmap_keys(this.ptr);\n        return PlutusList.__wrap(ret);\n    }\n}\n/**\n*/\nclass PlutusScript {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PlutusScript.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_plutusscript_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.plutusscript_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PlutusScript}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.plutusscript_from_bytes(ptr0, len0);\n        return PlutusScript.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PlutusScript}\n    */\n    static new(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.plutusscript_new(ptr0, len0);\n        return PlutusScript.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.plutusscript_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nclass PlutusScripts {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PlutusScripts.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_plutusscripts_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.plutusscripts_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PlutusScripts}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.plutusscripts_from_bytes(ptr0, len0);\n        return PlutusScripts.__wrap(ret);\n    }\n    /**\n    * @returns {PlutusScripts}\n    */\n    static new() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.plutusscripts_new();\n        return PlutusScripts.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.plutusscripts_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {PlutusScript}\n    */\n    get(index) {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.plutusscripts_get(this.ptr, index);\n        return PlutusScript.__wrap(ret);\n    }\n    /**\n    * @param {PlutusScript} elem\n    */\n    add(elem) {\n        _assertClass(elem, PlutusScript);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.plutusscripts_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nclass Pointer {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Pointer.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_pointer_free(ptr);\n    }\n    /**\n    * @param {number} slot\n    * @param {number} tx_index\n    * @param {number} cert_index\n    * @returns {Pointer}\n    */\n    static new(slot, tx_index, cert_index) {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.pointer_new(slot, tx_index, cert_index);\n        return Pointer.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    slot() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.pointer_slot(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    tx_index() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.pointer_tx_index(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    cert_index() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.pointer_cert_index(this.ptr);\n        return ret >>> 0;\n    }\n}\n/**\n*/\nclass PointerAddress {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PointerAddress.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_pointeraddress_free(ptr);\n    }\n    /**\n    * @param {number} network\n    * @param {StakeCredential} payment\n    * @param {Pointer} stake\n    * @returns {PointerAddress}\n    */\n    static new(network, payment, stake) {\n        _assertClass(payment, StakeCredential);\n        _assertClass(stake, Pointer);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.pointeraddress_new(network, payment.ptr, stake.ptr);\n        return PointerAddress.__wrap(ret);\n    }\n    /**\n    * @returns {StakeCredential}\n    */\n    payment_cred() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.pointeraddress_payment_cred(this.ptr);\n        return StakeCredential.__wrap(ret);\n    }\n    /**\n    * @returns {Pointer}\n    */\n    stake_pointer() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.pointeraddress_stake_pointer(this.ptr);\n        return Pointer.__wrap(ret);\n    }\n    /**\n    * @returns {Address}\n    */\n    to_address() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.pointeraddress_to_address(this.ptr);\n        return Address.__wrap(ret);\n    }\n    /**\n    * @param {Address} addr\n    * @returns {PointerAddress | undefined}\n    */\n    static from_address(addr) {\n        _assertClass(addr, Address);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.pointeraddress_from_address(addr.ptr);\n        return ret === 0 ? undefined : PointerAddress.__wrap(ret);\n    }\n}\n/**\n*/\nclass PoolMetadata {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PoolMetadata.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_poolmetadata_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.poolmetadata_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PoolMetadata}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.poolmetadata_from_bytes(ptr0, len0);\n        return PoolMetadata.__wrap(ret);\n    }\n    /**\n    * @returns {URL}\n    */\n    url() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.poolmetadata_url(this.ptr);\n        return URL.__wrap(ret);\n    }\n    /**\n    * @returns {PoolMetadataHash}\n    */\n    pool_metadata_hash() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.poolmetadata_pool_metadata_hash(this.ptr);\n        return PoolMetadataHash.__wrap(ret);\n    }\n    /**\n    * @param {URL} url\n    * @param {PoolMetadataHash} pool_metadata_hash\n    * @returns {PoolMetadata}\n    */\n    static new(url, pool_metadata_hash) {\n        _assertClass(url, URL);\n        _assertClass(pool_metadata_hash, PoolMetadataHash);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.poolmetadata_new(url.ptr, pool_metadata_hash.ptr);\n        return PoolMetadata.__wrap(ret);\n    }\n}\n/**\n*/\nclass PoolMetadataHash {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PoolMetadataHash.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_poolmetadatahash_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.poolmetadatahash_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} prefix\n    * @returns {string}\n    */\n    to_bech32(prefix) {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(prefix, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.poolmetadatahash_to_bech32(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} bech_str\n    * @returns {PoolMetadataHash}\n    */\n    static from_bech32(bech_str) {\n        var ptr0 = passStringToWasm0(bech_str, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.poolmetadatahash_from_bech32(ptr0, len0);\n        return PoolMetadataHash.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PoolMetadataHash}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.poolmetadatahash_from_bytes(ptr0, len0);\n        return PoolMetadataHash.__wrap(ret);\n    }\n}\n/**\n*/\nclass PoolParams {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PoolParams.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_poolparams_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.poolparams_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PoolParams}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.poolparams_from_bytes(ptr0, len0);\n        return PoolParams.__wrap(ret);\n    }\n    /**\n    * @returns {Ed25519KeyHash}\n    */\n    operator() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.poolparams_operator(this.ptr);\n        return Ed25519KeyHash.__wrap(ret);\n    }\n    /**\n    * @returns {VRFKeyHash}\n    */\n    vrf_keyhash() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.poolparams_vrf_keyhash(this.ptr);\n        return VRFKeyHash.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum}\n    */\n    pledge() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.poolparams_pledge(this.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum}\n    */\n    cost() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.poolparams_cost(this.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {UnitInterval}\n    */\n    margin() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.poolparams_margin(this.ptr);\n        return UnitInterval.__wrap(ret);\n    }\n    /**\n    * @returns {RewardAddress}\n    */\n    reward_account() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.poolparams_reward_account(this.ptr);\n        return RewardAddress.__wrap(ret);\n    }\n    /**\n    * @returns {Ed25519KeyHashes}\n    */\n    pool_owners() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.poolparams_pool_owners(this.ptr);\n        return Ed25519KeyHashes.__wrap(ret);\n    }\n    /**\n    * @returns {Relays}\n    */\n    relays() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.poolparams_relays(this.ptr);\n        return Relays.__wrap(ret);\n    }\n    /**\n    * @returns {PoolMetadata | undefined}\n    */\n    pool_metadata() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.poolparams_pool_metadata(this.ptr);\n        return ret === 0 ? undefined : PoolMetadata.__wrap(ret);\n    }\n    /**\n    * @param {Ed25519KeyHash} operator\n    * @param {VRFKeyHash} vrf_keyhash\n    * @param {BigNum} pledge\n    * @param {BigNum} cost\n    * @param {UnitInterval} margin\n    * @param {RewardAddress} reward_account\n    * @param {Ed25519KeyHashes} pool_owners\n    * @param {Relays} relays\n    * @param {PoolMetadata | undefined} pool_metadata\n    * @returns {PoolParams}\n    */\n    static new(operator, vrf_keyhash, pledge, cost, margin, reward_account, pool_owners, relays, pool_metadata) {\n        _assertClass(operator, Ed25519KeyHash);\n        _assertClass(vrf_keyhash, VRFKeyHash);\n        _assertClass(pledge, BigNum);\n        _assertClass(cost, BigNum);\n        _assertClass(margin, UnitInterval);\n        _assertClass(reward_account, RewardAddress);\n        _assertClass(pool_owners, Ed25519KeyHashes);\n        _assertClass(relays, Relays);\n        let ptr0 = 0;\n        if (!isLikeNone(pool_metadata)) {\n            _assertClass(pool_metadata, PoolMetadata);\n            ptr0 = pool_metadata.ptr;\n            pool_metadata.ptr = 0;\n        }\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.poolparams_new(operator.ptr, vrf_keyhash.ptr, pledge.ptr, cost.ptr, margin.ptr, reward_account.ptr, pool_owners.ptr, relays.ptr, ptr0);\n        return PoolParams.__wrap(ret);\n    }\n}\n/**\n*/\nclass PoolRegistration {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PoolRegistration.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_poolregistration_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.poolregistration_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PoolRegistration}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.poolregistration_from_bytes(ptr0, len0);\n        return PoolRegistration.__wrap(ret);\n    }\n    /**\n    * @returns {PoolParams}\n    */\n    pool_params() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.poolregistration_pool_params(this.ptr);\n        return PoolParams.__wrap(ret);\n    }\n    /**\n    * @param {PoolParams} pool_params\n    * @returns {PoolRegistration}\n    */\n    static new(pool_params) {\n        _assertClass(pool_params, PoolParams);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.poolregistration_new(pool_params.ptr);\n        return PoolRegistration.__wrap(ret);\n    }\n}\n/**\n*/\nclass PoolRetirement {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PoolRetirement.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_poolretirement_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.poolretirement_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PoolRetirement}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.poolretirement_from_bytes(ptr0, len0);\n        return PoolRetirement.__wrap(ret);\n    }\n    /**\n    * @returns {Ed25519KeyHash}\n    */\n    pool_keyhash() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.poolretirement_pool_keyhash(this.ptr);\n        return Ed25519KeyHash.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    epoch() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.poolretirement_epoch(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {Ed25519KeyHash} pool_keyhash\n    * @param {number} epoch\n    * @returns {PoolRetirement}\n    */\n    static new(pool_keyhash, epoch) {\n        _assertClass(pool_keyhash, Ed25519KeyHash);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.poolretirement_new(pool_keyhash.ptr, epoch);\n        return PoolRetirement.__wrap(ret);\n    }\n}\n/**\n*/\nclass PrivateKey {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PrivateKey.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_privatekey_free(ptr);\n    }\n    /**\n    * @returns {PublicKey}\n    */\n    to_public() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.privatekey_to_public(this.ptr);\n        return PublicKey.__wrap(ret);\n    }\n    /**\n    * @returns {PrivateKey}\n    */\n    static generate_ed25519() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.privatekey_generate_ed25519();\n        return PrivateKey.__wrap(ret);\n    }\n    /**\n    * @returns {PrivateKey}\n    */\n    static generate_ed25519extended() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.privatekey_generate_ed25519extended();\n        return PrivateKey.__wrap(ret);\n    }\n    /**\n    * Get private key from its bech32 representation\n    * ```javascript\n    * PrivateKey.from_bech32(&#39;ed25519_sk1ahfetf02qwwg4dkq7mgp4a25lx5vh9920cr5wnxmpzz9906qvm8qwvlts0&#39;);\n    * ```\n    * For an extended 25519 key\n    * ```javascript\n    * PrivateKey.from_bech32(&#39;ed25519e_sk1gqwl4szuwwh6d0yk3nsqcc6xxc3fpvjlevgwvt60df59v8zd8f8prazt8ln3lmz096ux3xvhhvm3ca9wj2yctdh3pnw0szrma07rt5gl748fp&#39;);\n    * ```\n    * @param {string} bech32_str\n    * @returns {PrivateKey}\n    */\n    static from_bech32(bech32_str) {\n        var ptr0 = passStringToWasm0(bech32_str, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.privatekey_from_bech32(ptr0, len0);\n        return PrivateKey.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_bech32() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.privatekey_to_bech32(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    as_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.privatekey_as_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PrivateKey}\n    */\n    static from_extended_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.privatekey_from_extended_bytes(ptr0, len0);\n        return PrivateKey.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PrivateKey}\n    */\n    static from_normal_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.privatekey_from_normal_bytes(ptr0, len0);\n        return PrivateKey.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} message\n    * @returns {Ed25519Signature}\n    */\n    sign(message) {\n        var ptr0 = passArray8ToWasm0(message, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.privatekey_sign(this.ptr, ptr0, len0);\n        return Ed25519Signature.__wrap(ret);\n    }\n}\n/**\n*/\nclass ProposedProtocolParameterUpdates {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ProposedProtocolParameterUpdates.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_proposedprotocolparameterupdates_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.proposedprotocolparameterupdates_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ProposedProtocolParameterUpdates}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.proposedprotocolparameterupdates_from_bytes(ptr0, len0);\n        return ProposedProtocolParameterUpdates.__wrap(ret);\n    }\n    /**\n    * @returns {ProposedProtocolParameterUpdates}\n    */\n    static new() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.proposedprotocolparameterupdates_new();\n        return ProposedProtocolParameterUpdates.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.proposedprotocolparameterupdates_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {GenesisHash} key\n    * @param {ProtocolParamUpdate} value\n    * @returns {ProtocolParamUpdate | undefined}\n    */\n    insert(key, value) {\n        _assertClass(key, GenesisHash);\n        _assertClass(value, ProtocolParamUpdate);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.proposedprotocolparameterupdates_insert(this.ptr, key.ptr, value.ptr);\n        return ret === 0 ? undefined : ProtocolParamUpdate.__wrap(ret);\n    }\n    /**\n    * @param {GenesisHash} key\n    * @returns {ProtocolParamUpdate | undefined}\n    */\n    get(key) {\n        _assertClass(key, GenesisHash);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.proposedprotocolparameterupdates_get(this.ptr, key.ptr);\n        return ret === 0 ? undefined : ProtocolParamUpdate.__wrap(ret);\n    }\n    /**\n    * @returns {GenesisHashes}\n    */\n    keys() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.proposedprotocolparameterupdates_keys(this.ptr);\n        return GenesisHashes.__wrap(ret);\n    }\n}\n/**\n*/\nclass ProtocolParamUpdate {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ProtocolParamUpdate.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_protocolparamupdate_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.protocolparamupdate_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ProtocolParamUpdate}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.protocolparamupdate_from_bytes(ptr0, len0);\n        return ProtocolParamUpdate.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} minfee_a\n    */\n    set_minfee_a(minfee_a) {\n        _assertClass(minfee_a, BigNum);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.protocolparamupdate_set_minfee_a(this.ptr, minfee_a.ptr);\n    }\n    /**\n    * @returns {BigNum | undefined}\n    */\n    minfee_a() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.protocolparamupdate_minfee_a(this.ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} minfee_b\n    */\n    set_minfee_b(minfee_b) {\n        _assertClass(minfee_b, BigNum);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.protocolparamupdate_set_minfee_b(this.ptr, minfee_b.ptr);\n    }\n    /**\n    * @returns {BigNum | undefined}\n    */\n    minfee_b() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.protocolparamupdate_minfee_b(this.ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @param {number} max_block_body_size\n    */\n    set_max_block_body_size(max_block_body_size) {\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.protocolparamupdate_set_max_block_body_size(this.ptr, max_block_body_size);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    max_block_body_size() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.protocolparamupdate_max_block_body_size(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} max_tx_size\n    */\n    set_max_tx_size(max_tx_size) {\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.protocolparamupdate_set_max_tx_size(this.ptr, max_tx_size);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    max_tx_size() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.protocolparamupdate_max_tx_size(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} max_block_header_size\n    */\n    set_max_block_header_size(max_block_header_size) {\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.protocolparamupdate_set_max_block_header_size(this.ptr, max_block_header_size);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    max_block_header_size() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.protocolparamupdate_max_block_header_size(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {BigNum} key_deposit\n    */\n    set_key_deposit(key_deposit) {\n        _assertClass(key_deposit, BigNum);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.protocolparamupdate_set_key_deposit(this.ptr, key_deposit.ptr);\n    }\n    /**\n    * @returns {BigNum | undefined}\n    */\n    key_deposit() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.protocolparamupdate_key_deposit(this.ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} pool_deposit\n    */\n    set_pool_deposit(pool_deposit) {\n        _assertClass(pool_deposit, BigNum);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.protocolparamupdate_set_pool_deposit(this.ptr, pool_deposit.ptr);\n    }\n    /**\n    * @returns {BigNum | undefined}\n    */\n    pool_deposit() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.protocolparamupdate_pool_deposit(this.ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @param {number} max_epoch\n    */\n    set_max_epoch(max_epoch) {\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.protocolparamupdate_set_max_epoch(this.ptr, max_epoch);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    max_epoch() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.protocolparamupdate_max_epoch(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} n_opt\n    */\n    set_n_opt(n_opt) {\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.protocolparamupdate_set_n_opt(this.ptr, n_opt);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    n_opt() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.protocolparamupdate_n_opt(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {UnitInterval} pool_pledge_influence\n    */\n    set_pool_pledge_influence(pool_pledge_influence) {\n        _assertClass(pool_pledge_influence, UnitInterval);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.protocolparamupdate_set_pool_pledge_influence(this.ptr, pool_pledge_influence.ptr);\n    }\n    /**\n    * @returns {UnitInterval | undefined}\n    */\n    pool_pledge_influence() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.protocolparamupdate_pool_pledge_influence(this.ptr);\n        return ret === 0 ? undefined : UnitInterval.__wrap(ret);\n    }\n    /**\n    * @param {UnitInterval} expansion_rate\n    */\n    set_expansion_rate(expansion_rate) {\n        _assertClass(expansion_rate, UnitInterval);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.protocolparamupdate_set_expansion_rate(this.ptr, expansion_rate.ptr);\n    }\n    /**\n    * @returns {UnitInterval | undefined}\n    */\n    expansion_rate() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.protocolparamupdate_expansion_rate(this.ptr);\n        return ret === 0 ? undefined : UnitInterval.__wrap(ret);\n    }\n    /**\n    * @param {UnitInterval} treasury_growth_rate\n    */\n    set_treasury_growth_rate(treasury_growth_rate) {\n        _assertClass(treasury_growth_rate, UnitInterval);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.protocolparamupdate_set_treasury_growth_rate(this.ptr, treasury_growth_rate.ptr);\n    }\n    /**\n    * @returns {UnitInterval | undefined}\n    */\n    treasury_growth_rate() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.protocolparamupdate_treasury_growth_rate(this.ptr);\n        return ret === 0 ? undefined : UnitInterval.__wrap(ret);\n    }\n    /**\n    * @param {UnitInterval} d\n    */\n    set_d(d) {\n        _assertClass(d, UnitInterval);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.protocolparamupdate_set_d(this.ptr, d.ptr);\n    }\n    /**\n    * @returns {UnitInterval | undefined}\n    */\n    d() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.protocolparamupdate_d(this.ptr);\n        return ret === 0 ? undefined : UnitInterval.__wrap(ret);\n    }\n    /**\n    * @param {Nonce} extra_entropy\n    */\n    set_extra_entropy(extra_entropy) {\n        _assertClass(extra_entropy, Nonce);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.protocolparamupdate_set_extra_entropy(this.ptr, extra_entropy.ptr);\n    }\n    /**\n    * @returns {Nonce | undefined}\n    */\n    extra_entropy() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.protocolparamupdate_extra_entropy(this.ptr);\n        return ret === 0 ? undefined : Nonce.__wrap(ret);\n    }\n    /**\n    * @param {ProtocolVersions} protocol_version\n    */\n    set_protocol_version(protocol_version) {\n        _assertClass(protocol_version, ProtocolVersions);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.protocolparamupdate_set_protocol_version(this.ptr, protocol_version.ptr);\n    }\n    /**\n    * @returns {ProtocolVersions | undefined}\n    */\n    protocol_version() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.protocolparamupdate_protocol_version(this.ptr);\n        return ret === 0 ? undefined : ProtocolVersions.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} min_pool_cost\n    */\n    set_min_pool_cost(min_pool_cost) {\n        _assertClass(min_pool_cost, BigNum);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.protocolparamupdate_set_min_pool_cost(this.ptr, min_pool_cost.ptr);\n    }\n    /**\n    * @returns {BigNum | undefined}\n    */\n    min_pool_cost() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.protocolparamupdate_min_pool_cost(this.ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} ada_per_utxo_byte\n    */\n    set_ada_per_utxo_byte(ada_per_utxo_byte) {\n        _assertClass(ada_per_utxo_byte, BigNum);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.protocolparamupdate_set_ada_per_utxo_byte(this.ptr, ada_per_utxo_byte.ptr);\n    }\n    /**\n    * @returns {BigNum | undefined}\n    */\n    ada_per_utxo_byte() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.protocolparamupdate_ada_per_utxo_byte(this.ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @param {Costmdls} cost_models\n    */\n    set_cost_models(cost_models) {\n        _assertClass(cost_models, Costmdls);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.protocolparamupdate_set_cost_models(this.ptr, cost_models.ptr);\n    }\n    /**\n    * @returns {Costmdls | undefined}\n    */\n    cost_models() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.protocolparamupdate_cost_models(this.ptr);\n        return ret === 0 ? undefined : Costmdls.__wrap(ret);\n    }\n    /**\n    * @param {ExUnitPrices} execution_costs\n    */\n    set_execution_costs(execution_costs) {\n        _assertClass(execution_costs, ExUnitPrices);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.protocolparamupdate_set_execution_costs(this.ptr, execution_costs.ptr);\n    }\n    /**\n    * @returns {ExUnitPrices | undefined}\n    */\n    execution_costs() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.protocolparamupdate_execution_costs(this.ptr);\n        return ret === 0 ? undefined : ExUnitPrices.__wrap(ret);\n    }\n    /**\n    * @param {ExUnits} max_tx_ex_units\n    */\n    set_max_tx_ex_units(max_tx_ex_units) {\n        _assertClass(max_tx_ex_units, ExUnits);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.protocolparamupdate_set_max_tx_ex_units(this.ptr, max_tx_ex_units.ptr);\n    }\n    /**\n    * @returns {ExUnits | undefined}\n    */\n    max_tx_ex_units() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.protocolparamupdate_max_tx_ex_units(this.ptr);\n        return ret === 0 ? undefined : ExUnits.__wrap(ret);\n    }\n    /**\n    * @param {ExUnits} max_block_ex_units\n    */\n    set_max_block_ex_units(max_block_ex_units) {\n        _assertClass(max_block_ex_units, ExUnits);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.protocolparamupdate_set_max_block_ex_units(this.ptr, max_block_ex_units.ptr);\n    }\n    /**\n    * @returns {ExUnits | undefined}\n    */\n    max_block_ex_units() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.protocolparamupdate_max_block_ex_units(this.ptr);\n        return ret === 0 ? undefined : ExUnits.__wrap(ret);\n    }\n    /**\n    * @param {number} max_value_size\n    */\n    set_max_value_size(max_value_size) {\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.protocolparamupdate_set_max_value_size(this.ptr, max_value_size);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    max_value_size() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.protocolparamupdate_max_value_size(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {ProtocolParamUpdate}\n    */\n    static new() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.protocolparamupdate_new();\n        return ProtocolParamUpdate.__wrap(ret);\n    }\n}\n/**\n*/\nclass ProtocolVersion {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ProtocolVersion.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_protocolversion_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.protocolversion_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ProtocolVersion}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.protocolversion_from_bytes(ptr0, len0);\n        return ProtocolVersion.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    major() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.protocolversion_major(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    minor() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.protocolversion_minor(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} major\n    * @param {number} minor\n    * @returns {ProtocolVersion}\n    */\n    static new(major, minor) {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.protocolversion_new(major, minor);\n        return ProtocolVersion.__wrap(ret);\n    }\n}\n/**\n*/\nclass ProtocolVersions {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ProtocolVersions.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_protocolversions_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.protocolversions_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ProtocolVersions}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.protocolversions_from_bytes(ptr0, len0);\n        return ProtocolVersions.__wrap(ret);\n    }\n    /**\n    * @returns {ProtocolVersions}\n    */\n    static new() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.protocolversions_new();\n        return ProtocolVersions.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.protocolversions_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {ProtocolVersion}\n    */\n    get(index) {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.protocolversions_get(this.ptr, index);\n        return ProtocolVersion.__wrap(ret);\n    }\n    /**\n    * @param {ProtocolVersion} elem\n    */\n    add(elem) {\n        _assertClass(elem, ProtocolVersion);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.protocolversions_add(this.ptr, elem.ptr);\n    }\n}\n/**\n* ED25519 key used as public key\n*/\nclass PublicKey {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PublicKey.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_publickey_free(ptr);\n    }\n    /**\n    * Get public key from its bech32 representation\n    * Example:\n    * ```javascript\n    * const pkey = PublicKey.from_bech32(&#39;ed25519_pk1dgaagyh470y66p899txcl3r0jaeaxu6yd7z2dxyk55qcycdml8gszkxze2&#39;);\n    * ```\n    * @param {string} bech32_str\n    * @returns {PublicKey}\n    */\n    static from_bech32(bech32_str) {\n        var ptr0 = passStringToWasm0(bech32_str, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.publickey_from_bech32(ptr0, len0);\n        return PublicKey.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_bech32() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.publickey_to_bech32(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    as_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.publickey_as_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PublicKey}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.publickey_from_bytes(ptr0, len0);\n        return PublicKey.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} data\n    * @param {Ed25519Signature} signature\n    * @returns {boolean}\n    */\n    verify(data, signature) {\n        var ptr0 = passArray8ToWasm0(data, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        _assertClass(signature, Ed25519Signature);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.publickey_verify(this.ptr, ptr0, len0, signature.ptr);\n        return ret !== 0;\n    }\n    /**\n    * @returns {Ed25519KeyHash}\n    */\n    hash() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.publickey_hash(this.ptr);\n        return Ed25519KeyHash.__wrap(ret);\n    }\n}\n/**\n*/\nclass PublicKeys {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PublicKeys.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_publickeys_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.publickeys_new();\n        return PublicKeys.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    size() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.publickeys_size(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {PublicKey}\n    */\n    get(index) {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.publickeys_get(this.ptr, index);\n        return PublicKey.__wrap(ret);\n    }\n    /**\n    * @param {PublicKey} key\n    */\n    add(key) {\n        _assertClass(key, PublicKey);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.publickeys_add(this.ptr, key.ptr);\n    }\n}\n/**\n*/\nclass Redeemer {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Redeemer.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_redeemer_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.redeemer_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Redeemer}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.redeemer_from_bytes(ptr0, len0);\n        return Redeemer.__wrap(ret);\n    }\n    /**\n    * @returns {RedeemerTag}\n    */\n    tag() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.redeemer_tag(this.ptr);\n        return RedeemerTag.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum}\n    */\n    index() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.redeemer_index(this.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {PlutusData}\n    */\n    data() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.redeemer_data(this.ptr);\n        return PlutusData.__wrap(ret);\n    }\n    /**\n    * @returns {ExUnits}\n    */\n    ex_units() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.redeemer_ex_units(this.ptr);\n        return ExUnits.__wrap(ret);\n    }\n    /**\n    * @param {RedeemerTag} tag\n    * @param {BigNum} index\n    * @param {PlutusData} data\n    * @param {ExUnits} ex_units\n    * @returns {Redeemer}\n    */\n    static new(tag, index, data, ex_units) {\n        _assertClass(tag, RedeemerTag);\n        _assertClass(index, BigNum);\n        _assertClass(data, PlutusData);\n        _assertClass(ex_units, ExUnits);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.redeemer_new(tag.ptr, index.ptr, data.ptr, ex_units.ptr);\n        return Redeemer.__wrap(ret);\n    }\n}\n/**\n*/\nclass RedeemerTag {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RedeemerTag.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_redeemertag_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.redeemertag_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {RedeemerTag}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.redeemertag_from_bytes(ptr0, len0);\n        return RedeemerTag.__wrap(ret);\n    }\n    /**\n    * @returns {RedeemerTag}\n    */\n    static new_spend() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.redeemertag_new_spend();\n        return RedeemerTag.__wrap(ret);\n    }\n    /**\n    * @returns {RedeemerTag}\n    */\n    static new_mint() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.redeemertag_new_mint();\n        return RedeemerTag.__wrap(ret);\n    }\n    /**\n    * @returns {RedeemerTag}\n    */\n    static new_cert() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.redeemertag_new_cert();\n        return RedeemerTag.__wrap(ret);\n    }\n    /**\n    * @returns {RedeemerTag}\n    */\n    static new_reward() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.redeemertag_new_reward();\n        return RedeemerTag.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    kind() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.redeemertag_kind(this.ptr);\n        return ret >>> 0;\n    }\n}\n/**\n*/\nclass Redeemers {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Redeemers.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_redeemers_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.redeemers_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Redeemers}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.redeemers_from_bytes(ptr0, len0);\n        return Redeemers.__wrap(ret);\n    }\n    /**\n    * @returns {Redeemers}\n    */\n    static new() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.redeemers_new();\n        return Redeemers.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.redeemers_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {Redeemer}\n    */\n    get(index) {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.redeemers_get(this.ptr, index);\n        return Redeemer.__wrap(ret);\n    }\n    /**\n    * @param {Redeemer} elem\n    */\n    add(elem) {\n        _assertClass(elem, Redeemer);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.redeemers_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nclass Relay {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Relay.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_relay_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.relay_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Relay}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.relay_from_bytes(ptr0, len0);\n        return Relay.__wrap(ret);\n    }\n    /**\n    * @param {SingleHostAddr} single_host_addr\n    * @returns {Relay}\n    */\n    static new_single_host_addr(single_host_addr) {\n        _assertClass(single_host_addr, SingleHostAddr);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.relay_new_single_host_addr(single_host_addr.ptr);\n        return Relay.__wrap(ret);\n    }\n    /**\n    * @param {SingleHostName} single_host_name\n    * @returns {Relay}\n    */\n    static new_single_host_name(single_host_name) {\n        _assertClass(single_host_name, SingleHostName);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.relay_new_single_host_name(single_host_name.ptr);\n        return Relay.__wrap(ret);\n    }\n    /**\n    * @param {MultiHostName} multi_host_name\n    * @returns {Relay}\n    */\n    static new_multi_host_name(multi_host_name) {\n        _assertClass(multi_host_name, MultiHostName);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.relay_new_multi_host_name(multi_host_name.ptr);\n        return Relay.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    kind() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.relay_kind(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {SingleHostAddr | undefined}\n    */\n    as_single_host_addr() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.relay_as_single_host_addr(this.ptr);\n        return ret === 0 ? undefined : SingleHostAddr.__wrap(ret);\n    }\n    /**\n    * @returns {SingleHostName | undefined}\n    */\n    as_single_host_name() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.relay_as_single_host_name(this.ptr);\n        return ret === 0 ? undefined : SingleHostName.__wrap(ret);\n    }\n    /**\n    * @returns {MultiHostName | undefined}\n    */\n    as_multi_host_name() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.relay_as_multi_host_name(this.ptr);\n        return ret === 0 ? undefined : MultiHostName.__wrap(ret);\n    }\n}\n/**\n*/\nclass Relays {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Relays.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_relays_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.relays_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Relays}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.relays_from_bytes(ptr0, len0);\n        return Relays.__wrap(ret);\n    }\n    /**\n    * @returns {Relays}\n    */\n    static new() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.relays_new();\n        return Relays.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.relays_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {Relay}\n    */\n    get(index) {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.relays_get(this.ptr, index);\n        return Relay.__wrap(ret);\n    }\n    /**\n    * @param {Relay} elem\n    */\n    add(elem) {\n        _assertClass(elem, Relay);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.relays_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nclass RewardAddress {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RewardAddress.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_rewardaddress_free(ptr);\n    }\n    /**\n    * @param {number} network\n    * @param {StakeCredential} payment\n    * @returns {RewardAddress}\n    */\n    static new(network, payment) {\n        _assertClass(payment, StakeCredential);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.rewardaddress_new(network, payment.ptr);\n        return RewardAddress.__wrap(ret);\n    }\n    /**\n    * @returns {StakeCredential}\n    */\n    payment_cred() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.rewardaddress_payment_cred(this.ptr);\n        return StakeCredential.__wrap(ret);\n    }\n    /**\n    * @returns {Address}\n    */\n    to_address() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.rewardaddress_to_address(this.ptr);\n        return Address.__wrap(ret);\n    }\n    /**\n    * @param {Address} addr\n    * @returns {RewardAddress | undefined}\n    */\n    static from_address(addr) {\n        _assertClass(addr, Address);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.rewardaddress_from_address(addr.ptr);\n        return ret === 0 ? undefined : RewardAddress.__wrap(ret);\n    }\n}\n/**\n*/\nclass RewardAddresses {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RewardAddresses.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_rewardaddresses_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.rewardaddresses_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {RewardAddresses}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.rewardaddresses_from_bytes(ptr0, len0);\n        return RewardAddresses.__wrap(ret);\n    }\n    /**\n    * @returns {RewardAddresses}\n    */\n    static new() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.rewardaddresses_new();\n        return RewardAddresses.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.rewardaddresses_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {RewardAddress}\n    */\n    get(index) {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.rewardaddresses_get(this.ptr, index);\n        return RewardAddress.__wrap(ret);\n    }\n    /**\n    * @param {RewardAddress} elem\n    */\n    add(elem) {\n        _assertClass(elem, RewardAddress);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.rewardaddresses_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nclass ScriptAll {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ScriptAll.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_scriptall_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.scriptall_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ScriptAll}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.scriptall_from_bytes(ptr0, len0);\n        return ScriptAll.__wrap(ret);\n    }\n    /**\n    * @returns {NativeScripts}\n    */\n    native_scripts() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.scriptall_native_scripts(this.ptr);\n        return NativeScripts.__wrap(ret);\n    }\n    /**\n    * @param {NativeScripts} native_scripts\n    * @returns {ScriptAll}\n    */\n    static new(native_scripts) {\n        _assertClass(native_scripts, NativeScripts);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.scriptall_new(native_scripts.ptr);\n        return ScriptAll.__wrap(ret);\n    }\n}\n/**\n*/\nclass ScriptAny {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ScriptAny.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_scriptany_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.scriptany_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ScriptAny}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.scriptany_from_bytes(ptr0, len0);\n        return ScriptAny.__wrap(ret);\n    }\n    /**\n    * @returns {NativeScripts}\n    */\n    native_scripts() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.scriptany_native_scripts(this.ptr);\n        return NativeScripts.__wrap(ret);\n    }\n    /**\n    * @param {NativeScripts} native_scripts\n    * @returns {ScriptAny}\n    */\n    static new(native_scripts) {\n        _assertClass(native_scripts, NativeScripts);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.scriptany_new(native_scripts.ptr);\n        return ScriptAny.__wrap(ret);\n    }\n}\n/**\n*/\nclass ScriptDataHash {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ScriptDataHash.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_scriptdatahash_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.scriptdatahash_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} prefix\n    * @returns {string}\n    */\n    to_bech32(prefix) {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(prefix, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.scriptdatahash_to_bech32(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} bech_str\n    * @returns {ScriptDataHash}\n    */\n    static from_bech32(bech_str) {\n        var ptr0 = passStringToWasm0(bech_str, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.scriptdatahash_from_bech32(ptr0, len0);\n        return ScriptDataHash.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ScriptDataHash}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.scriptdatahash_from_bytes(ptr0, len0);\n        return ScriptDataHash.__wrap(ret);\n    }\n}\n/**\n*/\nclass ScriptHash {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ScriptHash.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_scripthash_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.scripthash_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} prefix\n    * @returns {string}\n    */\n    to_bech32(prefix) {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(prefix, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.scripthash_to_bech32(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} bech_str\n    * @returns {ScriptHash}\n    */\n    static from_bech32(bech_str) {\n        var ptr0 = passStringToWasm0(bech_str, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.scripthash_from_bech32(ptr0, len0);\n        return ScriptHash.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ScriptHash}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.scripthash_from_bytes(ptr0, len0);\n        return ScriptHash.__wrap(ret);\n    }\n}\n/**\n*/\nclass ScriptHashes {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ScriptHashes.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_scripthashes_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.scripthashes_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ScriptHashes}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.scripthashes_from_bytes(ptr0, len0);\n        return ScriptHashes.__wrap(ret);\n    }\n    /**\n    * @returns {ScriptHashes}\n    */\n    static new() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.scripthashes_new();\n        return ScriptHashes.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.scripthashes_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {ScriptHash}\n    */\n    get(index) {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.scripthashes_get(this.ptr, index);\n        return ScriptHash.__wrap(ret);\n    }\n    /**\n    * @param {ScriptHash} elem\n    */\n    add(elem) {\n        _assertClass(elem, ScriptHash);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.scripthashes_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nclass ScriptNOfK {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ScriptNOfK.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_scriptnofk_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.scriptnofk_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ScriptNOfK}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.scriptnofk_from_bytes(ptr0, len0);\n        return ScriptNOfK.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    n() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.scriptnofk_n(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {NativeScripts}\n    */\n    native_scripts() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.scriptnofk_native_scripts(this.ptr);\n        return NativeScripts.__wrap(ret);\n    }\n    /**\n    * @param {number} n\n    * @param {NativeScripts} native_scripts\n    * @returns {ScriptNOfK}\n    */\n    static new(n, native_scripts) {\n        _assertClass(native_scripts, NativeScripts);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.scriptnofk_new(n, native_scripts.ptr);\n        return ScriptNOfK.__wrap(ret);\n    }\n}\n/**\n*/\nclass ScriptPubkey {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ScriptPubkey.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_scriptpubkey_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.scriptpubkey_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ScriptPubkey}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.scriptpubkey_from_bytes(ptr0, len0);\n        return ScriptPubkey.__wrap(ret);\n    }\n    /**\n    * @returns {Ed25519KeyHash}\n    */\n    addr_keyhash() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.scriptpubkey_addr_keyhash(this.ptr);\n        return Ed25519KeyHash.__wrap(ret);\n    }\n    /**\n    * @param {Ed25519KeyHash} addr_keyhash\n    * @returns {ScriptPubkey}\n    */\n    static new(addr_keyhash) {\n        _assertClass(addr_keyhash, Ed25519KeyHash);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.scriptpubkey_new(addr_keyhash.ptr);\n        return ScriptPubkey.__wrap(ret);\n    }\n}\n/**\n*/\nclass SingleHostAddr {\n\n    static __wrap(ptr) {\n        const obj = Object.create(SingleHostAddr.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_singlehostaddr_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.singlehostaddr_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {SingleHostAddr}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.singlehostaddr_from_bytes(ptr0, len0);\n        return SingleHostAddr.__wrap(ret);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    port() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.singlehostaddr_port(this.ptr);\n        return ret === 0xFFFFFF ? undefined : ret;\n    }\n    /**\n    * @returns {Ipv4 | undefined}\n    */\n    ipv4() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.singlehostaddr_ipv4(this.ptr);\n        return ret === 0 ? undefined : Ipv4.__wrap(ret);\n    }\n    /**\n    * @returns {Ipv6 | undefined}\n    */\n    ipv6() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.singlehostaddr_ipv6(this.ptr);\n        return ret === 0 ? undefined : Ipv6.__wrap(ret);\n    }\n    /**\n    * @param {number | undefined} port\n    * @param {Ipv4 | undefined} ipv4\n    * @param {Ipv6 | undefined} ipv6\n    * @returns {SingleHostAddr}\n    */\n    static new(port, ipv4, ipv6) {\n        let ptr0 = 0;\n        if (!isLikeNone(ipv4)) {\n            _assertClass(ipv4, Ipv4);\n            ptr0 = ipv4.ptr;\n            ipv4.ptr = 0;\n        }\n        let ptr1 = 0;\n        if (!isLikeNone(ipv6)) {\n            _assertClass(ipv6, Ipv6);\n            ptr1 = ipv6.ptr;\n            ipv6.ptr = 0;\n        }\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.singlehostaddr_new(isLikeNone(port) ? 0xFFFFFF : port, ptr0, ptr1);\n        return SingleHostAddr.__wrap(ret);\n    }\n}\n/**\n*/\nclass SingleHostName {\n\n    static __wrap(ptr) {\n        const obj = Object.create(SingleHostName.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_singlehostname_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.singlehostname_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {SingleHostName}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.singlehostname_from_bytes(ptr0, len0);\n        return SingleHostName.__wrap(ret);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    port() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.singlehostname_port(this.ptr);\n        return ret === 0xFFFFFF ? undefined : ret;\n    }\n    /**\n    * @returns {DNSRecordAorAAAA}\n    */\n    dns_name() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.singlehostname_dns_name(this.ptr);\n        return DNSRecordAorAAAA.__wrap(ret);\n    }\n    /**\n    * @param {number | undefined} port\n    * @param {DNSRecordAorAAAA} dns_name\n    * @returns {SingleHostName}\n    */\n    static new(port, dns_name) {\n        _assertClass(dns_name, DNSRecordAorAAAA);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.singlehostname_new(isLikeNone(port) ? 0xFFFFFF : port, dns_name.ptr);\n        return SingleHostName.__wrap(ret);\n    }\n}\n/**\n*/\nclass StakeCredential {\n\n    static __wrap(ptr) {\n        const obj = Object.create(StakeCredential.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_stakecredential_free(ptr);\n    }\n    /**\n    * @param {Ed25519KeyHash} hash\n    * @returns {StakeCredential}\n    */\n    static from_keyhash(hash) {\n        _assertClass(hash, Ed25519KeyHash);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.stakecredential_from_keyhash(hash.ptr);\n        return StakeCredential.__wrap(ret);\n    }\n    /**\n    * @param {ScriptHash} hash\n    * @returns {StakeCredential}\n    */\n    static from_scripthash(hash) {\n        _assertClass(hash, ScriptHash);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.stakecredential_from_scripthash(hash.ptr);\n        return StakeCredential.__wrap(ret);\n    }\n    /**\n    * @returns {Ed25519KeyHash | undefined}\n    */\n    to_keyhash() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.stakecredential_to_keyhash(this.ptr);\n        return ret === 0 ? undefined : Ed25519KeyHash.__wrap(ret);\n    }\n    /**\n    * @returns {ScriptHash | undefined}\n    */\n    to_scripthash() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.stakecredential_to_scripthash(this.ptr);\n        return ret === 0 ? undefined : ScriptHash.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    kind() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.stakecredential_kind(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.stakecredential_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {StakeCredential}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.stakecredential_from_bytes(ptr0, len0);\n        return StakeCredential.__wrap(ret);\n    }\n}\n/**\n*/\nclass StakeCredentials {\n\n    static __wrap(ptr) {\n        const obj = Object.create(StakeCredentials.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_stakecredentials_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.stakecredentials_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {StakeCredentials}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.stakecredentials_from_bytes(ptr0, len0);\n        return StakeCredentials.__wrap(ret);\n    }\n    /**\n    * @returns {StakeCredentials}\n    */\n    static new() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.stakecredentials_new();\n        return StakeCredentials.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.stakecredentials_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {StakeCredential}\n    */\n    get(index) {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.stakecredentials_get(this.ptr, index);\n        return StakeCredential.__wrap(ret);\n    }\n    /**\n    * @param {StakeCredential} elem\n    */\n    add(elem) {\n        _assertClass(elem, StakeCredential);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.stakecredentials_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nclass StakeDelegation {\n\n    static __wrap(ptr) {\n        const obj = Object.create(StakeDelegation.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_stakedelegation_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.stakedelegation_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {StakeDelegation}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.stakedelegation_from_bytes(ptr0, len0);\n        return StakeDelegation.__wrap(ret);\n    }\n    /**\n    * @returns {StakeCredential}\n    */\n    stake_credential() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.stakedelegation_stake_credential(this.ptr);\n        return StakeCredential.__wrap(ret);\n    }\n    /**\n    * @returns {Ed25519KeyHash}\n    */\n    pool_keyhash() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.stakedelegation_pool_keyhash(this.ptr);\n        return Ed25519KeyHash.__wrap(ret);\n    }\n    /**\n    * @param {StakeCredential} stake_credential\n    * @param {Ed25519KeyHash} pool_keyhash\n    * @returns {StakeDelegation}\n    */\n    static new(stake_credential, pool_keyhash) {\n        _assertClass(stake_credential, StakeCredential);\n        _assertClass(pool_keyhash, Ed25519KeyHash);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.stakedelegation_new(stake_credential.ptr, pool_keyhash.ptr);\n        return StakeDelegation.__wrap(ret);\n    }\n}\n/**\n*/\nclass StakeDeregistration {\n\n    static __wrap(ptr) {\n        const obj = Object.create(StakeDeregistration.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_stakederegistration_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.stakederegistration_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {StakeDeregistration}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.stakederegistration_from_bytes(ptr0, len0);\n        return StakeDeregistration.__wrap(ret);\n    }\n    /**\n    * @returns {StakeCredential}\n    */\n    stake_credential() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.stakederegistration_stake_credential(this.ptr);\n        return StakeCredential.__wrap(ret);\n    }\n    /**\n    * @param {StakeCredential} stake_credential\n    * @returns {StakeDeregistration}\n    */\n    static new(stake_credential) {\n        _assertClass(stake_credential, StakeCredential);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.stakederegistration_new(stake_credential.ptr);\n        return StakeDeregistration.__wrap(ret);\n    }\n}\n/**\n*/\nclass StakeRegistration {\n\n    static __wrap(ptr) {\n        const obj = Object.create(StakeRegistration.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_stakeregistration_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.stakeregistration_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {StakeRegistration}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.stakeregistration_from_bytes(ptr0, len0);\n        return StakeRegistration.__wrap(ret);\n    }\n    /**\n    * @returns {StakeCredential}\n    */\n    stake_credential() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.stakeregistration_stake_credential(this.ptr);\n        return StakeCredential.__wrap(ret);\n    }\n    /**\n    * @param {StakeCredential} stake_credential\n    * @returns {StakeRegistration}\n    */\n    static new(stake_credential) {\n        _assertClass(stake_credential, StakeCredential);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.stakeregistration_new(stake_credential.ptr);\n        return StakeRegistration.__wrap(ret);\n    }\n}\n/**\n*/\nclass Strings {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Strings.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_strings_free(ptr);\n    }\n    /**\n    * @returns {Strings}\n    */\n    static new() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.strings_new();\n        return Strings.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.strings_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {string}\n    */\n    get(index) {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.strings_get(retptr, this.ptr, index);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} elem\n    */\n    add(elem) {\n        var ptr0 = passStringToWasm0(elem, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.strings_add(this.ptr, ptr0, len0);\n    }\n}\n/**\n*/\nclass TimelockExpiry {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TimelockExpiry.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_timelockexpiry_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.timelockexpiry_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TimelockExpiry}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.timelockexpiry_from_bytes(ptr0, len0);\n        return TimelockExpiry.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    slot() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.timelockexpiry_slot(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} slot\n    * @returns {TimelockExpiry}\n    */\n    static new(slot) {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.timelockexpiry_new(slot);\n        return TimelockExpiry.__wrap(ret);\n    }\n}\n/**\n*/\nclass TimelockStart {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TimelockStart.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_timelockstart_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.timelockstart_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TimelockStart}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.timelockstart_from_bytes(ptr0, len0);\n        return TimelockStart.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    slot() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.timelockstart_slot(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} slot\n    * @returns {TimelockStart}\n    */\n    static new(slot) {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.timelockstart_new(slot);\n        return TimelockStart.__wrap(ret);\n    }\n}\n/**\n*/\nclass Transaction {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Transaction.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_transaction_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transaction_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Transaction}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transaction_from_bytes(ptr0, len0);\n        return Transaction.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionBody}\n    */\n    body() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transaction_body(this.ptr);\n        return TransactionBody.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionWitnessSet}\n    */\n    witness_set() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transaction_witness_set(this.ptr);\n        return TransactionWitnessSet.__wrap(ret);\n    }\n    /**\n    * @returns {boolean}\n    */\n    is_valid() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transaction_is_valid(this.ptr);\n        return ret !== 0;\n    }\n    /**\n    * @returns {AuxiliaryData | undefined}\n    */\n    auxiliary_data() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transaction_auxiliary_data(this.ptr);\n        return ret === 0 ? undefined : AuxiliaryData.__wrap(ret);\n    }\n    /**\n    * @param {boolean} valid\n    */\n    set_is_valid(valid) {\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transaction_set_is_valid(this.ptr, valid);\n    }\n    /**\n    * @param {TransactionBody} body\n    * @param {TransactionWitnessSet} witness_set\n    * @param {AuxiliaryData | undefined} auxiliary_data\n    * @returns {Transaction}\n    */\n    static new(body, witness_set, auxiliary_data) {\n        _assertClass(body, TransactionBody);\n        _assertClass(witness_set, TransactionWitnessSet);\n        let ptr0 = 0;\n        if (!isLikeNone(auxiliary_data)) {\n            _assertClass(auxiliary_data, AuxiliaryData);\n            ptr0 = auxiliary_data.ptr;\n            auxiliary_data.ptr = 0;\n        }\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transaction_new(body.ptr, witness_set.ptr, ptr0);\n        return Transaction.__wrap(ret);\n    }\n}\n/**\n*/\nclass TransactionBodies {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TransactionBodies.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_transactionbodies_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbodies_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TransactionBodies}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbodies_from_bytes(ptr0, len0);\n        return TransactionBodies.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionBodies}\n    */\n    static new() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbodies_new();\n        return TransactionBodies.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbodies_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {TransactionBody}\n    */\n    get(index) {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbodies_get(this.ptr, index);\n        return TransactionBody.__wrap(ret);\n    }\n    /**\n    * @param {TransactionBody} elem\n    */\n    add(elem) {\n        _assertClass(elem, TransactionBody);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbodies_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nclass TransactionBody {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TransactionBody.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_transactionbody_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbody_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TransactionBody}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbody_from_bytes(ptr0, len0);\n        return TransactionBody.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionInputs}\n    */\n    inputs() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbody_inputs(this.ptr);\n        return TransactionInputs.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionOutputs}\n    */\n    outputs() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbody_outputs(this.ptr);\n        return TransactionOutputs.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum}\n    */\n    fee() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbody_fee(this.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    ttl() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbody_ttl(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Certificates} certs\n    */\n    set_certs(certs) {\n        _assertClass(certs, Certificates);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbody_set_certs(this.ptr, certs.ptr);\n    }\n    /**\n    * @returns {Certificates | undefined}\n    */\n    certs() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbody_certs(this.ptr);\n        return ret === 0 ? undefined : Certificates.__wrap(ret);\n    }\n    /**\n    * @param {Withdrawals} withdrawals\n    */\n    set_withdrawals(withdrawals) {\n        _assertClass(withdrawals, Withdrawals);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbody_set_withdrawals(this.ptr, withdrawals.ptr);\n    }\n    /**\n    * @returns {Withdrawals | undefined}\n    */\n    withdrawals() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbody_withdrawals(this.ptr);\n        return ret === 0 ? undefined : Withdrawals.__wrap(ret);\n    }\n    /**\n    * @param {Update} update\n    */\n    set_update(update) {\n        _assertClass(update, Update);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbody_set_update(this.ptr, update.ptr);\n    }\n    /**\n    * @returns {Update | undefined}\n    */\n    update() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbody_update(this.ptr);\n        return ret === 0 ? undefined : Update.__wrap(ret);\n    }\n    /**\n    * @param {AuxiliaryDataHash} auxiliary_data_hash\n    */\n    set_auxiliary_data_hash(auxiliary_data_hash) {\n        _assertClass(auxiliary_data_hash, AuxiliaryDataHash);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbody_set_auxiliary_data_hash(this.ptr, auxiliary_data_hash.ptr);\n    }\n    /**\n    * @returns {AuxiliaryDataHash | undefined}\n    */\n    auxiliary_data_hash() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbody_auxiliary_data_hash(this.ptr);\n        return ret === 0 ? undefined : AuxiliaryDataHash.__wrap(ret);\n    }\n    /**\n    * @param {number} validity_start_interval\n    */\n    set_validity_start_interval(validity_start_interval) {\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbody_set_validity_start_interval(this.ptr, validity_start_interval);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    validity_start_interval() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbody_validity_start_interval(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Mint} mint\n    */\n    set_mint(mint) {\n        _assertClass(mint, Mint);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbody_set_mint(this.ptr, mint.ptr);\n    }\n    /**\n    * @returns {Mint | undefined}\n    */\n    multiassets() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbody_multiassets(this.ptr);\n        return ret === 0 ? undefined : Mint.__wrap(ret);\n    }\n    /**\n    * @param {ScriptDataHash} script_data_hash\n    */\n    set_script_data_hash(script_data_hash) {\n        _assertClass(script_data_hash, ScriptDataHash);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbody_set_script_data_hash(this.ptr, script_data_hash.ptr);\n    }\n    /**\n    * @returns {ScriptDataHash | undefined}\n    */\n    script_data_hash() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbody_script_data_hash(this.ptr);\n        return ret === 0 ? undefined : ScriptDataHash.__wrap(ret);\n    }\n    /**\n    * @param {TransactionInputs} collateral\n    */\n    set_collateral(collateral) {\n        _assertClass(collateral, TransactionInputs);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbody_set_collateral(this.ptr, collateral.ptr);\n    }\n    /**\n    * @returns {TransactionInputs | undefined}\n    */\n    collateral() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbody_collateral(this.ptr);\n        return ret === 0 ? undefined : TransactionInputs.__wrap(ret);\n    }\n    /**\n    * @param {Ed25519KeyHashes} required_signers\n    */\n    set_required_signers(required_signers) {\n        _assertClass(required_signers, Ed25519KeyHashes);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbody_set_required_signers(this.ptr, required_signers.ptr);\n    }\n    /**\n    * @returns {Ed25519KeyHashes | undefined}\n    */\n    required_signers() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbody_required_signers(this.ptr);\n        return ret === 0 ? undefined : Ed25519KeyHashes.__wrap(ret);\n    }\n    /**\n    * @param {NetworkId} network_id\n    */\n    set_network_id(network_id) {\n        _assertClass(network_id, NetworkId);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbody_set_network_id(this.ptr, network_id.ptr);\n    }\n    /**\n    * @returns {NetworkId | undefined}\n    */\n    network_id() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbody_network_id(this.ptr);\n        return ret === 0 ? undefined : NetworkId.__wrap(ret);\n    }\n    /**\n    * @param {TransactionInputs} inputs\n    * @param {TransactionOutputs} outputs\n    * @param {BigNum} fee\n    * @param {number | undefined} ttl\n    * @returns {TransactionBody}\n    */\n    static new(inputs, outputs, fee, ttl) {\n        _assertClass(inputs, TransactionInputs);\n        _assertClass(outputs, TransactionOutputs);\n        _assertClass(fee, BigNum);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbody_new(inputs.ptr, outputs.ptr, fee.ptr, !isLikeNone(ttl), isLikeNone(ttl) ? 0 : ttl);\n        return TransactionBody.__wrap(ret);\n    }\n}\n/**\n*/\nclass TransactionBuilder {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TransactionBuilder.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_transactionbuilder_free(ptr);\n    }\n    /**\n    * This automatically selects and adds inputs from {inputs} consisting of just enough to cover\n    * the outputs that have already been added.\n    * This should be called after adding all certs/outputs/etc and will be an error otherwise.\n    * Uses CIP2: https://github.com/cardano-foundation/CIPs/blob/master/CIP-0002/CIP-0002.md\n    * Adding a change output must be called after via TransactionBuilder::add_change_if_needed()\n    * This function, diverging from CIP2, takes into account fees and will attempt to add additional\n    * inputs to cover the minimum fees. This does not, however, set the txbuilder's fee.\n    * @param {TransactionUnspentOutputs} inputs\n    * @param {number} strategy\n    */\n    add_inputs_from(inputs, strategy) {\n        _assertClass(inputs, TransactionUnspentOutputs);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbuilder_add_inputs_from(this.ptr, inputs.ptr, strategy);\n    }\n    /**\n    * We have to know what kind of inputs these are to know what kind of mock witnesses to create since\n    * 1) mock witnesses have different lengths depending on the type which changes the expecting fee\n    * 2) Witnesses are a set so we need to get rid of duplicates to avoid over-estimating the fee\n    * @param {Ed25519KeyHash} hash\n    * @param {TransactionInput} input\n    * @param {Value} amount\n    */\n    add_key_input(hash, input, amount) {\n        _assertClass(hash, Ed25519KeyHash);\n        _assertClass(input, TransactionInput);\n        _assertClass(amount, Value);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbuilder_add_key_input(this.ptr, hash.ptr, input.ptr, amount.ptr);\n    }\n    /**\n    * @param {ScriptHash} hash\n    * @param {TransactionInput} input\n    * @param {Value} amount\n    */\n    add_script_input(hash, input, amount) {\n        _assertClass(hash, ScriptHash);\n        _assertClass(input, TransactionInput);\n        _assertClass(amount, Value);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbuilder_add_script_input(this.ptr, hash.ptr, input.ptr, amount.ptr);\n    }\n    /**\n    * @param {ByronAddress} hash\n    * @param {TransactionInput} input\n    * @param {Value} amount\n    */\n    add_bootstrap_input(hash, input, amount) {\n        _assertClass(hash, ByronAddress);\n        _assertClass(input, TransactionInput);\n        _assertClass(amount, Value);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbuilder_add_bootstrap_input(this.ptr, hash.ptr, input.ptr, amount.ptr);\n    }\n    /**\n    * @param {Address} address\n    * @param {TransactionInput} input\n    * @param {Value} amount\n    */\n    add_input(address, input, amount) {\n        _assertClass(address, Address);\n        _assertClass(input, TransactionInput);\n        _assertClass(amount, Value);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbuilder_add_input(this.ptr, address.ptr, input.ptr, amount.ptr);\n    }\n    /**\n    * calculates how much the fee would increase if you added a given output\n    * @param {Address} address\n    * @param {TransactionInput} input\n    * @param {Value} amount\n    * @returns {BigNum}\n    */\n    fee_for_input(address, input, amount) {\n        _assertClass(address, Address);\n        _assertClass(input, TransactionInput);\n        _assertClass(amount, Value);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbuilder_fee_for_input(this.ptr, address.ptr, input.ptr, amount.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * Add output by specifying the Address and Value\n    * @param {Address} address\n    * @param {Value} amount\n    */\n    add_output_amount(address, amount) {\n        _assertClass(address, Address);\n        _assertClass(amount, Value);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbuilder_add_output_amount(this.ptr, address.ptr, amount.ptr);\n    }\n    /**\n    * Add output by specifying the Address and Coin (BigNum)\n    * Output will have no additional assets\n    * @param {Address} address\n    * @param {BigNum} coin\n    */\n    add_output_coin(address, coin) {\n        _assertClass(address, Address);\n        _assertClass(coin, BigNum);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbuilder_add_output_coin(this.ptr, address.ptr, coin.ptr);\n    }\n    /**\n    * Add output by specifying the Address, the Coin (BigNum), and the MultiAsset\n    * @param {Address} address\n    * @param {BigNum} coin\n    * @param {MultiAsset} multiasset\n    */\n    add_output_coin_and_asset(address, coin, multiasset) {\n        _assertClass(address, Address);\n        _assertClass(coin, BigNum);\n        _assertClass(multiasset, MultiAsset);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbuilder_add_output_coin_and_asset(this.ptr, address.ptr, coin.ptr, multiasset.ptr);\n    }\n    /**\n    * Add output by specifying the Address and the MultiAsset\n    * The output will be set to contain the minimum required amount of Coin\n    * @param {Address} address\n    * @param {MultiAsset} multiasset\n    */\n    add_output_asset_and_min_required_coin(address, multiasset) {\n        _assertClass(address, Address);\n        _assertClass(multiasset, MultiAsset);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbuilder_add_output_asset_and_min_required_coin(this.ptr, address.ptr, multiasset.ptr);\n    }\n    /**\n    * Add explicit output via a TransactionOutput object\n    * @param {TransactionOutput} output\n    */\n    add_output(output) {\n        _assertClass(output, TransactionOutput);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbuilder_add_output(this.ptr, output.ptr);\n    }\n    /**\n    * calculates how much the fee would increase if you added a given output\n    * @param {TransactionOutput} output\n    * @returns {BigNum}\n    */\n    fee_for_output(output) {\n        _assertClass(output, TransactionOutput);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbuilder_fee_for_output(this.ptr, output.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} fee\n    */\n    set_fee(fee) {\n        _assertClass(fee, BigNum);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbuilder_set_fee(this.ptr, fee.ptr);\n    }\n    /**\n    * @param {number} ttl\n    */\n    set_ttl(ttl) {\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbuilder_set_ttl(this.ptr, ttl);\n    }\n    /**\n    * @param {number} validity_start_interval\n    */\n    set_validity_start_interval(validity_start_interval) {\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbuilder_set_validity_start_interval(this.ptr, validity_start_interval);\n    }\n    /**\n    * @param {Certificates} certs\n    */\n    set_certs(certs) {\n        _assertClass(certs, Certificates);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbuilder_set_certs(this.ptr, certs.ptr);\n    }\n    /**\n    * @param {Withdrawals} withdrawals\n    */\n    set_withdrawals(withdrawals) {\n        _assertClass(withdrawals, Withdrawals);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbuilder_set_withdrawals(this.ptr, withdrawals.ptr);\n    }\n    /**\n    * @returns {AuxiliaryData | undefined}\n    */\n    get_auxiliary_data() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbuilder_get_auxiliary_data(this.ptr);\n        return ret === 0 ? undefined : AuxiliaryData.__wrap(ret);\n    }\n    /**\n    * Set explicit auxiliary data via an AuxiliaryData object\n    * It might contain some metadata plus native or Plutus scripts\n    * @param {AuxiliaryData} auxiliary_data\n    */\n    set_auxiliary_data(auxiliary_data) {\n        _assertClass(auxiliary_data, AuxiliaryData);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbuilder_set_auxiliary_data(this.ptr, auxiliary_data.ptr);\n    }\n    /**\n    * Set metadata using a GeneralTransactionMetadata object\n    * It will be set to the existing or new auxiliary data in this builder\n    * @param {GeneralTransactionMetadata} metadata\n    */\n    set_metadata(metadata) {\n        _assertClass(metadata, GeneralTransactionMetadata);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbuilder_set_metadata(this.ptr, metadata.ptr);\n    }\n    /**\n    * Add a single metadatum using TransactionMetadatumLabel and TransactionMetadatum objects\n    * It will be securely added to existing or new metadata in this builder\n    * @param {BigNum} key\n    * @param {TransactionMetadatum} val\n    */\n    add_metadatum(key, val) {\n        _assertClass(key, BigNum);\n        _assertClass(val, TransactionMetadatum);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbuilder_add_metadatum(this.ptr, key.ptr, val.ptr);\n    }\n    /**\n    * Add a single JSON metadatum using a TransactionMetadatumLabel and a String\n    * It will be securely added to existing or new metadata in this builder\n    * @param {BigNum} key\n    * @param {string} val\n    */\n    add_json_metadatum(key, val) {\n        _assertClass(key, BigNum);\n        var ptr0 = passStringToWasm0(val, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbuilder_add_json_metadatum(this.ptr, key.ptr, ptr0, len0);\n    }\n    /**\n    * Add a single JSON metadatum using a TransactionMetadatumLabel, a String, and a MetadataJsonSchema object\n    * It will be securely added to existing or new metadata in this builder\n    * @param {BigNum} key\n    * @param {string} val\n    * @param {number} schema\n    */\n    add_json_metadatum_with_schema(key, val, schema) {\n        _assertClass(key, BigNum);\n        var ptr0 = passStringToWasm0(val, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbuilder_add_json_metadatum_with_schema(this.ptr, key.ptr, ptr0, len0, schema);\n    }\n    /**\n    * Set explicit Mint object to this builder\n    * it will replace any previously existing mint\n    * NOTE! If you use `set_mint` manually - you must use `set_mint_scripts`\n    * to provide matching policy scripts or min-fee calculation will be rejected!\n    * @param {Mint} mint\n    */\n    set_mint(mint) {\n        _assertClass(mint, Mint);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbuilder_set_mint(this.ptr, mint.ptr);\n    }\n    /**\n    * Returns a copy of the current mint state in the builder\n    * @returns {Mint | undefined}\n    */\n    get_mint() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbuilder_get_mint(this.ptr);\n        return ret === 0 ? undefined : Mint.__wrap(ret);\n    }\n    /**\n    * Set explicit witness set to this builder\n    * It will replace any previously existing witnesses\n    * NOTE! Use carefully! If you are using `set_mint` - then you must be using\n    * this setter as well to be able to calculate fee automatically!\n    * @param {NativeScripts} mint_scripts\n    */\n    set_mint_scripts(mint_scripts) {\n        _assertClass(mint_scripts, NativeScripts);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbuilder_set_mint_scripts(this.ptr, mint_scripts.ptr);\n    }\n    /**\n    * Returns a copy of the current mint witness scripts in the builder\n    * @returns {NativeScripts | undefined}\n    */\n    get_mint_scripts() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbuilder_get_mint_scripts(this.ptr);\n        return ret === 0 ? undefined : NativeScripts.__wrap(ret);\n    }\n    /**\n    * Add a mint entry to this builder using a PolicyID and MintAssets object\n    * It will be securely added to existing or new Mint in this builder\n    * It will replace any existing mint assets with the same PolicyID\n    * @param {NativeScript} policy_script\n    * @param {MintAssets} mint_assets\n    */\n    set_mint_asset(policy_script, mint_assets) {\n        _assertClass(policy_script, NativeScript);\n        _assertClass(mint_assets, MintAssets);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbuilder_set_mint_asset(this.ptr, policy_script.ptr, mint_assets.ptr);\n    }\n    /**\n    * Add a mint entry to this builder using a PolicyID, AssetName, and Int object for amount\n    * It will be securely added to existing or new Mint in this builder\n    * It will replace any previous existing amount same PolicyID and AssetName\n    * @param {NativeScript} policy_script\n    * @param {AssetName} asset_name\n    * @param {Int} amount\n    */\n    add_mint_asset(policy_script, asset_name, amount) {\n        _assertClass(policy_script, NativeScript);\n        _assertClass(asset_name, AssetName);\n        _assertClass(amount, Int);\n        var ptr0 = amount.ptr;\n        amount.ptr = 0;\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbuilder_add_mint_asset(this.ptr, policy_script.ptr, asset_name.ptr, ptr0);\n    }\n    /**\n    * Add a mint entry together with an output to this builder\n    * Using a PolicyID, AssetName, Int for amount, Address, and Coin (BigNum) objects\n    * The asset will be securely added to existing or new Mint in this builder\n    * A new output will be added with the specified Address, the Coin value, and the minted asset\n    * @param {NativeScript} policy_script\n    * @param {AssetName} asset_name\n    * @param {Int} amount\n    * @param {Address} address\n    * @param {BigNum} output_coin\n    */\n    add_mint_asset_and_output(policy_script, asset_name, amount, address, output_coin) {\n        _assertClass(policy_script, NativeScript);\n        _assertClass(asset_name, AssetName);\n        _assertClass(amount, Int);\n        var ptr0 = amount.ptr;\n        amount.ptr = 0;\n        _assertClass(address, Address);\n        _assertClass(output_coin, BigNum);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbuilder_add_mint_asset_and_output(this.ptr, policy_script.ptr, asset_name.ptr, ptr0, address.ptr, output_coin.ptr);\n    }\n    /**\n    * Add a mint entry together with an output to this builder\n    * Using a PolicyID, AssetName, Int for amount, and Address objects\n    * The asset will be securely added to existing or new Mint in this builder\n    * A new output will be added with the specified Address and the minted asset\n    * The output will be set to contain the minimum required amount of Coin\n    * @param {NativeScript} policy_script\n    * @param {AssetName} asset_name\n    * @param {Int} amount\n    * @param {Address} address\n    */\n    add_mint_asset_and_output_min_required_coin(policy_script, asset_name, amount, address) {\n        _assertClass(policy_script, NativeScript);\n        _assertClass(asset_name, AssetName);\n        _assertClass(amount, Int);\n        var ptr0 = amount.ptr;\n        amount.ptr = 0;\n        _assertClass(address, Address);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbuilder_add_mint_asset_and_output_min_required_coin(this.ptr, policy_script.ptr, asset_name.ptr, ptr0, address.ptr);\n    }\n    /**\n    * @param {TransactionBuilderConfig} cfg\n    * @returns {TransactionBuilder}\n    */\n    static new(cfg) {\n        _assertClass(cfg, TransactionBuilderConfig);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbuilder_new(cfg.ptr);\n        return TransactionBuilder.__wrap(ret);\n    }\n    /**\n    * does not include refunds or withdrawals\n    * @returns {Value}\n    */\n    get_explicit_input() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbuilder_get_explicit_input(this.ptr);\n        return Value.__wrap(ret);\n    }\n    /**\n    * withdrawals and refunds\n    * @returns {Value}\n    */\n    get_implicit_input() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbuilder_get_implicit_input(this.ptr);\n        return Value.__wrap(ret);\n    }\n    /**\n    * does not include fee\n    * @returns {Value}\n    */\n    get_explicit_output() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbuilder_get_explicit_output(this.ptr);\n        return Value.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum}\n    */\n    get_deposit() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbuilder_get_deposit(this.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum | undefined}\n    */\n    get_fee_if_set() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbuilder_get_fee_if_set(this.ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * Warning: this function will mutate the /fee/ field\n    * Make sure to call this function last after setting all other tx-body properties\n    * Editing inputs, outputs, mint, etc. after change been calculated\n    * might cause a mismatch in calculated fee versus the required fee\n    * @param {Address} address\n    * @returns {boolean}\n    */\n    add_change_if_needed(address) {\n        _assertClass(address, Address);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbuilder_add_change_if_needed(this.ptr, address.ptr);\n        return ret !== 0;\n    }\n    /**\n    * @returns {number}\n    */\n    full_size() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbuilder_full_size(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {Uint32Array}\n    */\n    output_sizes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbuilder_output_sizes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU32FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 4);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Returns object the body of the new transaction\n    * Auxiliary data itself is not included\n    * You can use `get_auxiliary_data` or `build_tx`\n    * @returns {TransactionBody}\n    */\n    build() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbuilder_build(this.ptr);\n        return TransactionBody.__wrap(ret);\n    }\n    /**\n    * Returns full Transaction object with the body and the auxiliary data\n    * NOTE: witness_set will contain all mint_scripts if any been added or set\n    * NOTE: is_valid set to true\n    * @returns {Transaction}\n    */\n    build_tx() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbuilder_build_tx(this.ptr);\n        return Transaction.__wrap(ret);\n    }\n    /**\n    * warning: sum of all parts of a transaction must equal 0. You cannot just set the fee to the min value and forget about it\n    * warning: min_fee may be slightly larger than the actual minimum fee (ex: a few lovelaces)\n    * this is done to simplify the library code, but can be fixed later\n    * @returns {BigNum}\n    */\n    min_fee() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbuilder_min_fee(this.ptr);\n        return BigNum.__wrap(ret);\n    }\n}\n/**\n*/\nclass TransactionBuilderConfig {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TransactionBuilderConfig.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_transactionbuilderconfig_free(ptr);\n    }\n}\n/**\n*/\nclass TransactionBuilderConfigBuilder {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TransactionBuilderConfigBuilder.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_transactionbuilderconfigbuilder_free(ptr);\n    }\n    /**\n    * @returns {TransactionBuilderConfigBuilder}\n    */\n    static new() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbuilderconfigbuilder_new();\n        return TransactionBuilderConfigBuilder.__wrap(ret);\n    }\n    /**\n    * @param {LinearFee} fee_algo\n    * @returns {TransactionBuilderConfigBuilder}\n    */\n    fee_algo(fee_algo) {\n        _assertClass(fee_algo, LinearFee);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbuilderconfigbuilder_fee_algo(this.ptr, fee_algo.ptr);\n        return TransactionBuilderConfigBuilder.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} coins_per_utxo_word\n    * @returns {TransactionBuilderConfigBuilder}\n    */\n    coins_per_utxo_word(coins_per_utxo_word) {\n        _assertClass(coins_per_utxo_word, BigNum);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbuilderconfigbuilder_coins_per_utxo_word(this.ptr, coins_per_utxo_word.ptr);\n        return TransactionBuilderConfigBuilder.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} pool_deposit\n    * @returns {TransactionBuilderConfigBuilder}\n    */\n    pool_deposit(pool_deposit) {\n        _assertClass(pool_deposit, BigNum);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbuilderconfigbuilder_pool_deposit(this.ptr, pool_deposit.ptr);\n        return TransactionBuilderConfigBuilder.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} key_deposit\n    * @returns {TransactionBuilderConfigBuilder}\n    */\n    key_deposit(key_deposit) {\n        _assertClass(key_deposit, BigNum);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbuilderconfigbuilder_key_deposit(this.ptr, key_deposit.ptr);\n        return TransactionBuilderConfigBuilder.__wrap(ret);\n    }\n    /**\n    * @param {number} max_value_size\n    * @returns {TransactionBuilderConfigBuilder}\n    */\n    max_value_size(max_value_size) {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbuilderconfigbuilder_max_value_size(this.ptr, max_value_size);\n        return TransactionBuilderConfigBuilder.__wrap(ret);\n    }\n    /**\n    * @param {number} max_tx_size\n    * @returns {TransactionBuilderConfigBuilder}\n    */\n    max_tx_size(max_tx_size) {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbuilderconfigbuilder_max_tx_size(this.ptr, max_tx_size);\n        return TransactionBuilderConfigBuilder.__wrap(ret);\n    }\n    /**\n    * @param {boolean} prefer_pure_change\n    * @returns {TransactionBuilderConfigBuilder}\n    */\n    prefer_pure_change(prefer_pure_change) {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbuilderconfigbuilder_prefer_pure_change(this.ptr, prefer_pure_change);\n        return TransactionBuilderConfigBuilder.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionBuilderConfig}\n    */\n    build() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionbuilderconfigbuilder_build(this.ptr);\n        return TransactionBuilderConfig.__wrap(ret);\n    }\n}\n/**\n*/\nclass TransactionHash {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TransactionHash.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_transactionhash_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionhash_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} prefix\n    * @returns {string}\n    */\n    to_bech32(prefix) {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(prefix, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionhash_to_bech32(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} bech_str\n    * @returns {TransactionHash}\n    */\n    static from_bech32(bech_str) {\n        var ptr0 = passStringToWasm0(bech_str, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionhash_from_bech32(ptr0, len0);\n        return TransactionHash.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TransactionHash}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionhash_from_bytes(ptr0, len0);\n        return TransactionHash.__wrap(ret);\n    }\n}\n/**\n*/\nclass TransactionInput {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TransactionInput.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_transactioninput_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactioninput_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TransactionInput}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactioninput_from_bytes(ptr0, len0);\n        return TransactionInput.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionHash}\n    */\n    transaction_id() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactioninput_transaction_id(this.ptr);\n        return TransactionHash.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    index() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactioninput_index(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {TransactionHash} transaction_id\n    * @param {number} index\n    * @returns {TransactionInput}\n    */\n    static new(transaction_id, index) {\n        _assertClass(transaction_id, TransactionHash);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactioninput_new(transaction_id.ptr, index);\n        return TransactionInput.__wrap(ret);\n    }\n}\n/**\n*/\nclass TransactionInputs {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TransactionInputs.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_transactioninputs_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactioninputs_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TransactionInputs}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactioninputs_from_bytes(ptr0, len0);\n        return TransactionInputs.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionInputs}\n    */\n    static new() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactioninputs_new();\n        return TransactionInputs.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactioninputs_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {TransactionInput}\n    */\n    get(index) {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactioninputs_get(this.ptr, index);\n        return TransactionInput.__wrap(ret);\n    }\n    /**\n    * @param {TransactionInput} elem\n    */\n    add(elem) {\n        _assertClass(elem, TransactionInput);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactioninputs_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nclass TransactionMetadatum {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TransactionMetadatum.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_transactionmetadatum_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionmetadatum_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TransactionMetadatum}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionmetadatum_from_bytes(ptr0, len0);\n        return TransactionMetadatum.__wrap(ret);\n    }\n    /**\n    * @param {MetadataMap} map\n    * @returns {TransactionMetadatum}\n    */\n    static new_map(map) {\n        _assertClass(map, MetadataMap);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionmetadatum_new_map(map.ptr);\n        return TransactionMetadatum.__wrap(ret);\n    }\n    /**\n    * @param {MetadataList} list\n    * @returns {TransactionMetadatum}\n    */\n    static new_list(list) {\n        _assertClass(list, MetadataList);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionmetadatum_new_list(list.ptr);\n        return TransactionMetadatum.__wrap(ret);\n    }\n    /**\n    * @param {Int} int\n    * @returns {TransactionMetadatum}\n    */\n    static new_int(int) {\n        _assertClass(int, Int);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionmetadatum_new_int(int.ptr);\n        return TransactionMetadatum.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TransactionMetadatum}\n    */\n    static new_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionmetadatum_new_bytes(ptr0, len0);\n        return TransactionMetadatum.__wrap(ret);\n    }\n    /**\n    * @param {string} text\n    * @returns {TransactionMetadatum}\n    */\n    static new_text(text) {\n        var ptr0 = passStringToWasm0(text, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionmetadatum_new_text(ptr0, len0);\n        return TransactionMetadatum.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    kind() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionmetadatum_kind(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {MetadataMap}\n    */\n    as_map() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionmetadatum_as_map(this.ptr);\n        return MetadataMap.__wrap(ret);\n    }\n    /**\n    * @returns {MetadataList}\n    */\n    as_list() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionmetadatum_as_list(this.ptr);\n        return MetadataList.__wrap(ret);\n    }\n    /**\n    * @returns {Int}\n    */\n    as_int() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionmetadatum_as_int(this.ptr);\n        return Int.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    as_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionmetadatum_as_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    as_text() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionmetadatum_as_text(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1);\n        }\n    }\n}\n/**\n*/\nclass TransactionMetadatumLabels {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TransactionMetadatumLabels.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_transactionmetadatumlabels_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionmetadatumlabels_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TransactionMetadatumLabels}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionmetadatumlabels_from_bytes(ptr0, len0);\n        return TransactionMetadatumLabels.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionMetadatumLabels}\n    */\n    static new() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionmetadatumlabels_new();\n        return TransactionMetadatumLabels.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionmetadatumlabels_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {BigNum}\n    */\n    get(index) {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionmetadatumlabels_get(this.ptr, index);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} elem\n    */\n    add(elem) {\n        _assertClass(elem, BigNum);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionmetadatumlabels_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nclass TransactionOutput {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TransactionOutput.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_transactionoutput_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionoutput_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TransactionOutput}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionoutput_from_bytes(ptr0, len0);\n        return TransactionOutput.__wrap(ret);\n    }\n    /**\n    * @returns {Address}\n    */\n    address() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionoutput_address(this.ptr);\n        return Address.__wrap(ret);\n    }\n    /**\n    * @returns {Value}\n    */\n    amount() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionoutput_amount(this.ptr);\n        return Value.__wrap(ret);\n    }\n    /**\n    * @returns {DataHash | undefined}\n    */\n    data_hash() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionoutput_data_hash(this.ptr);\n        return ret === 0 ? undefined : DataHash.__wrap(ret);\n    }\n    /**\n    * @param {DataHash} data_hash\n    */\n    set_data_hash(data_hash) {\n        _assertClass(data_hash, DataHash);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionoutput_set_data_hash(this.ptr, data_hash.ptr);\n    }\n    /**\n    * @param {Address} address\n    * @param {Value} amount\n    * @returns {TransactionOutput}\n    */\n    static new(address, amount) {\n        _assertClass(address, Address);\n        _assertClass(amount, Value);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionoutput_new(address.ptr, amount.ptr);\n        return TransactionOutput.__wrap(ret);\n    }\n}\n/**\n*/\nclass TransactionOutputs {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TransactionOutputs.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_transactionoutputs_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionoutputs_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TransactionOutputs}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionoutputs_from_bytes(ptr0, len0);\n        return TransactionOutputs.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionOutputs}\n    */\n    static new() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionoutputs_new();\n        return TransactionOutputs.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionoutputs_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {TransactionOutput}\n    */\n    get(index) {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionoutputs_get(this.ptr, index);\n        return TransactionOutput.__wrap(ret);\n    }\n    /**\n    * @param {TransactionOutput} elem\n    */\n    add(elem) {\n        _assertClass(elem, TransactionOutput);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionoutputs_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nclass TransactionUnspentOutput {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TransactionUnspentOutput.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_transactionunspentoutput_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionunspentoutput_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TransactionUnspentOutput}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionunspentoutput_from_bytes(ptr0, len0);\n        return TransactionUnspentOutput.__wrap(ret);\n    }\n    /**\n    * @param {TransactionInput} input\n    * @param {TransactionOutput} output\n    * @returns {TransactionUnspentOutput}\n    */\n    static new(input, output) {\n        _assertClass(input, TransactionInput);\n        _assertClass(output, TransactionOutput);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionunspentoutput_new(input.ptr, output.ptr);\n        return TransactionUnspentOutput.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionInput}\n    */\n    input() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionunspentoutput_input(this.ptr);\n        return TransactionInput.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionOutput}\n    */\n    output() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionunspentoutput_output(this.ptr);\n        return TransactionOutput.__wrap(ret);\n    }\n}\n/**\n*/\nclass TransactionUnspentOutputs {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TransactionUnspentOutputs.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_transactionunspentoutputs_free(ptr);\n    }\n    /**\n    * @returns {TransactionUnspentOutputs}\n    */\n    static new() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionunspentoutputs_new();\n        return TransactionUnspentOutputs.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionunspentoutputs_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {TransactionUnspentOutput}\n    */\n    get(index) {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionunspentoutputs_get(this.ptr, index);\n        return TransactionUnspentOutput.__wrap(ret);\n    }\n    /**\n    * @param {TransactionUnspentOutput} elem\n    */\n    add(elem) {\n        _assertClass(elem, TransactionUnspentOutput);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionunspentoutputs_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nclass TransactionWitnessSet {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TransactionWitnessSet.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_transactionwitnessset_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionwitnessset_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TransactionWitnessSet}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionwitnessset_from_bytes(ptr0, len0);\n        return TransactionWitnessSet.__wrap(ret);\n    }\n    /**\n    * @param {Vkeywitnesses} vkeys\n    */\n    set_vkeys(vkeys) {\n        _assertClass(vkeys, Vkeywitnesses);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionwitnessset_set_vkeys(this.ptr, vkeys.ptr);\n    }\n    /**\n    * @returns {Vkeywitnesses | undefined}\n    */\n    vkeys() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionwitnessset_vkeys(this.ptr);\n        return ret === 0 ? undefined : Vkeywitnesses.__wrap(ret);\n    }\n    /**\n    * @param {NativeScripts} native_scripts\n    */\n    set_native_scripts(native_scripts) {\n        _assertClass(native_scripts, NativeScripts);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionwitnessset_set_native_scripts(this.ptr, native_scripts.ptr);\n    }\n    /**\n    * @returns {NativeScripts | undefined}\n    */\n    native_scripts() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionwitnessset_native_scripts(this.ptr);\n        return ret === 0 ? undefined : NativeScripts.__wrap(ret);\n    }\n    /**\n    * @param {BootstrapWitnesses} bootstraps\n    */\n    set_bootstraps(bootstraps) {\n        _assertClass(bootstraps, BootstrapWitnesses);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionwitnessset_set_bootstraps(this.ptr, bootstraps.ptr);\n    }\n    /**\n    * @returns {BootstrapWitnesses | undefined}\n    */\n    bootstraps() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionwitnessset_bootstraps(this.ptr);\n        return ret === 0 ? undefined : BootstrapWitnesses.__wrap(ret);\n    }\n    /**\n    * @param {PlutusScripts} plutus_scripts\n    */\n    set_plutus_scripts(plutus_scripts) {\n        _assertClass(plutus_scripts, PlutusScripts);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionwitnessset_set_plutus_scripts(this.ptr, plutus_scripts.ptr);\n    }\n    /**\n    * @returns {PlutusScripts | undefined}\n    */\n    plutus_scripts() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionwitnessset_plutus_scripts(this.ptr);\n        return ret === 0 ? undefined : PlutusScripts.__wrap(ret);\n    }\n    /**\n    * @param {PlutusList} plutus_data\n    */\n    set_plutus_data(plutus_data) {\n        _assertClass(plutus_data, PlutusList);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionwitnessset_set_plutus_data(this.ptr, plutus_data.ptr);\n    }\n    /**\n    * @returns {PlutusList | undefined}\n    */\n    plutus_data() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionwitnessset_plutus_data(this.ptr);\n        return ret === 0 ? undefined : PlutusList.__wrap(ret);\n    }\n    /**\n    * @param {Redeemers} redeemers\n    */\n    set_redeemers(redeemers) {\n        _assertClass(redeemers, Redeemers);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionwitnessset_set_redeemers(this.ptr, redeemers.ptr);\n    }\n    /**\n    * @returns {Redeemers | undefined}\n    */\n    redeemers() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionwitnessset_redeemers(this.ptr);\n        return ret === 0 ? undefined : Redeemers.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionWitnessSet}\n    */\n    static new() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionwitnessset_new();\n        return TransactionWitnessSet.__wrap(ret);\n    }\n}\n/**\n*/\nclass TransactionWitnessSets {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TransactionWitnessSets.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_transactionwitnesssets_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionwitnesssets_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TransactionWitnessSets}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionwitnesssets_from_bytes(ptr0, len0);\n        return TransactionWitnessSets.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionWitnessSets}\n    */\n    static new() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionwitnesssets_new();\n        return TransactionWitnessSets.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionwitnesssets_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {TransactionWitnessSet}\n    */\n    get(index) {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionwitnesssets_get(this.ptr, index);\n        return TransactionWitnessSet.__wrap(ret);\n    }\n    /**\n    * @param {TransactionWitnessSet} elem\n    */\n    add(elem) {\n        _assertClass(elem, TransactionWitnessSet);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.transactionwitnesssets_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nclass URL {\n\n    static __wrap(ptr) {\n        const obj = Object.create(URL.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_url_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.url_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {URL}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.url_from_bytes(ptr0, len0);\n        return URL.__wrap(ret);\n    }\n    /**\n    * @param {string} url\n    * @returns {URL}\n    */\n    static new(url) {\n        var ptr0 = passStringToWasm0(url, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.url_new(ptr0, len0);\n        return URL.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    url() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.url_url(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1);\n        }\n    }\n}\n/**\n*/\nclass UnitInterval {\n\n    static __wrap(ptr) {\n        const obj = Object.create(UnitInterval.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_unitinterval_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.unitinterval_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {UnitInterval}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.unitinterval_from_bytes(ptr0, len0);\n        return UnitInterval.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum}\n    */\n    numerator() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.unitinterval_numerator(this.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum}\n    */\n    denominator() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.unitinterval_denominator(this.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} numerator\n    * @param {BigNum} denominator\n    * @returns {UnitInterval}\n    */\n    static new(numerator, denominator) {\n        _assertClass(numerator, BigNum);\n        _assertClass(denominator, BigNum);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.unitinterval_new(numerator.ptr, denominator.ptr);\n        return UnitInterval.__wrap(ret);\n    }\n}\n/**\n*/\nclass Update {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Update.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_update_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.update_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Update}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.update_from_bytes(ptr0, len0);\n        return Update.__wrap(ret);\n    }\n    /**\n    * @returns {ProposedProtocolParameterUpdates}\n    */\n    proposed_protocol_parameter_updates() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.update_proposed_protocol_parameter_updates(this.ptr);\n        return ProposedProtocolParameterUpdates.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    epoch() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.update_epoch(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {ProposedProtocolParameterUpdates} proposed_protocol_parameter_updates\n    * @param {number} epoch\n    * @returns {Update}\n    */\n    static new(proposed_protocol_parameter_updates, epoch) {\n        _assertClass(proposed_protocol_parameter_updates, ProposedProtocolParameterUpdates);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.update_new(proposed_protocol_parameter_updates.ptr, epoch);\n        return Update.__wrap(ret);\n    }\n}\n/**\n*/\nclass VRFCert {\n\n    static __wrap(ptr) {\n        const obj = Object.create(VRFCert.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_vrfcert_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.vrfcert_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {VRFCert}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.vrfcert_from_bytes(ptr0, len0);\n        return VRFCert.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    output() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.vrfcert_output(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    proof() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.vrfcert_proof(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} output\n    * @param {Uint8Array} proof\n    * @returns {VRFCert}\n    */\n    static new(output, proof) {\n        var ptr0 = passArray8ToWasm0(output, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ptr1 = passArray8ToWasm0(proof, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len1 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.vrfcert_new(ptr0, len0, ptr1, len1);\n        return VRFCert.__wrap(ret);\n    }\n}\n/**\n*/\nclass VRFKeyHash {\n\n    static __wrap(ptr) {\n        const obj = Object.create(VRFKeyHash.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_vrfkeyhash_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.vrfkeyhash_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} prefix\n    * @returns {string}\n    */\n    to_bech32(prefix) {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(prefix, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.vrfkeyhash_to_bech32(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} bech_str\n    * @returns {VRFKeyHash}\n    */\n    static from_bech32(bech_str) {\n        var ptr0 = passStringToWasm0(bech_str, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.vrfkeyhash_from_bech32(ptr0, len0);\n        return VRFKeyHash.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {VRFKeyHash}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.vrfkeyhash_from_bytes(ptr0, len0);\n        return VRFKeyHash.__wrap(ret);\n    }\n}\n/**\n*/\nclass VRFVKey {\n\n    static __wrap(ptr) {\n        const obj = Object.create(VRFVKey.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_vrfvkey_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.vrfvkey_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} prefix\n    * @returns {string}\n    */\n    to_bech32(prefix) {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(prefix, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.vrfvkey_to_bech32(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} bech_str\n    * @returns {VRFVKey}\n    */\n    static from_bech32(bech_str) {\n        var ptr0 = passStringToWasm0(bech_str, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.vrfvkey_from_bech32(ptr0, len0);\n        return VRFVKey.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {VRFVKey}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.vrfvkey_from_bytes(ptr0, len0);\n        return VRFVKey.__wrap(ret);\n    }\n}\n/**\n*/\nclass Value {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Value.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_value_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.value_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Value}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.value_from_bytes(ptr0, len0);\n        return Value.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} coin\n    * @returns {Value}\n    */\n    static new(coin) {\n        _assertClass(coin, BigNum);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.value_new(coin.ptr);\n        return Value.__wrap(ret);\n    }\n    /**\n    * @param {MultiAsset} multiasset\n    * @returns {Value}\n    */\n    static new_from_assets(multiasset) {\n        _assertClass(multiasset, MultiAsset);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.value_new_from_assets(multiasset.ptr);\n        return Value.__wrap(ret);\n    }\n    /**\n    * @returns {Value}\n    */\n    static zero() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.value_zero();\n        return Value.__wrap(ret);\n    }\n    /**\n    * @returns {boolean}\n    */\n    is_zero() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.value_is_zero(this.ptr);\n        return ret !== 0;\n    }\n    /**\n    * @returns {BigNum}\n    */\n    coin() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.value_coin(this.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} coin\n    */\n    set_coin(coin) {\n        _assertClass(coin, BigNum);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.value_set_coin(this.ptr, coin.ptr);\n    }\n    /**\n    * @returns {MultiAsset | undefined}\n    */\n    multiasset() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.value_multiasset(this.ptr);\n        return ret === 0 ? undefined : MultiAsset.__wrap(ret);\n    }\n    /**\n    * @param {MultiAsset} multiasset\n    */\n    set_multiasset(multiasset) {\n        _assertClass(multiasset, MultiAsset);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.value_set_multiasset(this.ptr, multiasset.ptr);\n    }\n    /**\n    * @param {Value} rhs\n    * @returns {Value}\n    */\n    checked_add(rhs) {\n        _assertClass(rhs, Value);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.value_checked_add(this.ptr, rhs.ptr);\n        return Value.__wrap(ret);\n    }\n    /**\n    * @param {Value} rhs_value\n    * @returns {Value}\n    */\n    checked_sub(rhs_value) {\n        _assertClass(rhs_value, Value);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.value_checked_sub(this.ptr, rhs_value.ptr);\n        return Value.__wrap(ret);\n    }\n    /**\n    * @param {Value} rhs_value\n    * @returns {Value}\n    */\n    clamped_sub(rhs_value) {\n        _assertClass(rhs_value, Value);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.value_clamped_sub(this.ptr, rhs_value.ptr);\n        return Value.__wrap(ret);\n    }\n    /**\n    * note: values are only partially comparable\n    * @param {Value} rhs_value\n    * @returns {number | undefined}\n    */\n    compare(rhs_value) {\n        _assertClass(rhs_value, Value);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.value_compare(this.ptr, rhs_value.ptr);\n        return ret === 0xFFFFFF ? undefined : ret;\n    }\n}\n/**\n*/\nclass Vkey {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Vkey.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_vkey_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.vkey_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Vkey}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.vkey_from_bytes(ptr0, len0);\n        return Vkey.__wrap(ret);\n    }\n    /**\n    * @param {PublicKey} pk\n    * @returns {Vkey}\n    */\n    static new(pk) {\n        _assertClass(pk, PublicKey);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.vkey_new(pk.ptr);\n        return Vkey.__wrap(ret);\n    }\n    /**\n    * @returns {PublicKey}\n    */\n    public_key() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.vkey_public_key(this.ptr);\n        return PublicKey.__wrap(ret);\n    }\n}\n/**\n*/\nclass Vkeys {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Vkeys.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_vkeys_free(ptr);\n    }\n    /**\n    * @returns {Vkeys}\n    */\n    static new() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.vkeys_new();\n        return Vkeys.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.vkeys_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {Vkey}\n    */\n    get(index) {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.vkeys_get(this.ptr, index);\n        return Vkey.__wrap(ret);\n    }\n    /**\n    * @param {Vkey} elem\n    */\n    add(elem) {\n        _assertClass(elem, Vkey);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.vkeys_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nclass Vkeywitness {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Vkeywitness.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_vkeywitness_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.vkeywitness_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Vkeywitness}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.vkeywitness_from_bytes(ptr0, len0);\n        return Vkeywitness.__wrap(ret);\n    }\n    /**\n    * @param {Vkey} vkey\n    * @param {Ed25519Signature} signature\n    * @returns {Vkeywitness}\n    */\n    static new(vkey, signature) {\n        _assertClass(vkey, Vkey);\n        _assertClass(signature, Ed25519Signature);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.vkeywitness_new(vkey.ptr, signature.ptr);\n        return Vkeywitness.__wrap(ret);\n    }\n    /**\n    * @returns {Vkey}\n    */\n    vkey() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.vkeywitness_vkey(this.ptr);\n        return Vkey.__wrap(ret);\n    }\n    /**\n    * @returns {Ed25519Signature}\n    */\n    signature() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.vkeywitness_signature(this.ptr);\n        return Ed25519Signature.__wrap(ret);\n    }\n}\n/**\n*/\nclass Vkeywitnesses {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Vkeywitnesses.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_vkeywitnesses_free(ptr);\n    }\n    /**\n    * @returns {Vkeywitnesses}\n    */\n    static new() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.vkeywitnesses_new();\n        return Vkeywitnesses.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.vkeywitnesses_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {Vkeywitness}\n    */\n    get(index) {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.vkeywitnesses_get(this.ptr, index);\n        return Vkeywitness.__wrap(ret);\n    }\n    /**\n    * @param {Vkeywitness} elem\n    */\n    add(elem) {\n        _assertClass(elem, Vkeywitness);\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.vkeywitnesses_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nclass Withdrawals {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Withdrawals.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_withdrawals_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.withdrawals_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Withdrawals}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.withdrawals_from_bytes(ptr0, len0);\n        return Withdrawals.__wrap(ret);\n    }\n    /**\n    * @returns {Withdrawals}\n    */\n    static new() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.withdrawals_new();\n        return Withdrawals.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.withdrawals_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {RewardAddress} key\n    * @param {BigNum} value\n    * @returns {BigNum | undefined}\n    */\n    insert(key, value) {\n        _assertClass(key, RewardAddress);\n        _assertClass(value, BigNum);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.withdrawals_insert(this.ptr, key.ptr, value.ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @param {RewardAddress} key\n    * @returns {BigNum | undefined}\n    */\n    get(key) {\n        _assertClass(key, RewardAddress);\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.withdrawals_get(this.ptr, key.ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {RewardAddresses}\n    */\n    keys() {\n        var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.withdrawals_keys(this.ptr);\n        return RewardAddresses.__wrap(ret);\n    }\n}\n\nfunction __wbindgen_object_drop_ref(arg0) {\n    takeObject(arg0);\n};\n\nfunction __wbindgen_string_new(arg0, arg1) {\n    var ret = getStringFromWasm0(arg0, arg1);\n    return addHeapObject(ret);\n};\n\nfunction __wbg_getRandomValues_98117e9a7e993920() { return handleError(function (arg0, arg1) {\n    getObject(arg0).getRandomValues(getObject(arg1));\n}, arguments) };\n\nfunction __wbg_randomFillSync_64cc7d048f228ca8() { return handleError(function (arg0, arg1, arg2) {\n    getObject(arg0).randomFillSync(getArrayU8FromWasm0(arg1, arg2));\n}, arguments) };\n\nfunction __wbg_process_2f24d6544ea7b200(arg0) {\n    var ret = getObject(arg0).process;\n    return addHeapObject(ret);\n};\n\nfunction __wbindgen_is_object(arg0) {\n    const val = getObject(arg0);\n    var ret = typeof(val) === 'object' && val !== null;\n    return ret;\n};\n\nfunction __wbg_versions_6164651e75405d4a(arg0) {\n    var ret = getObject(arg0).versions;\n    return addHeapObject(ret);\n};\n\nfunction __wbg_node_4b517d861cbcb3bc(arg0) {\n    var ret = getObject(arg0).node;\n    return addHeapObject(ret);\n};\n\nfunction __wbg_crypto_98fc271021c7d2ad(arg0) {\n    var ret = getObject(arg0).crypto;\n    return addHeapObject(ret);\n};\n\nfunction __wbg_msCrypto_a2cdb043d2bfe57f(arg0) {\n    var ret = getObject(arg0).msCrypto;\n    return addHeapObject(ret);\n};\n\nfunction __wbg_modulerequire_3440a4bcf44437db() { return handleError(function (arg0, arg1) {\n    var ret = __webpack_require__(\"./node_modules/@emurgo/cardano-serialization-lib-browser sync recursive\")(getStringFromWasm0(arg0, arg1));\n    return addHeapObject(ret);\n}, arguments) };\n\nfunction __wbg_newnoargs_9fdd8f3961dd1bee(arg0, arg1) {\n    var ret = new Function(getStringFromWasm0(arg0, arg1));\n    return addHeapObject(ret);\n};\n\nfunction __wbg_call_ba36642bd901572b() { return handleError(function (arg0, arg1) {\n    var ret = getObject(arg0).call(getObject(arg1));\n    return addHeapObject(ret);\n}, arguments) };\n\nfunction __wbg_self_bb69a836a72ec6e9() { return handleError(function () {\n    var ret = self.self;\n    return addHeapObject(ret);\n}, arguments) };\n\nfunction __wbg_window_3304fc4b414c9693() { return handleError(function () {\n    var ret = window.window;\n    return addHeapObject(ret);\n}, arguments) };\n\nfunction __wbg_globalThis_e0d21cabc6630763() { return handleError(function () {\n    var ret = globalThis.globalThis;\n    return addHeapObject(ret);\n}, arguments) };\n\nfunction __wbg_global_8463719227271676() { return handleError(function () {\n    var ret = __webpack_require__.g.global;\n    return addHeapObject(ret);\n}, arguments) };\n\nfunction __wbindgen_is_undefined(arg0) {\n    var ret = getObject(arg0) === undefined;\n    return ret;\n};\n\nfunction __wbg_buffer_9e184d6f785de5ed(arg0) {\n    var ret = getObject(arg0).buffer;\n    return addHeapObject(ret);\n};\n\nfunction __wbg_new_e8101319e4cf95fc(arg0) {\n    var ret = new Uint8Array(getObject(arg0));\n    return addHeapObject(ret);\n};\n\nfunction __wbg_set_e8ae7b27314e8b98(arg0, arg1, arg2) {\n    getObject(arg0).set(getObject(arg1), arg2 >>> 0);\n};\n\nfunction __wbg_length_2d56cb37075fcfb1(arg0) {\n    var ret = getObject(arg0).length;\n    return ret;\n};\n\nfunction __wbg_newwithlength_a8d1dbcbe703a5c6(arg0) {\n    var ret = new Uint8Array(arg0 >>> 0);\n    return addHeapObject(ret);\n};\n\nfunction __wbg_subarray_901ede8318da52a6(arg0, arg1, arg2) {\n    var ret = getObject(arg0).subarray(arg1 >>> 0, arg2 >>> 0);\n    return addHeapObject(ret);\n};\n\nfunction __wbindgen_object_clone_ref(arg0) {\n    var ret = getObject(arg0);\n    return addHeapObject(ret);\n};\n\nfunction __wbg_new_3a746f2619705add(arg0, arg1) {\n    var ret = new Function(getStringFromWasm0(arg0, arg1));\n    return addHeapObject(ret);\n};\n\nfunction __wbg_call_f54d3a6dadb199ca(arg0, arg1) {\n    var ret = getObject(arg0).call(getObject(arg1));\n    return addHeapObject(ret);\n};\n\nfunction __wbindgen_jsval_eq(arg0, arg1) {\n    var ret = getObject(arg0) === getObject(arg1);\n    return ret;\n};\n\nfunction __wbg_self_ac379e780a0d8b94(arg0) {\n    var ret = getObject(arg0).self;\n    return addHeapObject(ret);\n};\n\nfunction __wbg_crypto_1e4302b85d4f64a2(arg0) {\n    var ret = getObject(arg0).crypto;\n    return addHeapObject(ret);\n};\n\nfunction __wbg_getRandomValues_1b4ba144162a5c9e(arg0) {\n    var ret = getObject(arg0).getRandomValues;\n    return addHeapObject(ret);\n};\n\nfunction __wbg_require_6461b1e9a0d7c34a(arg0, arg1) {\n    var ret = __webpack_require__(\"./node_modules/@emurgo/cardano-serialization-lib-browser sync recursive\")(getStringFromWasm0(arg0, arg1));\n    return addHeapObject(ret);\n};\n\nfunction __wbg_randomFillSync_1b52c8482374c55b(arg0, arg1, arg2) {\n    getObject(arg0).randomFillSync(getArrayU8FromWasm0(arg1, arg2));\n};\n\nfunction __wbg_getRandomValues_1ef11e888e5228e9(arg0, arg1, arg2) {\n    getObject(arg0).getRandomValues(getArrayU8FromWasm0(arg1, arg2));\n};\n\nfunction __wbindgen_is_string(arg0) {\n    var ret = typeof(getObject(arg0)) === 'string';\n    return ret;\n};\n\nfunction __wbindgen_string_get(arg0, arg1) {\n    const obj = getObject(arg1);\n    var ret = typeof(obj) === 'string' ? obj : undefined;\n    var ptr0 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_realloc);\n    var len0 = WASM_VECTOR_LEN;\n    getInt32Memory0()[arg0 / 4 + 1] = len0;\n    getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n};\n\nfunction __wbindgen_debug_string(arg0, arg1) {\n    var ret = debugString(getObject(arg1));\n    var ptr0 = passStringToWasm0(ret, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc, _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_realloc);\n    var len0 = WASM_VECTOR_LEN;\n    getInt32Memory0()[arg0 / 4 + 1] = len0;\n    getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n};\n\nfunction __wbindgen_throw(arg0, arg1) {\n    throw new Error(getStringFromWasm0(arg0, arg1));\n};\n\nfunction __wbindgen_rethrow(arg0) {\n    throw takeObject(arg0);\n};\n\nfunction __wbindgen_memory() {\n    var ret = _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.memory;\n    return addHeapObject(ret);\n};\n\n\n});\n\n//# sourceURL=webpack://test-webpack-wasm/./node_modules/@emurgo/cardano-serialization-lib-browser/cardano_serialization_lib_bg.js?");

/***/ }),

/***/ "./node_modules/@emurgo/cardano-serialization-lib-browser sync recursive":
/*!**********************************************************************!*\
  !*** ./node_modules/@emurgo/cardano-serialization-lib-browser/ sync ***!
  \**********************************************************************/
/***/ ((module) => {

eval("function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = () => ([]);\nwebpackEmptyContext.resolve = webpackEmptyContext;\nwebpackEmptyContext.id = \"./node_modules/@emurgo/cardano-serialization-lib-browser sync recursive\";\nmodule.exports = webpackEmptyContext;\n\n//# sourceURL=webpack://test-webpack-wasm/./node_modules/@emurgo/cardano-serialization-lib-browser/_sync?");

/***/ }),

/***/ "./node_modules/assert/build/assert.js":
/*!*********************************************!*\
  !*** ./node_modules/assert/build/assert.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var process = __webpack_require__(/*! ./node_modules/process/browser.js */ \"./node_modules/process/browser.js\");\n/* provided dependency */ var console = __webpack_require__(/*! ./node_modules/console-browserify/index.js */ \"./node_modules/console-browserify/index.js\");\n// Currently in sync with Node.js lib/assert.js\n// https://github.com/nodejs/node/commit/2a51ae424a513ec9a6aa3466baa0cc1d55dd4f3b\n// Originally from narwhal.js (http://narwhaljs.org)\n// Copyright (c) 2009 Thomas Robinson <280north.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the 'Software'), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _require = __webpack_require__(/*! ./internal/errors */ \"./node_modules/assert/build/internal/errors.js\"),\n    _require$codes = _require.codes,\n    ERR_AMBIGUOUS_ARGUMENT = _require$codes.ERR_AMBIGUOUS_ARGUMENT,\n    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n    ERR_INVALID_ARG_VALUE = _require$codes.ERR_INVALID_ARG_VALUE,\n    ERR_INVALID_RETURN_VALUE = _require$codes.ERR_INVALID_RETURN_VALUE,\n    ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;\n\nvar AssertionError = __webpack_require__(/*! ./internal/assert/assertion_error */ \"./node_modules/assert/build/internal/assert/assertion_error.js\");\n\nvar _require2 = __webpack_require__(/*! util/ */ \"./node_modules/util/util.js\"),\n    inspect = _require2.inspect;\n\nvar _require$types = (__webpack_require__(/*! util/ */ \"./node_modules/util/util.js\").types),\n    isPromise = _require$types.isPromise,\n    isRegExp = _require$types.isRegExp;\n\nvar objectAssign = Object.assign ? Object.assign : (__webpack_require__(/*! es6-object-assign */ \"./node_modules/es6-object-assign/index.js\").assign);\nvar objectIs = Object.is ? Object.is : __webpack_require__(/*! object-is */ \"./node_modules/object-is/index.js\");\nvar errorCache = new Map();\nvar isDeepEqual;\nvar isDeepStrictEqual;\nvar parseExpressionAt;\nvar findNodeAround;\nvar decoder;\n\nfunction lazyLoadComparison() {\n  var comparison = __webpack_require__(/*! ./internal/util/comparisons */ \"./node_modules/assert/build/internal/util/comparisons.js\");\n\n  isDeepEqual = comparison.isDeepEqual;\n  isDeepStrictEqual = comparison.isDeepStrictEqual;\n} // Escape control characters but not \\n and \\t to keep the line breaks and\n// indentation intact.\n// eslint-disable-next-line no-control-regex\n\n\nvar escapeSequencesRegExp = /[\\x00-\\x08\\x0b\\x0c\\x0e-\\x1f]/g;\nvar meta = [\"\\\\u0000\", \"\\\\u0001\", \"\\\\u0002\", \"\\\\u0003\", \"\\\\u0004\", \"\\\\u0005\", \"\\\\u0006\", \"\\\\u0007\", '\\\\b', '', '', \"\\\\u000b\", '\\\\f', '', \"\\\\u000e\", \"\\\\u000f\", \"\\\\u0010\", \"\\\\u0011\", \"\\\\u0012\", \"\\\\u0013\", \"\\\\u0014\", \"\\\\u0015\", \"\\\\u0016\", \"\\\\u0017\", \"\\\\u0018\", \"\\\\u0019\", \"\\\\u001a\", \"\\\\u001b\", \"\\\\u001c\", \"\\\\u001d\", \"\\\\u001e\", \"\\\\u001f\"];\n\nvar escapeFn = function escapeFn(str) {\n  return meta[str.charCodeAt(0)];\n};\n\nvar warned = false; // The assert module provides functions that throw\n// AssertionError's when particular conditions are not met. The\n// assert module must conform to the following interface.\n\nvar assert = module.exports = ok;\nvar NO_EXCEPTION_SENTINEL = {}; // All of the following functions must throw an AssertionError\n// when a corresponding condition is not met, with a message that\n// may be undefined if not provided. All assertion methods provide\n// both the actual and expected values to the assertion error for\n// display purposes.\n\nfunction innerFail(obj) {\n  if (obj.message instanceof Error) throw obj.message;\n  throw new AssertionError(obj);\n}\n\nfunction fail(actual, expected, message, operator, stackStartFn) {\n  var argsLen = arguments.length;\n  var internalMessage;\n\n  if (argsLen === 0) {\n    internalMessage = 'Failed';\n  } else if (argsLen === 1) {\n    message = actual;\n    actual = undefined;\n  } else {\n    if (warned === false) {\n      warned = true;\n      var warn = process.emitWarning ? process.emitWarning : console.warn.bind(console);\n      warn('assert.fail() with more than one argument is deprecated. ' + 'Please use assert.strictEqual() instead or only pass a message.', 'DeprecationWarning', 'DEP0094');\n    }\n\n    if (argsLen === 2) operator = '!=';\n  }\n\n  if (message instanceof Error) throw message;\n  var errArgs = {\n    actual: actual,\n    expected: expected,\n    operator: operator === undefined ? 'fail' : operator,\n    stackStartFn: stackStartFn || fail\n  };\n\n  if (message !== undefined) {\n    errArgs.message = message;\n  }\n\n  var err = new AssertionError(errArgs);\n\n  if (internalMessage) {\n    err.message = internalMessage;\n    err.generatedMessage = true;\n  }\n\n  throw err;\n}\n\nassert.fail = fail; // The AssertionError is defined in internal/error.\n\nassert.AssertionError = AssertionError;\n\nfunction innerOk(fn, argLen, value, message) {\n  if (!value) {\n    var generatedMessage = false;\n\n    if (argLen === 0) {\n      generatedMessage = true;\n      message = 'No value argument passed to `assert.ok()`';\n    } else if (message instanceof Error) {\n      throw message;\n    }\n\n    var err = new AssertionError({\n      actual: value,\n      expected: true,\n      message: message,\n      operator: '==',\n      stackStartFn: fn\n    });\n    err.generatedMessage = generatedMessage;\n    throw err;\n  }\n} // Pure assertion tests whether a value is truthy, as determined\n// by !!value.\n\n\nfunction ok() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  innerOk.apply(void 0, [ok, args.length].concat(args));\n}\n\nassert.ok = ok; // The equality assertion tests shallow, coercive equality with ==.\n\n/* eslint-disable no-restricted-properties */\n\nassert.equal = function equal(actual, expected, message) {\n  if (arguments.length < 2) {\n    throw new ERR_MISSING_ARGS('actual', 'expected');\n  } // eslint-disable-next-line eqeqeq\n\n\n  if (actual != expected) {\n    innerFail({\n      actual: actual,\n      expected: expected,\n      message: message,\n      operator: '==',\n      stackStartFn: equal\n    });\n  }\n}; // The non-equality assertion tests for whether two objects are not\n// equal with !=.\n\n\nassert.notEqual = function notEqual(actual, expected, message) {\n  if (arguments.length < 2) {\n    throw new ERR_MISSING_ARGS('actual', 'expected');\n  } // eslint-disable-next-line eqeqeq\n\n\n  if (actual == expected) {\n    innerFail({\n      actual: actual,\n      expected: expected,\n      message: message,\n      operator: '!=',\n      stackStartFn: notEqual\n    });\n  }\n}; // The equivalence assertion tests a deep equality relation.\n\n\nassert.deepEqual = function deepEqual(actual, expected, message) {\n  if (arguments.length < 2) {\n    throw new ERR_MISSING_ARGS('actual', 'expected');\n  }\n\n  if (isDeepEqual === undefined) lazyLoadComparison();\n\n  if (!isDeepEqual(actual, expected)) {\n    innerFail({\n      actual: actual,\n      expected: expected,\n      message: message,\n      operator: 'deepEqual',\n      stackStartFn: deepEqual\n    });\n  }\n}; // The non-equivalence assertion tests for any deep inequality.\n\n\nassert.notDeepEqual = function notDeepEqual(actual, expected, message) {\n  if (arguments.length < 2) {\n    throw new ERR_MISSING_ARGS('actual', 'expected');\n  }\n\n  if (isDeepEqual === undefined) lazyLoadComparison();\n\n  if (isDeepEqual(actual, expected)) {\n    innerFail({\n      actual: actual,\n      expected: expected,\n      message: message,\n      operator: 'notDeepEqual',\n      stackStartFn: notDeepEqual\n    });\n  }\n};\n/* eslint-enable */\n\n\nassert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {\n  if (arguments.length < 2) {\n    throw new ERR_MISSING_ARGS('actual', 'expected');\n  }\n\n  if (isDeepEqual === undefined) lazyLoadComparison();\n\n  if (!isDeepStrictEqual(actual, expected)) {\n    innerFail({\n      actual: actual,\n      expected: expected,\n      message: message,\n      operator: 'deepStrictEqual',\n      stackStartFn: deepStrictEqual\n    });\n  }\n};\n\nassert.notDeepStrictEqual = notDeepStrictEqual;\n\nfunction notDeepStrictEqual(actual, expected, message) {\n  if (arguments.length < 2) {\n    throw new ERR_MISSING_ARGS('actual', 'expected');\n  }\n\n  if (isDeepEqual === undefined) lazyLoadComparison();\n\n  if (isDeepStrictEqual(actual, expected)) {\n    innerFail({\n      actual: actual,\n      expected: expected,\n      message: message,\n      operator: 'notDeepStrictEqual',\n      stackStartFn: notDeepStrictEqual\n    });\n  }\n}\n\nassert.strictEqual = function strictEqual(actual, expected, message) {\n  if (arguments.length < 2) {\n    throw new ERR_MISSING_ARGS('actual', 'expected');\n  }\n\n  if (!objectIs(actual, expected)) {\n    innerFail({\n      actual: actual,\n      expected: expected,\n      message: message,\n      operator: 'strictEqual',\n      stackStartFn: strictEqual\n    });\n  }\n};\n\nassert.notStrictEqual = function notStrictEqual(actual, expected, message) {\n  if (arguments.length < 2) {\n    throw new ERR_MISSING_ARGS('actual', 'expected');\n  }\n\n  if (objectIs(actual, expected)) {\n    innerFail({\n      actual: actual,\n      expected: expected,\n      message: message,\n      operator: 'notStrictEqual',\n      stackStartFn: notStrictEqual\n    });\n  }\n};\n\nvar Comparison = function Comparison(obj, keys, actual) {\n  var _this = this;\n\n  _classCallCheck(this, Comparison);\n\n  keys.forEach(function (key) {\n    if (key in obj) {\n      if (actual !== undefined && typeof actual[key] === 'string' && isRegExp(obj[key]) && obj[key].test(actual[key])) {\n        _this[key] = actual[key];\n      } else {\n        _this[key] = obj[key];\n      }\n    }\n  });\n};\n\nfunction compareExceptionKey(actual, expected, key, message, keys, fn) {\n  if (!(key in actual) || !isDeepStrictEqual(actual[key], expected[key])) {\n    if (!message) {\n      // Create placeholder objects to create a nice output.\n      var a = new Comparison(actual, keys);\n      var b = new Comparison(expected, keys, actual);\n      var err = new AssertionError({\n        actual: a,\n        expected: b,\n        operator: 'deepStrictEqual',\n        stackStartFn: fn\n      });\n      err.actual = actual;\n      err.expected = expected;\n      err.operator = fn.name;\n      throw err;\n    }\n\n    innerFail({\n      actual: actual,\n      expected: expected,\n      message: message,\n      operator: fn.name,\n      stackStartFn: fn\n    });\n  }\n}\n\nfunction expectedException(actual, expected, msg, fn) {\n  if (typeof expected !== 'function') {\n    if (isRegExp(expected)) return expected.test(actual); // assert.doesNotThrow does not accept objects.\n\n    if (arguments.length === 2) {\n      throw new ERR_INVALID_ARG_TYPE('expected', ['Function', 'RegExp'], expected);\n    } // Handle primitives properly.\n\n\n    if (_typeof(actual) !== 'object' || actual === null) {\n      var err = new AssertionError({\n        actual: actual,\n        expected: expected,\n        message: msg,\n        operator: 'deepStrictEqual',\n        stackStartFn: fn\n      });\n      err.operator = fn.name;\n      throw err;\n    }\n\n    var keys = Object.keys(expected); // Special handle errors to make sure the name and the message are compared\n    // as well.\n\n    if (expected instanceof Error) {\n      keys.push('name', 'message');\n    } else if (keys.length === 0) {\n      throw new ERR_INVALID_ARG_VALUE('error', expected, 'may not be an empty object');\n    }\n\n    if (isDeepEqual === undefined) lazyLoadComparison();\n    keys.forEach(function (key) {\n      if (typeof actual[key] === 'string' && isRegExp(expected[key]) && expected[key].test(actual[key])) {\n        return;\n      }\n\n      compareExceptionKey(actual, expected, key, msg, keys, fn);\n    });\n    return true;\n  } // Guard instanceof against arrow functions as they don't have a prototype.\n\n\n  if (expected.prototype !== undefined && actual instanceof expected) {\n    return true;\n  }\n\n  if (Error.isPrototypeOf(expected)) {\n    return false;\n  }\n\n  return expected.call({}, actual) === true;\n}\n\nfunction getActual(fn) {\n  if (typeof fn !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE('fn', 'Function', fn);\n  }\n\n  try {\n    fn();\n  } catch (e) {\n    return e;\n  }\n\n  return NO_EXCEPTION_SENTINEL;\n}\n\nfunction checkIsPromise(obj) {\n  // Accept native ES6 promises and promises that are implemented in a similar\n  // way. Do not accept thenables that use a function as `obj` and that have no\n  // `catch` handler.\n  // TODO: thenables are checked up until they have the correct methods,\n  // but according to documentation, the `then` method should receive\n  // the `fulfill` and `reject` arguments as well or it may be never resolved.\n  return isPromise(obj) || obj !== null && _typeof(obj) === 'object' && typeof obj.then === 'function' && typeof obj.catch === 'function';\n}\n\nfunction waitForActual(promiseFn) {\n  return Promise.resolve().then(function () {\n    var resultPromise;\n\n    if (typeof promiseFn === 'function') {\n      // Return a rejected promise if `promiseFn` throws synchronously.\n      resultPromise = promiseFn(); // Fail in case no promise is returned.\n\n      if (!checkIsPromise(resultPromise)) {\n        throw new ERR_INVALID_RETURN_VALUE('instance of Promise', 'promiseFn', resultPromise);\n      }\n    } else if (checkIsPromise(promiseFn)) {\n      resultPromise = promiseFn;\n    } else {\n      throw new ERR_INVALID_ARG_TYPE('promiseFn', ['Function', 'Promise'], promiseFn);\n    }\n\n    return Promise.resolve().then(function () {\n      return resultPromise;\n    }).then(function () {\n      return NO_EXCEPTION_SENTINEL;\n    }).catch(function (e) {\n      return e;\n    });\n  });\n}\n\nfunction expectsError(stackStartFn, actual, error, message) {\n  if (typeof error === 'string') {\n    if (arguments.length === 4) {\n      throw new ERR_INVALID_ARG_TYPE('error', ['Object', 'Error', 'Function', 'RegExp'], error);\n    }\n\n    if (_typeof(actual) === 'object' && actual !== null) {\n      if (actual.message === error) {\n        throw new ERR_AMBIGUOUS_ARGUMENT('error/message', \"The error message \\\"\".concat(actual.message, \"\\\" is identical to the message.\"));\n      }\n    } else if (actual === error) {\n      throw new ERR_AMBIGUOUS_ARGUMENT('error/message', \"The error \\\"\".concat(actual, \"\\\" is identical to the message.\"));\n    }\n\n    message = error;\n    error = undefined;\n  } else if (error != null && _typeof(error) !== 'object' && typeof error !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE('error', ['Object', 'Error', 'Function', 'RegExp'], error);\n  }\n\n  if (actual === NO_EXCEPTION_SENTINEL) {\n    var details = '';\n\n    if (error && error.name) {\n      details += \" (\".concat(error.name, \")\");\n    }\n\n    details += message ? \": \".concat(message) : '.';\n    var fnType = stackStartFn.name === 'rejects' ? 'rejection' : 'exception';\n    innerFail({\n      actual: undefined,\n      expected: error,\n      operator: stackStartFn.name,\n      message: \"Missing expected \".concat(fnType).concat(details),\n      stackStartFn: stackStartFn\n    });\n  }\n\n  if (error && !expectedException(actual, error, message, stackStartFn)) {\n    throw actual;\n  }\n}\n\nfunction expectsNoError(stackStartFn, actual, error, message) {\n  if (actual === NO_EXCEPTION_SENTINEL) return;\n\n  if (typeof error === 'string') {\n    message = error;\n    error = undefined;\n  }\n\n  if (!error || expectedException(actual, error)) {\n    var details = message ? \": \".concat(message) : '.';\n    var fnType = stackStartFn.name === 'doesNotReject' ? 'rejection' : 'exception';\n    innerFail({\n      actual: actual,\n      expected: error,\n      operator: stackStartFn.name,\n      message: \"Got unwanted \".concat(fnType).concat(details, \"\\n\") + \"Actual message: \\\"\".concat(actual && actual.message, \"\\\"\"),\n      stackStartFn: stackStartFn\n    });\n  }\n\n  throw actual;\n}\n\nassert.throws = function throws(promiseFn) {\n  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    args[_key2 - 1] = arguments[_key2];\n  }\n\n  expectsError.apply(void 0, [throws, getActual(promiseFn)].concat(args));\n};\n\nassert.rejects = function rejects(promiseFn) {\n  for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    args[_key3 - 1] = arguments[_key3];\n  }\n\n  return waitForActual(promiseFn).then(function (result) {\n    return expectsError.apply(void 0, [rejects, result].concat(args));\n  });\n};\n\nassert.doesNotThrow = function doesNotThrow(fn) {\n  for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n    args[_key4 - 1] = arguments[_key4];\n  }\n\n  expectsNoError.apply(void 0, [doesNotThrow, getActual(fn)].concat(args));\n};\n\nassert.doesNotReject = function doesNotReject(fn) {\n  for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n    args[_key5 - 1] = arguments[_key5];\n  }\n\n  return waitForActual(fn).then(function (result) {\n    return expectsNoError.apply(void 0, [doesNotReject, result].concat(args));\n  });\n};\n\nassert.ifError = function ifError(err) {\n  if (err !== null && err !== undefined) {\n    var message = 'ifError got unwanted exception: ';\n\n    if (_typeof(err) === 'object' && typeof err.message === 'string') {\n      if (err.message.length === 0 && err.constructor) {\n        message += err.constructor.name;\n      } else {\n        message += err.message;\n      }\n    } else {\n      message += inspect(err);\n    }\n\n    var newErr = new AssertionError({\n      actual: err,\n      expected: null,\n      operator: 'ifError',\n      message: message,\n      stackStartFn: ifError\n    }); // Make sure we actually have a stack trace!\n\n    var origStack = err.stack;\n\n    if (typeof origStack === 'string') {\n      // This will remove any duplicated frames from the error frames taken\n      // from within `ifError` and add the original error frames to the newly\n      // created ones.\n      var tmp2 = origStack.split('\\n');\n      tmp2.shift(); // Filter all frames existing in err.stack.\n\n      var tmp1 = newErr.stack.split('\\n');\n\n      for (var i = 0; i < tmp2.length; i++) {\n        // Find the first occurrence of the frame.\n        var pos = tmp1.indexOf(tmp2[i]);\n\n        if (pos !== -1) {\n          // Only keep new frames.\n          tmp1 = tmp1.slice(0, pos);\n          break;\n        }\n      }\n\n      newErr.stack = \"\".concat(tmp1.join('\\n'), \"\\n\").concat(tmp2.join('\\n'));\n    }\n\n    throw newErr;\n  }\n}; // Expose a strict only variant of assert\n\n\nfunction strict() {\n  for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n    args[_key6] = arguments[_key6];\n  }\n\n  innerOk.apply(void 0, [strict, args.length].concat(args));\n}\n\nassert.strict = objectAssign(strict, assert, {\n  equal: assert.strictEqual,\n  deepEqual: assert.deepStrictEqual,\n  notEqual: assert.notStrictEqual,\n  notDeepEqual: assert.notDeepStrictEqual\n});\nassert.strict.strict = assert.strict;\n\n//# sourceURL=webpack://test-webpack-wasm/./node_modules/assert/build/assert.js?");

/***/ }),

/***/ "./node_modules/assert/build/internal/assert/assertion_error.js":
/*!**********************************************************************!*\
  !*** ./node_modules/assert/build/internal/assert/assertion_error.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var process = __webpack_require__(/*! ./node_modules/process/browser.js */ \"./node_modules/process/browser.js\");\n// Currently in sync with Node.js lib/internal/assert/assertion_error.js\n// https://github.com/nodejs/node/commit/0817840f775032169ddd70c85ac059f18ffcc81c\n\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === \"function\" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== \"function\") { throw new TypeError(\"Super expression must either be null or a function\"); } if (typeof _cache !== \"undefined\") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\n\nfunction isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\n\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf(\"[native code]\") !== -1; }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar _require = __webpack_require__(/*! util/ */ \"./node_modules/util/util.js\"),\n    inspect = _require.inspect;\n\nvar _require2 = __webpack_require__(/*! ../errors */ \"./node_modules/assert/build/internal/errors.js\"),\n    ERR_INVALID_ARG_TYPE = _require2.codes.ERR_INVALID_ARG_TYPE; // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith\n\n\nfunction endsWith(str, search, this_len) {\n  if (this_len === undefined || this_len > str.length) {\n    this_len = str.length;\n  }\n\n  return str.substring(this_len - search.length, this_len) === search;\n} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat\n\n\nfunction repeat(str, count) {\n  count = Math.floor(count);\n  if (str.length == 0 || count == 0) return '';\n  var maxCount = str.length * count;\n  count = Math.floor(Math.log(count) / Math.log(2));\n\n  while (count) {\n    str += str;\n    count--;\n  }\n\n  str += str.substring(0, maxCount - str.length);\n  return str;\n}\n\nvar blue = '';\nvar green = '';\nvar red = '';\nvar white = '';\nvar kReadableOperator = {\n  deepStrictEqual: 'Expected values to be strictly deep-equal:',\n  strictEqual: 'Expected values to be strictly equal:',\n  strictEqualObject: 'Expected \"actual\" to be reference-equal to \"expected\":',\n  deepEqual: 'Expected values to be loosely deep-equal:',\n  equal: 'Expected values to be loosely equal:',\n  notDeepStrictEqual: 'Expected \"actual\" not to be strictly deep-equal to:',\n  notStrictEqual: 'Expected \"actual\" to be strictly unequal to:',\n  notStrictEqualObject: 'Expected \"actual\" not to be reference-equal to \"expected\":',\n  notDeepEqual: 'Expected \"actual\" not to be loosely deep-equal to:',\n  notEqual: 'Expected \"actual\" to be loosely unequal to:',\n  notIdentical: 'Values identical but not reference-equal:'\n}; // Comparing short primitives should just show === / !== instead of using the\n// diff.\n\nvar kMaxShortLength = 10;\n\nfunction copyError(source) {\n  var keys = Object.keys(source);\n  var target = Object.create(Object.getPrototypeOf(source));\n  keys.forEach(function (key) {\n    target[key] = source[key];\n  });\n  Object.defineProperty(target, 'message', {\n    value: source.message\n  });\n  return target;\n}\n\nfunction inspectValue(val) {\n  // The util.inspect default values could be changed. This makes sure the\n  // error messages contain the necessary information nevertheless.\n  return inspect(val, {\n    compact: false,\n    customInspect: false,\n    depth: 1000,\n    maxArrayLength: Infinity,\n    // Assert compares only enumerable properties (with a few exceptions).\n    showHidden: false,\n    // Having a long line as error is better than wrapping the line for\n    // comparison for now.\n    // TODO(BridgeAR): `breakLength` should be limited as soon as soon as we\n    // have meta information about the inspected properties (i.e., know where\n    // in what line the property starts and ends).\n    breakLength: Infinity,\n    // Assert does not detect proxies currently.\n    showProxy: false,\n    sorted: true,\n    // Inspect getters as we also check them when comparing entries.\n    getters: true\n  });\n}\n\nfunction createErrDiff(actual, expected, operator) {\n  var other = '';\n  var res = '';\n  var lastPos = 0;\n  var end = '';\n  var skipped = false;\n  var actualInspected = inspectValue(actual);\n  var actualLines = actualInspected.split('\\n');\n  var expectedLines = inspectValue(expected).split('\\n');\n  var i = 0;\n  var indicator = ''; // In case both values are objects explicitly mark them as not reference equal\n  // for the `strictEqual` operator.\n\n  if (operator === 'strictEqual' && _typeof(actual) === 'object' && _typeof(expected) === 'object' && actual !== null && expected !== null) {\n    operator = 'strictEqualObject';\n  } // If \"actual\" and \"expected\" fit on a single line and they are not strictly\n  // equal, check further special handling.\n\n\n  if (actualLines.length === 1 && expectedLines.length === 1 && actualLines[0] !== expectedLines[0]) {\n    var inputLength = actualLines[0].length + expectedLines[0].length; // If the character length of \"actual\" and \"expected\" together is less than\n    // kMaxShortLength and if neither is an object and at least one of them is\n    // not `zero`, use the strict equal comparison to visualize the output.\n\n    if (inputLength <= kMaxShortLength) {\n      if ((_typeof(actual) !== 'object' || actual === null) && (_typeof(expected) !== 'object' || expected === null) && (actual !== 0 || expected !== 0)) {\n        // -0 === +0\n        return \"\".concat(kReadableOperator[operator], \"\\n\\n\") + \"\".concat(actualLines[0], \" !== \").concat(expectedLines[0], \"\\n\");\n      }\n    } else if (operator !== 'strictEqualObject') {\n      // If the stderr is a tty and the input length is lower than the current\n      // columns per line, add a mismatch indicator below the output. If it is\n      // not a tty, use a default value of 80 characters.\n      var maxLength = process.stderr && process.stderr.isTTY ? process.stderr.columns : 80;\n\n      if (inputLength < maxLength) {\n        while (actualLines[0][i] === expectedLines[0][i]) {\n          i++;\n        } // Ignore the first characters.\n\n\n        if (i > 2) {\n          // Add position indicator for the first mismatch in case it is a\n          // single line and the input length is less than the column length.\n          indicator = \"\\n  \".concat(repeat(' ', i), \"^\");\n          i = 0;\n        }\n      }\n    }\n  } // Remove all ending lines that match (this optimizes the output for\n  // readability by reducing the number of total changed lines).\n\n\n  var a = actualLines[actualLines.length - 1];\n  var b = expectedLines[expectedLines.length - 1];\n\n  while (a === b) {\n    if (i++ < 2) {\n      end = \"\\n  \".concat(a).concat(end);\n    } else {\n      other = a;\n    }\n\n    actualLines.pop();\n    expectedLines.pop();\n    if (actualLines.length === 0 || expectedLines.length === 0) break;\n    a = actualLines[actualLines.length - 1];\n    b = expectedLines[expectedLines.length - 1];\n  }\n\n  var maxLines = Math.max(actualLines.length, expectedLines.length); // Strict equal with identical objects that are not identical by reference.\n  // E.g., assert.deepStrictEqual({ a: Symbol() }, { a: Symbol() })\n\n  if (maxLines === 0) {\n    // We have to get the result again. The lines were all removed before.\n    var _actualLines = actualInspected.split('\\n'); // Only remove lines in case it makes sense to collapse those.\n    // TODO: Accept env to always show the full error.\n\n\n    if (_actualLines.length > 30) {\n      _actualLines[26] = \"\".concat(blue, \"...\").concat(white);\n\n      while (_actualLines.length > 27) {\n        _actualLines.pop();\n      }\n    }\n\n    return \"\".concat(kReadableOperator.notIdentical, \"\\n\\n\").concat(_actualLines.join('\\n'), \"\\n\");\n  }\n\n  if (i > 3) {\n    end = \"\\n\".concat(blue, \"...\").concat(white).concat(end);\n    skipped = true;\n  }\n\n  if (other !== '') {\n    end = \"\\n  \".concat(other).concat(end);\n    other = '';\n  }\n\n  var printedLines = 0;\n  var msg = kReadableOperator[operator] + \"\\n\".concat(green, \"+ actual\").concat(white, \" \").concat(red, \"- expected\").concat(white);\n  var skippedMsg = \" \".concat(blue, \"...\").concat(white, \" Lines skipped\");\n\n  for (i = 0; i < maxLines; i++) {\n    // Only extra expected lines exist\n    var cur = i - lastPos;\n\n    if (actualLines.length < i + 1) {\n      // If the last diverging line is more than one line above and the\n      // current line is at least line three, add some of the former lines and\n      // also add dots to indicate skipped entries.\n      if (cur > 1 && i > 2) {\n        if (cur > 4) {\n          res += \"\\n\".concat(blue, \"...\").concat(white);\n          skipped = true;\n        } else if (cur > 3) {\n          res += \"\\n  \".concat(expectedLines[i - 2]);\n          printedLines++;\n        }\n\n        res += \"\\n  \".concat(expectedLines[i - 1]);\n        printedLines++;\n      } // Mark the current line as the last diverging one.\n\n\n      lastPos = i; // Add the expected line to the cache.\n\n      other += \"\\n\".concat(red, \"-\").concat(white, \" \").concat(expectedLines[i]);\n      printedLines++; // Only extra actual lines exist\n    } else if (expectedLines.length < i + 1) {\n      // If the last diverging line is more than one line above and the\n      // current line is at least line three, add some of the former lines and\n      // also add dots to indicate skipped entries.\n      if (cur > 1 && i > 2) {\n        if (cur > 4) {\n          res += \"\\n\".concat(blue, \"...\").concat(white);\n          skipped = true;\n        } else if (cur > 3) {\n          res += \"\\n  \".concat(actualLines[i - 2]);\n          printedLines++;\n        }\n\n        res += \"\\n  \".concat(actualLines[i - 1]);\n        printedLines++;\n      } // Mark the current line as the last diverging one.\n\n\n      lastPos = i; // Add the actual line to the result.\n\n      res += \"\\n\".concat(green, \"+\").concat(white, \" \").concat(actualLines[i]);\n      printedLines++; // Lines diverge\n    } else {\n      var expectedLine = expectedLines[i];\n      var actualLine = actualLines[i]; // If the lines diverge, specifically check for lines that only diverge by\n      // a trailing comma. In that case it is actually identical and we should\n      // mark it as such.\n\n      var divergingLines = actualLine !== expectedLine && (!endsWith(actualLine, ',') || actualLine.slice(0, -1) !== expectedLine); // If the expected line has a trailing comma but is otherwise identical,\n      // add a comma at the end of the actual line. Otherwise the output could\n      // look weird as in:\n      //\n      //   [\n      //     1         // No comma at the end!\n      // +   2\n      //   ]\n      //\n\n      if (divergingLines && endsWith(expectedLine, ',') && expectedLine.slice(0, -1) === actualLine) {\n        divergingLines = false;\n        actualLine += ',';\n      }\n\n      if (divergingLines) {\n        // If the last diverging line is more than one line above and the\n        // current line is at least line three, add some of the former lines and\n        // also add dots to indicate skipped entries.\n        if (cur > 1 && i > 2) {\n          if (cur > 4) {\n            res += \"\\n\".concat(blue, \"...\").concat(white);\n            skipped = true;\n          } else if (cur > 3) {\n            res += \"\\n  \".concat(actualLines[i - 2]);\n            printedLines++;\n          }\n\n          res += \"\\n  \".concat(actualLines[i - 1]);\n          printedLines++;\n        } // Mark the current line as the last diverging one.\n\n\n        lastPos = i; // Add the actual line to the result and cache the expected diverging\n        // line so consecutive diverging lines show up as +++--- and not +-+-+-.\n\n        res += \"\\n\".concat(green, \"+\").concat(white, \" \").concat(actualLine);\n        other += \"\\n\".concat(red, \"-\").concat(white, \" \").concat(expectedLine);\n        printedLines += 2; // Lines are identical\n      } else {\n        // Add all cached information to the result before adding other things\n        // and reset the cache.\n        res += other;\n        other = ''; // If the last diverging line is exactly one line above or if it is the\n        // very first line, add the line to the result.\n\n        if (cur === 1 || i === 0) {\n          res += \"\\n  \".concat(actualLine);\n          printedLines++;\n        }\n      }\n    } // Inspected object to big (Show ~20 rows max)\n\n\n    if (printedLines > 20 && i < maxLines - 2) {\n      return \"\".concat(msg).concat(skippedMsg, \"\\n\").concat(res, \"\\n\").concat(blue, \"...\").concat(white).concat(other, \"\\n\") + \"\".concat(blue, \"...\").concat(white);\n    }\n  }\n\n  return \"\".concat(msg).concat(skipped ? skippedMsg : '', \"\\n\").concat(res).concat(other).concat(end).concat(indicator);\n}\n\nvar AssertionError =\n/*#__PURE__*/\nfunction (_Error) {\n  _inherits(AssertionError, _Error);\n\n  function AssertionError(options) {\n    var _this;\n\n    _classCallCheck(this, AssertionError);\n\n    if (_typeof(options) !== 'object' || options === null) {\n      throw new ERR_INVALID_ARG_TYPE('options', 'Object', options);\n    }\n\n    var message = options.message,\n        operator = options.operator,\n        stackStartFn = options.stackStartFn;\n    var actual = options.actual,\n        expected = options.expected;\n    var limit = Error.stackTraceLimit;\n    Error.stackTraceLimit = 0;\n\n    if (message != null) {\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, String(message)));\n    } else {\n      if (process.stderr && process.stderr.isTTY) {\n        // Reset on each call to make sure we handle dynamically set environment\n        // variables correct.\n        if (process.stderr && process.stderr.getColorDepth && process.stderr.getColorDepth() !== 1) {\n          blue = \"\\x1B[34m\";\n          green = \"\\x1B[32m\";\n          white = \"\\x1B[39m\";\n          red = \"\\x1B[31m\";\n        } else {\n          blue = '';\n          green = '';\n          white = '';\n          red = '';\n        }\n      } // Prevent the error stack from being visible by duplicating the error\n      // in a very close way to the original in case both sides are actually\n      // instances of Error.\n\n\n      if (_typeof(actual) === 'object' && actual !== null && _typeof(expected) === 'object' && expected !== null && 'stack' in actual && actual instanceof Error && 'stack' in expected && expected instanceof Error) {\n        actual = copyError(actual);\n        expected = copyError(expected);\n      }\n\n      if (operator === 'deepStrictEqual' || operator === 'strictEqual') {\n        _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, createErrDiff(actual, expected, operator)));\n      } else if (operator === 'notDeepStrictEqual' || operator === 'notStrictEqual') {\n        // In case the objects are equal but the operator requires unequal, show\n        // the first object and say A equals B\n        var base = kReadableOperator[operator];\n        var res = inspectValue(actual).split('\\n'); // In case \"actual\" is an object, it should not be reference equal.\n\n        if (operator === 'notStrictEqual' && _typeof(actual) === 'object' && actual !== null) {\n          base = kReadableOperator.notStrictEqualObject;\n        } // Only remove lines in case it makes sense to collapse those.\n        // TODO: Accept env to always show the full error.\n\n\n        if (res.length > 30) {\n          res[26] = \"\".concat(blue, \"...\").concat(white);\n\n          while (res.length > 27) {\n            res.pop();\n          }\n        } // Only print a single input.\n\n\n        if (res.length === 1) {\n          _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, \"\".concat(base, \" \").concat(res[0])));\n        } else {\n          _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, \"\".concat(base, \"\\n\\n\").concat(res.join('\\n'), \"\\n\")));\n        }\n      } else {\n        var _res = inspectValue(actual);\n\n        var other = '';\n        var knownOperators = kReadableOperator[operator];\n\n        if (operator === 'notDeepEqual' || operator === 'notEqual') {\n          _res = \"\".concat(kReadableOperator[operator], \"\\n\\n\").concat(_res);\n\n          if (_res.length > 1024) {\n            _res = \"\".concat(_res.slice(0, 1021), \"...\");\n          }\n        } else {\n          other = \"\".concat(inspectValue(expected));\n\n          if (_res.length > 512) {\n            _res = \"\".concat(_res.slice(0, 509), \"...\");\n          }\n\n          if (other.length > 512) {\n            other = \"\".concat(other.slice(0, 509), \"...\");\n          }\n\n          if (operator === 'deepEqual' || operator === 'equal') {\n            _res = \"\".concat(knownOperators, \"\\n\\n\").concat(_res, \"\\n\\nshould equal\\n\\n\");\n          } else {\n            other = \" \".concat(operator, \" \").concat(other);\n          }\n        }\n\n        _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, \"\".concat(_res).concat(other)));\n      }\n    }\n\n    Error.stackTraceLimit = limit;\n    _this.generatedMessage = !message;\n    Object.defineProperty(_assertThisInitialized(_this), 'name', {\n      value: 'AssertionError [ERR_ASSERTION]',\n      enumerable: false,\n      writable: true,\n      configurable: true\n    });\n    _this.code = 'ERR_ASSERTION';\n    _this.actual = actual;\n    _this.expected = expected;\n    _this.operator = operator;\n\n    if (Error.captureStackTrace) {\n      // eslint-disable-next-line no-restricted-syntax\n      Error.captureStackTrace(_assertThisInitialized(_this), stackStartFn);\n    } // Create error message including the error code in the name.\n\n\n    _this.stack; // Reset the name.\n\n    _this.name = 'AssertionError';\n    return _possibleConstructorReturn(_this);\n  }\n\n  _createClass(AssertionError, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"\".concat(this.name, \" [\").concat(this.code, \"]: \").concat(this.message);\n    }\n  }, {\n    key: inspect.custom,\n    value: function value(recurseTimes, ctx) {\n      // This limits the `actual` and `expected` property default inspection to\n      // the minimum depth. Otherwise those values would be too verbose compared\n      // to the actual error message which contains a combined view of these two\n      // input values.\n      return inspect(this, _objectSpread({}, ctx, {\n        customInspect: false,\n        depth: 0\n      }));\n    }\n  }]);\n\n  return AssertionError;\n}(_wrapNativeSuper(Error));\n\nmodule.exports = AssertionError;\n\n//# sourceURL=webpack://test-webpack-wasm/./node_modules/assert/build/internal/assert/assertion_error.js?");

/***/ }),

/***/ "./node_modules/assert/build/internal/errors.js":
/*!******************************************************!*\
  !*** ./node_modules/assert/build/internal/errors.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Currently in sync with Node.js lib/internal/errors.js\n// https://github.com/nodejs/node/commit/3b044962c48fe313905877a96b5d0894a5404f6f\n\n/* eslint node-core/documented-errors: \"error\" */\n\n/* eslint node-core/alphabetize-errors: \"error\" */\n\n/* eslint node-core/prefer-util-format-errors: \"error\" */\n // The whole point behind this internal module is to allow Node.js to no\n// longer be forced to treat every error message change as a semver-major\n// change. The NodeError classes here all expose a `code` property whose\n// value statically and permanently identifies the error. While the error\n// message may change, the code should not.\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar codes = {}; // Lazy loaded\n\nvar assert;\nvar util;\n\nfunction createErrorType(code, message, Base) {\n  if (!Base) {\n    Base = Error;\n  }\n\n  function getMessage(arg1, arg2, arg3) {\n    if (typeof message === 'string') {\n      return message;\n    } else {\n      return message(arg1, arg2, arg3);\n    }\n  }\n\n  var NodeError =\n  /*#__PURE__*/\n  function (_Base) {\n    _inherits(NodeError, _Base);\n\n    function NodeError(arg1, arg2, arg3) {\n      var _this;\n\n      _classCallCheck(this, NodeError);\n\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(NodeError).call(this, getMessage(arg1, arg2, arg3)));\n      _this.code = code;\n      return _this;\n    }\n\n    return NodeError;\n  }(Base);\n\n  codes[code] = NodeError;\n} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js\n\n\nfunction oneOf(expected, thing) {\n  if (Array.isArray(expected)) {\n    var len = expected.length;\n    expected = expected.map(function (i) {\n      return String(i);\n    });\n\n    if (len > 2) {\n      return \"one of \".concat(thing, \" \").concat(expected.slice(0, len - 1).join(', '), \", or \") + expected[len - 1];\n    } else if (len === 2) {\n      return \"one of \".concat(thing, \" \").concat(expected[0], \" or \").concat(expected[1]);\n    } else {\n      return \"of \".concat(thing, \" \").concat(expected[0]);\n    }\n  } else {\n    return \"of \".concat(thing, \" \").concat(String(expected));\n  }\n} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith\n\n\nfunction startsWith(str, search, pos) {\n  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;\n} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith\n\n\nfunction endsWith(str, search, this_len) {\n  if (this_len === undefined || this_len > str.length) {\n    this_len = str.length;\n  }\n\n  return str.substring(this_len - search.length, this_len) === search;\n} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes\n\n\nfunction includes(str, search, start) {\n  if (typeof start !== 'number') {\n    start = 0;\n  }\n\n  if (start + search.length > str.length) {\n    return false;\n  } else {\n    return str.indexOf(search, start) !== -1;\n  }\n}\n\ncreateErrorType('ERR_AMBIGUOUS_ARGUMENT', 'The \"%s\" argument is ambiguous. %s', TypeError);\ncreateErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {\n  if (assert === undefined) assert = __webpack_require__(/*! ../assert */ \"./node_modules/assert/build/assert.js\");\n  assert(typeof name === 'string', \"'name' must be a string\"); // determiner: 'must be' or 'must not be'\n\n  var determiner;\n\n  if (typeof expected === 'string' && startsWith(expected, 'not ')) {\n    determiner = 'must not be';\n    expected = expected.replace(/^not /, '');\n  } else {\n    determiner = 'must be';\n  }\n\n  var msg;\n\n  if (endsWith(name, ' argument')) {\n    // For cases like 'first argument'\n    msg = \"The \".concat(name, \" \").concat(determiner, \" \").concat(oneOf(expected, 'type'));\n  } else {\n    var type = includes(name, '.') ? 'property' : 'argument';\n    msg = \"The \\\"\".concat(name, \"\\\" \").concat(type, \" \").concat(determiner, \" \").concat(oneOf(expected, 'type'));\n  } // TODO(BridgeAR): Improve the output by showing `null` and similar.\n\n\n  msg += \". Received type \".concat(_typeof(actual));\n  return msg;\n}, TypeError);\ncreateErrorType('ERR_INVALID_ARG_VALUE', function (name, value) {\n  var reason = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'is invalid';\n  if (util === undefined) util = __webpack_require__(/*! util/ */ \"./node_modules/util/util.js\");\n  var inspected = util.inspect(value);\n\n  if (inspected.length > 128) {\n    inspected = \"\".concat(inspected.slice(0, 128), \"...\");\n  }\n\n  return \"The argument '\".concat(name, \"' \").concat(reason, \". Received \").concat(inspected);\n}, TypeError, RangeError);\ncreateErrorType('ERR_INVALID_RETURN_VALUE', function (input, name, value) {\n  var type;\n\n  if (value && value.constructor && value.constructor.name) {\n    type = \"instance of \".concat(value.constructor.name);\n  } else {\n    type = \"type \".concat(_typeof(value));\n  }\n\n  return \"Expected \".concat(input, \" to be returned from the \\\"\").concat(name, \"\\\"\") + \" function but got \".concat(type, \".\");\n}, TypeError);\ncreateErrorType('ERR_MISSING_ARGS', function () {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  if (assert === undefined) assert = __webpack_require__(/*! ../assert */ \"./node_modules/assert/build/assert.js\");\n  assert(args.length > 0, 'At least one arg needs to be specified');\n  var msg = 'The ';\n  var len = args.length;\n  args = args.map(function (a) {\n    return \"\\\"\".concat(a, \"\\\"\");\n  });\n\n  switch (len) {\n    case 1:\n      msg += \"\".concat(args[0], \" argument\");\n      break;\n\n    case 2:\n      msg += \"\".concat(args[0], \" and \").concat(args[1], \" arguments\");\n      break;\n\n    default:\n      msg += args.slice(0, len - 1).join(', ');\n      msg += \", and \".concat(args[len - 1], \" arguments\");\n      break;\n  }\n\n  return \"\".concat(msg, \" must be specified\");\n}, TypeError);\nmodule.exports.codes = codes;\n\n//# sourceURL=webpack://test-webpack-wasm/./node_modules/assert/build/internal/errors.js?");

/***/ }),

/***/ "./node_modules/assert/build/internal/util/comparisons.js":
/*!****************************************************************!*\
  !*** ./node_modules/assert/build/internal/util/comparisons.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Currently in sync with Node.js lib/internal/util/comparisons.js\n// https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9\n\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar regexFlagsSupported = /a/g.flags !== undefined;\n\nvar arrayFromSet = function arrayFromSet(set) {\n  var array = [];\n  set.forEach(function (value) {\n    return array.push(value);\n  });\n  return array;\n};\n\nvar arrayFromMap = function arrayFromMap(map) {\n  var array = [];\n  map.forEach(function (value, key) {\n    return array.push([key, value]);\n  });\n  return array;\n};\n\nvar objectIs = Object.is ? Object.is : __webpack_require__(/*! object-is */ \"./node_modules/object-is/index.js\");\nvar objectGetOwnPropertySymbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function () {\n  return [];\n};\nvar numberIsNaN = Number.isNaN ? Number.isNaN : __webpack_require__(/*! is-nan */ \"./node_modules/is-nan/index.js\");\n\nfunction uncurryThis(f) {\n  return f.call.bind(f);\n}\n\nvar hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);\nvar propertyIsEnumerable = uncurryThis(Object.prototype.propertyIsEnumerable);\nvar objectToString = uncurryThis(Object.prototype.toString);\n\nvar _require$types = (__webpack_require__(/*! util/ */ \"./node_modules/util/util.js\").types),\n    isAnyArrayBuffer = _require$types.isAnyArrayBuffer,\n    isArrayBufferView = _require$types.isArrayBufferView,\n    isDate = _require$types.isDate,\n    isMap = _require$types.isMap,\n    isRegExp = _require$types.isRegExp,\n    isSet = _require$types.isSet,\n    isNativeError = _require$types.isNativeError,\n    isBoxedPrimitive = _require$types.isBoxedPrimitive,\n    isNumberObject = _require$types.isNumberObject,\n    isStringObject = _require$types.isStringObject,\n    isBooleanObject = _require$types.isBooleanObject,\n    isBigIntObject = _require$types.isBigIntObject,\n    isSymbolObject = _require$types.isSymbolObject,\n    isFloat32Array = _require$types.isFloat32Array,\n    isFloat64Array = _require$types.isFloat64Array;\n\nfunction isNonIndex(key) {\n  if (key.length === 0 || key.length > 10) return true;\n\n  for (var i = 0; i < key.length; i++) {\n    var code = key.charCodeAt(i);\n    if (code < 48 || code > 57) return true;\n  } // The maximum size for an array is 2 ** 32 -1.\n\n\n  return key.length === 10 && key >= Math.pow(2, 32);\n}\n\nfunction getOwnNonIndexProperties(value) {\n  return Object.keys(value).filter(isNonIndex).concat(objectGetOwnPropertySymbols(value).filter(Object.prototype.propertyIsEnumerable.bind(value)));\n} // Taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js\n// original notice:\n\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n\n\nfunction compare(a, b) {\n  if (a === b) {\n    return 0;\n  }\n\n  var x = a.length;\n  var y = b.length;\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i];\n      y = b[i];\n      break;\n    }\n  }\n\n  if (x < y) {\n    return -1;\n  }\n\n  if (y < x) {\n    return 1;\n  }\n\n  return 0;\n}\n\nvar ONLY_ENUMERABLE = undefined;\nvar kStrict = true;\nvar kLoose = false;\nvar kNoIterator = 0;\nvar kIsArray = 1;\nvar kIsSet = 2;\nvar kIsMap = 3; // Check if they have the same source and flags\n\nfunction areSimilarRegExps(a, b) {\n  return regexFlagsSupported ? a.source === b.source && a.flags === b.flags : RegExp.prototype.toString.call(a) === RegExp.prototype.toString.call(b);\n}\n\nfunction areSimilarFloatArrays(a, b) {\n  if (a.byteLength !== b.byteLength) {\n    return false;\n  }\n\n  for (var offset = 0; offset < a.byteLength; offset++) {\n    if (a[offset] !== b[offset]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction areSimilarTypedArrays(a, b) {\n  if (a.byteLength !== b.byteLength) {\n    return false;\n  }\n\n  return compare(new Uint8Array(a.buffer, a.byteOffset, a.byteLength), new Uint8Array(b.buffer, b.byteOffset, b.byteLength)) === 0;\n}\n\nfunction areEqualArrayBuffers(buf1, buf2) {\n  return buf1.byteLength === buf2.byteLength && compare(new Uint8Array(buf1), new Uint8Array(buf2)) === 0;\n}\n\nfunction isEqualBoxedPrimitive(val1, val2) {\n  if (isNumberObject(val1)) {\n    return isNumberObject(val2) && objectIs(Number.prototype.valueOf.call(val1), Number.prototype.valueOf.call(val2));\n  }\n\n  if (isStringObject(val1)) {\n    return isStringObject(val2) && String.prototype.valueOf.call(val1) === String.prototype.valueOf.call(val2);\n  }\n\n  if (isBooleanObject(val1)) {\n    return isBooleanObject(val2) && Boolean.prototype.valueOf.call(val1) === Boolean.prototype.valueOf.call(val2);\n  }\n\n  if (isBigIntObject(val1)) {\n    return isBigIntObject(val2) && BigInt.prototype.valueOf.call(val1) === BigInt.prototype.valueOf.call(val2);\n  }\n\n  return isSymbolObject(val2) && Symbol.prototype.valueOf.call(val1) === Symbol.prototype.valueOf.call(val2);\n} // Notes: Type tags are historical [[Class]] properties that can be set by\n// FunctionTemplate::SetClassName() in C++ or Symbol.toStringTag in JS\n// and retrieved using Object.prototype.toString.call(obj) in JS\n// See https://tc39.github.io/ecma262/#sec-object.prototype.tostring\n// for a list of tags pre-defined in the spec.\n// There are some unspecified tags in the wild too (e.g. typed array tags).\n// Since tags can be altered, they only serve fast failures\n//\n// Typed arrays and buffers are checked by comparing the content in their\n// underlying ArrayBuffer. This optimization requires that it's\n// reasonable to interpret their underlying memory in the same way,\n// which is checked by comparing their type tags.\n// (e.g. a Uint8Array and a Uint16Array with the same memory content\n// could still be different because they will be interpreted differently).\n//\n// For strict comparison, objects should have\n// a) The same built-in type tags\n// b) The same prototypes.\n\n\nfunction innerDeepEqual(val1, val2, strict, memos) {\n  // All identical values are equivalent, as determined by ===.\n  if (val1 === val2) {\n    if (val1 !== 0) return true;\n    return strict ? objectIs(val1, val2) : true;\n  } // Check more closely if val1 and val2 are equal.\n\n\n  if (strict) {\n    if (_typeof(val1) !== 'object') {\n      return typeof val1 === 'number' && numberIsNaN(val1) && numberIsNaN(val2);\n    }\n\n    if (_typeof(val2) !== 'object' || val1 === null || val2 === null) {\n      return false;\n    }\n\n    if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) {\n      return false;\n    }\n  } else {\n    if (val1 === null || _typeof(val1) !== 'object') {\n      if (val2 === null || _typeof(val2) !== 'object') {\n        // eslint-disable-next-line eqeqeq\n        return val1 == val2;\n      }\n\n      return false;\n    }\n\n    if (val2 === null || _typeof(val2) !== 'object') {\n      return false;\n    }\n  }\n\n  var val1Tag = objectToString(val1);\n  var val2Tag = objectToString(val2);\n\n  if (val1Tag !== val2Tag) {\n    return false;\n  }\n\n  if (Array.isArray(val1)) {\n    // Check for sparse arrays and general fast path\n    if (val1.length !== val2.length) {\n      return false;\n    }\n\n    var keys1 = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);\n    var keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);\n\n    if (keys1.length !== keys2.length) {\n      return false;\n    }\n\n    return keyCheck(val1, val2, strict, memos, kIsArray, keys1);\n  } // [browserify] This triggers on certain types in IE (Map/Set) so we don't\n  // wan't to early return out of the rest of the checks. However we can check\n  // if the second value is one of these values and the first isn't.\n\n\n  if (val1Tag === '[object Object]') {\n    // return keyCheck(val1, val2, strict, memos, kNoIterator);\n    if (!isMap(val1) && isMap(val2) || !isSet(val1) && isSet(val2)) {\n      return false;\n    }\n  }\n\n  if (isDate(val1)) {\n    if (!isDate(val2) || Date.prototype.getTime.call(val1) !== Date.prototype.getTime.call(val2)) {\n      return false;\n    }\n  } else if (isRegExp(val1)) {\n    if (!isRegExp(val2) || !areSimilarRegExps(val1, val2)) {\n      return false;\n    }\n  } else if (isNativeError(val1) || val1 instanceof Error) {\n    // Do not compare the stack as it might differ even though the error itself\n    // is otherwise identical.\n    if (val1.message !== val2.message || val1.name !== val2.name) {\n      return false;\n    }\n  } else if (isArrayBufferView(val1)) {\n    if (!strict && (isFloat32Array(val1) || isFloat64Array(val1))) {\n      if (!areSimilarFloatArrays(val1, val2)) {\n        return false;\n      }\n    } else if (!areSimilarTypedArrays(val1, val2)) {\n      return false;\n    } // Buffer.compare returns true, so val1.length === val2.length. If they both\n    // only contain numeric keys, we don't need to exam further than checking\n    // the symbols.\n\n\n    var _keys = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);\n\n    var _keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);\n\n    if (_keys.length !== _keys2.length) {\n      return false;\n    }\n\n    return keyCheck(val1, val2, strict, memos, kNoIterator, _keys);\n  } else if (isSet(val1)) {\n    if (!isSet(val2) || val1.size !== val2.size) {\n      return false;\n    }\n\n    return keyCheck(val1, val2, strict, memos, kIsSet);\n  } else if (isMap(val1)) {\n    if (!isMap(val2) || val1.size !== val2.size) {\n      return false;\n    }\n\n    return keyCheck(val1, val2, strict, memos, kIsMap);\n  } else if (isAnyArrayBuffer(val1)) {\n    if (!areEqualArrayBuffers(val1, val2)) {\n      return false;\n    }\n  } else if (isBoxedPrimitive(val1) && !isEqualBoxedPrimitive(val1, val2)) {\n    return false;\n  }\n\n  return keyCheck(val1, val2, strict, memos, kNoIterator);\n}\n\nfunction getEnumerables(val, keys) {\n  return keys.filter(function (k) {\n    return propertyIsEnumerable(val, k);\n  });\n}\n\nfunction keyCheck(val1, val2, strict, memos, iterationType, aKeys) {\n  // For all remaining Object pairs, including Array, objects and Maps,\n  // equivalence is determined by having:\n  // a) The same number of owned enumerable properties\n  // b) The same set of keys/indexes (although not necessarily the same order)\n  // c) Equivalent values for every corresponding key/index\n  // d) For Sets and Maps, equal contents\n  // Note: this accounts for both named and indexed properties on Arrays.\n  if (arguments.length === 5) {\n    aKeys = Object.keys(val1);\n    var bKeys = Object.keys(val2); // The pair must have the same number of owned properties.\n\n    if (aKeys.length !== bKeys.length) {\n      return false;\n    }\n  } // Cheap key test\n\n\n  var i = 0;\n\n  for (; i < aKeys.length; i++) {\n    if (!hasOwnProperty(val2, aKeys[i])) {\n      return false;\n    }\n  }\n\n  if (strict && arguments.length === 5) {\n    var symbolKeysA = objectGetOwnPropertySymbols(val1);\n\n    if (symbolKeysA.length !== 0) {\n      var count = 0;\n\n      for (i = 0; i < symbolKeysA.length; i++) {\n        var key = symbolKeysA[i];\n\n        if (propertyIsEnumerable(val1, key)) {\n          if (!propertyIsEnumerable(val2, key)) {\n            return false;\n          }\n\n          aKeys.push(key);\n          count++;\n        } else if (propertyIsEnumerable(val2, key)) {\n          return false;\n        }\n      }\n\n      var symbolKeysB = objectGetOwnPropertySymbols(val2);\n\n      if (symbolKeysA.length !== symbolKeysB.length && getEnumerables(val2, symbolKeysB).length !== count) {\n        return false;\n      }\n    } else {\n      var _symbolKeysB = objectGetOwnPropertySymbols(val2);\n\n      if (_symbolKeysB.length !== 0 && getEnumerables(val2, _symbolKeysB).length !== 0) {\n        return false;\n      }\n    }\n  }\n\n  if (aKeys.length === 0 && (iterationType === kNoIterator || iterationType === kIsArray && val1.length === 0 || val1.size === 0)) {\n    return true;\n  } // Use memos to handle cycles.\n\n\n  if (memos === undefined) {\n    memos = {\n      val1: new Map(),\n      val2: new Map(),\n      position: 0\n    };\n  } else {\n    // We prevent up to two map.has(x) calls by directly retrieving the value\n    // and checking for undefined. The map can only contain numbers, so it is\n    // safe to check for undefined only.\n    var val2MemoA = memos.val1.get(val1);\n\n    if (val2MemoA !== undefined) {\n      var val2MemoB = memos.val2.get(val2);\n\n      if (val2MemoB !== undefined) {\n        return val2MemoA === val2MemoB;\n      }\n    }\n\n    memos.position++;\n  }\n\n  memos.val1.set(val1, memos.position);\n  memos.val2.set(val2, memos.position);\n  var areEq = objEquiv(val1, val2, strict, aKeys, memos, iterationType);\n  memos.val1.delete(val1);\n  memos.val2.delete(val2);\n  return areEq;\n}\n\nfunction setHasEqualElement(set, val1, strict, memo) {\n  // Go looking.\n  var setValues = arrayFromSet(set);\n\n  for (var i = 0; i < setValues.length; i++) {\n    var val2 = setValues[i];\n\n    if (innerDeepEqual(val1, val2, strict, memo)) {\n      // Remove the matching element to make sure we do not check that again.\n      set.delete(val2);\n      return true;\n    }\n  }\n\n  return false;\n} // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#Loose_equality_using\n// Sadly it is not possible to detect corresponding values properly in case the\n// type is a string, number, bigint or boolean. The reason is that those values\n// can match lots of different string values (e.g., 1n == '+00001').\n\n\nfunction findLooseMatchingPrimitives(prim) {\n  switch (_typeof(prim)) {\n    case 'undefined':\n      return null;\n\n    case 'object':\n      // Only pass in null as object!\n      return undefined;\n\n    case 'symbol':\n      return false;\n\n    case 'string':\n      prim = +prim;\n    // Loose equal entries exist only if the string is possible to convert to\n    // a regular number and not NaN.\n    // Fall through\n\n    case 'number':\n      if (numberIsNaN(prim)) {\n        return false;\n      }\n\n  }\n\n  return true;\n}\n\nfunction setMightHaveLoosePrim(a, b, prim) {\n  var altValue = findLooseMatchingPrimitives(prim);\n  if (altValue != null) return altValue;\n  return b.has(altValue) && !a.has(altValue);\n}\n\nfunction mapMightHaveLoosePrim(a, b, prim, item, memo) {\n  var altValue = findLooseMatchingPrimitives(prim);\n\n  if (altValue != null) {\n    return altValue;\n  }\n\n  var curB = b.get(altValue);\n\n  if (curB === undefined && !b.has(altValue) || !innerDeepEqual(item, curB, false, memo)) {\n    return false;\n  }\n\n  return !a.has(altValue) && innerDeepEqual(item, curB, false, memo);\n}\n\nfunction setEquiv(a, b, strict, memo) {\n  // This is a lazily initiated Set of entries which have to be compared\n  // pairwise.\n  var set = null;\n  var aValues = arrayFromSet(a);\n\n  for (var i = 0; i < aValues.length; i++) {\n    var val = aValues[i]; // Note: Checking for the objects first improves the performance for object\n    // heavy sets but it is a minor slow down for primitives. As they are fast\n    // to check this improves the worst case scenario instead.\n\n    if (_typeof(val) === 'object' && val !== null) {\n      if (set === null) {\n        set = new Set();\n      } // If the specified value doesn't exist in the second set its an not null\n      // object (or non strict only: a not matching primitive) we'll need to go\n      // hunting for something thats deep-(strict-)equal to it. To make this\n      // O(n log n) complexity we have to copy these values in a new set first.\n\n\n      set.add(val);\n    } else if (!b.has(val)) {\n      if (strict) return false; // Fast path to detect missing string, symbol, undefined and null values.\n\n      if (!setMightHaveLoosePrim(a, b, val)) {\n        return false;\n      }\n\n      if (set === null) {\n        set = new Set();\n      }\n\n      set.add(val);\n    }\n  }\n\n  if (set !== null) {\n    var bValues = arrayFromSet(b);\n\n    for (var _i = 0; _i < bValues.length; _i++) {\n      var _val = bValues[_i]; // We have to check if a primitive value is already\n      // matching and only if it's not, go hunting for it.\n\n      if (_typeof(_val) === 'object' && _val !== null) {\n        if (!setHasEqualElement(set, _val, strict, memo)) return false;\n      } else if (!strict && !a.has(_val) && !setHasEqualElement(set, _val, strict, memo)) {\n        return false;\n      }\n    }\n\n    return set.size === 0;\n  }\n\n  return true;\n}\n\nfunction mapHasEqualEntry(set, map, key1, item1, strict, memo) {\n  // To be able to handle cases like:\n  //   Map([[{}, 'a'], [{}, 'b']]) vs Map([[{}, 'b'], [{}, 'a']])\n  // ... we need to consider *all* matching keys, not just the first we find.\n  var setValues = arrayFromSet(set);\n\n  for (var i = 0; i < setValues.length; i++) {\n    var key2 = setValues[i];\n\n    if (innerDeepEqual(key1, key2, strict, memo) && innerDeepEqual(item1, map.get(key2), strict, memo)) {\n      set.delete(key2);\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction mapEquiv(a, b, strict, memo) {\n  var set = null;\n  var aEntries = arrayFromMap(a);\n\n  for (var i = 0; i < aEntries.length; i++) {\n    var _aEntries$i = _slicedToArray(aEntries[i], 2),\n        key = _aEntries$i[0],\n        item1 = _aEntries$i[1];\n\n    if (_typeof(key) === 'object' && key !== null) {\n      if (set === null) {\n        set = new Set();\n      }\n\n      set.add(key);\n    } else {\n      // By directly retrieving the value we prevent another b.has(key) check in\n      // almost all possible cases.\n      var item2 = b.get(key);\n\n      if (item2 === undefined && !b.has(key) || !innerDeepEqual(item1, item2, strict, memo)) {\n        if (strict) return false; // Fast path to detect missing string, symbol, undefined and null\n        // keys.\n\n        if (!mapMightHaveLoosePrim(a, b, key, item1, memo)) return false;\n\n        if (set === null) {\n          set = new Set();\n        }\n\n        set.add(key);\n      }\n    }\n  }\n\n  if (set !== null) {\n    var bEntries = arrayFromMap(b);\n\n    for (var _i2 = 0; _i2 < bEntries.length; _i2++) {\n      var _bEntries$_i = _slicedToArray(bEntries[_i2], 2),\n          key = _bEntries$_i[0],\n          item = _bEntries$_i[1];\n\n      if (_typeof(key) === 'object' && key !== null) {\n        if (!mapHasEqualEntry(set, a, key, item, strict, memo)) return false;\n      } else if (!strict && (!a.has(key) || !innerDeepEqual(a.get(key), item, false, memo)) && !mapHasEqualEntry(set, a, key, item, false, memo)) {\n        return false;\n      }\n    }\n\n    return set.size === 0;\n  }\n\n  return true;\n}\n\nfunction objEquiv(a, b, strict, keys, memos, iterationType) {\n  // Sets and maps don't have their entries accessible via normal object\n  // properties.\n  var i = 0;\n\n  if (iterationType === kIsSet) {\n    if (!setEquiv(a, b, strict, memos)) {\n      return false;\n    }\n  } else if (iterationType === kIsMap) {\n    if (!mapEquiv(a, b, strict, memos)) {\n      return false;\n    }\n  } else if (iterationType === kIsArray) {\n    for (; i < a.length; i++) {\n      if (hasOwnProperty(a, i)) {\n        if (!hasOwnProperty(b, i) || !innerDeepEqual(a[i], b[i], strict, memos)) {\n          return false;\n        }\n      } else if (hasOwnProperty(b, i)) {\n        return false;\n      } else {\n        // Array is sparse.\n        var keysA = Object.keys(a);\n\n        for (; i < keysA.length; i++) {\n          var key = keysA[i];\n\n          if (!hasOwnProperty(b, key) || !innerDeepEqual(a[key], b[key], strict, memos)) {\n            return false;\n          }\n        }\n\n        if (keysA.length !== Object.keys(b).length) {\n          return false;\n        }\n\n        return true;\n      }\n    }\n  } // The pair must have equivalent values for every corresponding key.\n  // Possibly expensive deep test:\n\n\n  for (i = 0; i < keys.length; i++) {\n    var _key = keys[i];\n\n    if (!innerDeepEqual(a[_key], b[_key], strict, memos)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction isDeepEqual(val1, val2) {\n  return innerDeepEqual(val1, val2, kLoose);\n}\n\nfunction isDeepStrictEqual(val1, val2) {\n  return innerDeepEqual(val1, val2, kStrict);\n}\n\nmodule.exports = {\n  isDeepEqual: isDeepEqual,\n  isDeepStrictEqual: isDeepStrictEqual\n};\n\n//# sourceURL=webpack://test-webpack-wasm/./node_modules/assert/build/internal/util/comparisons.js?");

/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n\n\n//# sourceURL=webpack://test-webpack-wasm/./node_modules/base64-js/index.js?");

/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var console = __webpack_require__(/*! ./node_modules/console-browserify/index.js */ \"./node_modules/console-browserify/index.js\");\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nconst base64 = __webpack_require__(/*! base64-js */ \"./node_modules/base64-js/index.js\")\nconst ieee754 = __webpack_require__(/*! ieee754 */ \"./node_modules/ieee754/index.js\")\nconst customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nconst K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    const arr = new Uint8Array(1)\n    const proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  const buf = new Uint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, SharedArrayBuffer) ||\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  const valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  const b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\nObject.setPrototypeOf(Buffer, Uint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  const length = byteLength(string, encoding) | 0\n  let buf = createBuffer(length)\n\n  const actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  const length = array.length < 0 ? 0 : checked(array.length) | 0\n  const buf = createBuffer(length)\n  for (let i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayView (arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    const copy = new Uint8Array(arrayView)\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n  }\n  return fromArrayLike(arrayView)\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  let buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    const len = checked(obj.length) | 0\n    const buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  let x = a.length\n  let y = b.length\n\n  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  let i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  const buffer = Buffer.allocUnsafe(length)\n  let pos = 0\n  for (i = 0; i < list.length; ++i) {\n    let buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)\n        buf.copy(buffer, pos)\n      } else {\n        Uint8Array.prototype.set.call(\n          buffer,\n          buf,\n          pos\n        )\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    } else {\n      buf.copy(buffer, pos)\n    }\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  const len = string.length\n  const mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  let loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  const i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  const len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (let i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  const len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (let i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  const len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (let i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  const length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  let str = ''\n  const max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  let x = thisEnd - thisStart\n  let y = end - start\n  const len = Math.min(x, y)\n\n  const thisCopy = this.slice(thisStart, thisEnd)\n  const targetCopy = target.slice(start, end)\n\n  for (let i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  let indexSize = 1\n  let arrLength = arr.length\n  let valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  let i\n  if (dir) {\n    let foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      let found = true\n      for (let j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  const remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  const strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  let i\n  for (i = 0; i < length; ++i) {\n    const parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  const remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  const res = []\n\n  let i = start\n  while (i < end) {\n    const firstByte = buf[i]\n    let codePoint = null\n    let bytesPerSequence = (firstByte > 0xEF)\n      ? 4\n      : (firstByte > 0xDF)\n          ? 3\n          : (firstByte > 0xBF)\n              ? 2\n              : 1\n\n    if (i + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  const len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  let res = ''\n  let i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  const len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  let out = ''\n  for (let i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  const bytes = buf.slice(start, end)\n  let res = ''\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n  for (let i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  const len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  const newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUintLE =\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUintBE =\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  let val = this[offset + --byteLength]\n  let mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUint8 =\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUint16LE =\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUint16BE =\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUint32LE =\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUint32BE =\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const lo = first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24\n\n  const hi = this[++offset] +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24\n\n  return BigInt(lo) + (BigInt(hi) << BigInt(32))\n})\n\nBuffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const hi = first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  const lo = this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last\n\n  return (BigInt(hi) << BigInt(32)) + BigInt(lo)\n})\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let i = byteLength\n  let mul = 1\n  let val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = this[offset + 4] +\n    this[offset + 5] * 2 ** 8 +\n    this[offset + 6] * 2 ** 16 +\n    (last << 24) // Overflow\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24)\n})\n\nBuffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last)\n})\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUintLE =\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let mul = 1\n  let i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUintBE =\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUint8 =\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUint16LE =\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint16BE =\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint32LE =\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUint32BE =\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction wrtBigUInt64LE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  return offset\n}\n\nfunction wrtBigUInt64BE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset + 7] = lo\n  lo = lo >> 8\n  buf[offset + 6] = lo\n  lo = lo >> 8\n  buf[offset + 5] = lo\n  lo = lo >> 8\n  buf[offset + 4] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset + 3] = hi\n  hi = hi >> 8\n  buf[offset + 2] = hi\n  hi = hi >> 8\n  buf[offset + 1] = hi\n  hi = hi >> 8\n  buf[offset] = hi\n  return offset + 8\n}\n\nBuffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = 0\n  let mul = 1\n  let sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  let sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nBuffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  const len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      const code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  let i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    const bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    const len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// CUSTOM ERRORS\n// =============\n\n// Simplified versions from Node, changed for Buffer-only usage\nconst errors = {}\nfunction E (sym, getMessage, Base) {\n  errors[sym] = class NodeError extends Base {\n    constructor () {\n      super()\n\n      Object.defineProperty(this, 'message', {\n        value: getMessage.apply(this, arguments),\n        writable: true,\n        configurable: true\n      })\n\n      // Add the error code to the name to include it in the stack trace.\n      this.name = `${this.name} [${sym}]`\n      // Access the stack to generate the error message including the error code\n      // from the name.\n      this.stack // eslint-disable-line no-unused-expressions\n      // Reset the name to the actual name.\n      delete this.name\n    }\n\n    get code () {\n      return sym\n    }\n\n    set code (value) {\n      Object.defineProperty(this, 'code', {\n        configurable: true,\n        enumerable: true,\n        value,\n        writable: true\n      })\n    }\n\n    toString () {\n      return `${this.name} [${sym}]: ${this.message}`\n    }\n  }\n}\n\nE('ERR_BUFFER_OUT_OF_BOUNDS',\n  function (name) {\n    if (name) {\n      return `${name} is outside of buffer bounds`\n    }\n\n    return 'Attempt to access memory outside buffer bounds'\n  }, RangeError)\nE('ERR_INVALID_ARG_TYPE',\n  function (name, actual) {\n    return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`\n  }, TypeError)\nE('ERR_OUT_OF_RANGE',\n  function (str, range, input) {\n    let msg = `The value of \"${str}\" is out of range.`\n    let received = input\n    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n      received = addNumericalSeparator(String(input))\n    } else if (typeof input === 'bigint') {\n      received = String(input)\n      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n        received = addNumericalSeparator(received)\n      }\n      received += 'n'\n    }\n    msg += ` It must be ${range}. Received ${received}`\n    return msg\n  }, RangeError)\n\nfunction addNumericalSeparator (val) {\n  let res = ''\n  let i = val.length\n  const start = val[0] === '-' ? 1 : 0\n  for (; i >= start + 4; i -= 3) {\n    res = `_${val.slice(i - 3, i)}${res}`\n  }\n  return `${val.slice(0, i)}${res}`\n}\n\n// CHECK FUNCTIONS\n// ===============\n\nfunction checkBounds (buf, offset, byteLength) {\n  validateNumber(offset, 'offset')\n  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {\n    boundsError(offset, buf.length - (byteLength + 1))\n  }\n}\n\nfunction checkIntBI (value, min, max, buf, offset, byteLength) {\n  if (value > max || value < min) {\n    const n = typeof min === 'bigint' ? 'n' : ''\n    let range\n    if (byteLength > 3) {\n      if (min === 0 || min === BigInt(0)) {\n        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`\n      } else {\n        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +\n                `${(byteLength + 1) * 8 - 1}${n}`\n      }\n    } else {\n      range = `>= ${min}${n} and <= ${max}${n}`\n    }\n    throw new errors.ERR_OUT_OF_RANGE('value', range, value)\n  }\n  checkBounds(buf, offset, byteLength)\n}\n\nfunction validateNumber (value, name) {\n  if (typeof value !== 'number') {\n    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)\n  }\n}\n\nfunction boundsError (value, length, type) {\n  if (Math.floor(value) !== value) {\n    validateNumber(value, type)\n    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)\n  }\n\n  if (length < 0) {\n    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()\n  }\n\n  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',\n                                    `>= ${type ? 1 : 0} and <= ${length}`,\n                                    value)\n}\n\n// HELPER FUNCTIONS\n// ================\n\nconst INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  let codePoint\n  const length = string.length\n  let leadSurrogate = null\n  const bytes = []\n\n  for (let i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  let c, hi, lo\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  let i\n  for (i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nconst hexSliceLookupTable = (function () {\n  const alphabet = '0123456789abcdef'\n  const table = new Array(256)\n  for (let i = 0; i < 16; ++i) {\n    const i16 = i * 16\n    for (let j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n\n// Return not function with Error if BigInt not supported\nfunction defineBigIntMethod (fn) {\n  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn\n}\n\nfunction BufferBigIntNotDefined () {\n  throw new Error('BigInt not supported')\n}\n\n\n//# sourceURL=webpack://test-webpack-wasm/./node_modules/buffer/index.js?");

/***/ }),

/***/ "./node_modules/call-bind/callBound.js":
/*!*********************************************!*\
  !*** ./node_modules/call-bind/callBound.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar GetIntrinsic = __webpack_require__(/*! get-intrinsic */ \"./node_modules/get-intrinsic/index.js\");\n\nvar callBind = __webpack_require__(/*! ./ */ \"./node_modules/call-bind/index.js\");\n\nvar $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));\n\nmodule.exports = function callBoundIntrinsic(name, allowMissing) {\n\tvar intrinsic = GetIntrinsic(name, !!allowMissing);\n\tif (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {\n\t\treturn callBind(intrinsic);\n\t}\n\treturn intrinsic;\n};\n\n\n//# sourceURL=webpack://test-webpack-wasm/./node_modules/call-bind/callBound.js?");

/***/ }),

/***/ "./node_modules/call-bind/index.js":
/*!*****************************************!*\
  !*** ./node_modules/call-bind/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar bind = __webpack_require__(/*! function-bind */ \"./node_modules/function-bind/index.js\");\nvar GetIntrinsic = __webpack_require__(/*! get-intrinsic */ \"./node_modules/get-intrinsic/index.js\");\n\nvar $apply = GetIntrinsic('%Function.prototype.apply%');\nvar $call = GetIntrinsic('%Function.prototype.call%');\nvar $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);\n\nvar $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);\nvar $defineProperty = GetIntrinsic('%Object.defineProperty%', true);\nvar $max = GetIntrinsic('%Math.max%');\n\nif ($defineProperty) {\n\ttry {\n\t\t$defineProperty({}, 'a', { value: 1 });\n\t} catch (e) {\n\t\t// IE 8 has a broken defineProperty\n\t\t$defineProperty = null;\n\t}\n}\n\nmodule.exports = function callBind(originalFunction) {\n\tvar func = $reflectApply(bind, $call, arguments);\n\tif ($gOPD && $defineProperty) {\n\t\tvar desc = $gOPD(func, 'length');\n\t\tif (desc.configurable) {\n\t\t\t// original length, plus the receiver, minus any additional arguments (after the receiver)\n\t\t\t$defineProperty(\n\t\t\t\tfunc,\n\t\t\t\t'length',\n\t\t\t\t{ value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }\n\t\t\t);\n\t\t}\n\t}\n\treturn func;\n};\n\nvar applyBind = function applyBind() {\n\treturn $reflectApply(bind, $apply, arguments);\n};\n\nif ($defineProperty) {\n\t$defineProperty(module.exports, 'apply', { value: applyBind });\n} else {\n\tmodule.exports.apply = applyBind;\n}\n\n\n//# sourceURL=webpack://test-webpack-wasm/./node_modules/call-bind/index.js?");

/***/ }),

/***/ "./node_modules/console-browserify/index.js":
/*!**************************************************!*\
  !*** ./node_modules/console-browserify/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*global window, global*/\nvar util = __webpack_require__(/*! util */ \"./node_modules/util/util.js\")\nvar assert = __webpack_require__(/*! assert */ \"./node_modules/assert/build/assert.js\")\nfunction now() { return new Date().getTime() }\n\nvar slice = Array.prototype.slice\nvar console\nvar times = {}\n\nif (typeof __webpack_require__.g !== \"undefined\" && __webpack_require__.g.console) {\n    console = __webpack_require__.g.console\n} else if (typeof window !== \"undefined\" && window.console) {\n    console = window.console\n} else {\n    console = {}\n}\n\nvar functions = [\n    [log, \"log\"],\n    [info, \"info\"],\n    [warn, \"warn\"],\n    [error, \"error\"],\n    [time, \"time\"],\n    [timeEnd, \"timeEnd\"],\n    [trace, \"trace\"],\n    [dir, \"dir\"],\n    [consoleAssert, \"assert\"]\n]\n\nfor (var i = 0; i < functions.length; i++) {\n    var tuple = functions[i]\n    var f = tuple[0]\n    var name = tuple[1]\n\n    if (!console[name]) {\n        console[name] = f\n    }\n}\n\nmodule.exports = console\n\nfunction log() {}\n\nfunction info() {\n    console.log.apply(console, arguments)\n}\n\nfunction warn() {\n    console.log.apply(console, arguments)\n}\n\nfunction error() {\n    console.warn.apply(console, arguments)\n}\n\nfunction time(label) {\n    times[label] = now()\n}\n\nfunction timeEnd(label) {\n    var time = times[label]\n    if (!time) {\n        throw new Error(\"No such label: \" + label)\n    }\n\n    delete times[label]\n    var duration = now() - time\n    console.log(label + \": \" + duration + \"ms\")\n}\n\nfunction trace() {\n    var err = new Error()\n    err.name = \"Trace\"\n    err.message = util.format.apply(null, arguments)\n    console.error(err.stack)\n}\n\nfunction dir(object) {\n    console.log(util.inspect(object) + \"\\n\")\n}\n\nfunction consoleAssert(expression) {\n    if (!expression) {\n        var arr = slice.call(arguments, 1)\n        assert.ok(false, util.format.apply(null, arr))\n    }\n}\n\n\n//# sourceURL=webpack://test-webpack-wasm/./node_modules/console-browserify/index.js?");

/***/ }),

/***/ "./node_modules/define-properties/index.js":
/*!*************************************************!*\
  !*** ./node_modules/define-properties/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar keys = __webpack_require__(/*! object-keys */ \"./node_modules/object-keys/index.js\");\nvar hasSymbols = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol';\n\nvar toStr = Object.prototype.toString;\nvar concat = Array.prototype.concat;\nvar origDefineProperty = Object.defineProperty;\n\nvar isFunction = function (fn) {\n\treturn typeof fn === 'function' && toStr.call(fn) === '[object Function]';\n};\n\nvar arePropertyDescriptorsSupported = function () {\n\tvar obj = {};\n\ttry {\n\t\torigDefineProperty(obj, 'x', { enumerable: false, value: obj });\n\t\t// eslint-disable-next-line no-unused-vars, no-restricted-syntax\n\t\tfor (var _ in obj) { // jscs:ignore disallowUnusedVariables\n\t\t\treturn false;\n\t\t}\n\t\treturn obj.x === obj;\n\t} catch (e) { /* this is IE 8. */\n\t\treturn false;\n\t}\n};\nvar supportsDescriptors = origDefineProperty && arePropertyDescriptorsSupported();\n\nvar defineProperty = function (object, name, value, predicate) {\n\tif (name in object && (!isFunction(predicate) || !predicate())) {\n\t\treturn;\n\t}\n\tif (supportsDescriptors) {\n\t\torigDefineProperty(object, name, {\n\t\t\tconfigurable: true,\n\t\t\tenumerable: false,\n\t\t\tvalue: value,\n\t\t\twritable: true\n\t\t});\n\t} else {\n\t\tobject[name] = value;\n\t}\n};\n\nvar defineProperties = function (object, map) {\n\tvar predicates = arguments.length > 2 ? arguments[2] : {};\n\tvar props = keys(map);\n\tif (hasSymbols) {\n\t\tprops = concat.call(props, Object.getOwnPropertySymbols(map));\n\t}\n\tfor (var i = 0; i < props.length; i += 1) {\n\t\tdefineProperty(object, props[i], map[props[i]], predicates[props[i]]);\n\t}\n};\n\ndefineProperties.supportsDescriptors = !!supportsDescriptors;\n\nmodule.exports = defineProperties;\n\n\n//# sourceURL=webpack://test-webpack-wasm/./node_modules/define-properties/index.js?");

/***/ }),

/***/ "./node_modules/es6-object-assign/index.js":
/*!*************************************************!*\
  !*** ./node_modules/es6-object-assign/index.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";
eval("/**\n * Code refactored from Mozilla Developer Network:\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n */\n\n\n\nfunction assign(target, firstSource) {\n  if (target === undefined || target === null) {\n    throw new TypeError('Cannot convert first argument to object');\n  }\n\n  var to = Object(target);\n  for (var i = 1; i < arguments.length; i++) {\n    var nextSource = arguments[i];\n    if (nextSource === undefined || nextSource === null) {\n      continue;\n    }\n\n    var keysArray = Object.keys(Object(nextSource));\n    for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {\n      var nextKey = keysArray[nextIndex];\n      var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);\n      if (desc !== undefined && desc.enumerable) {\n        to[nextKey] = nextSource[nextKey];\n      }\n    }\n  }\n  return to;\n}\n\nfunction polyfill() {\n  if (!Object.assign) {\n    Object.defineProperty(Object, 'assign', {\n      enumerable: false,\n      configurable: true,\n      writable: true,\n      value: assign\n    });\n  }\n}\n\nmodule.exports = {\n  assign: assign,\n  polyfill: polyfill\n};\n\n\n//# sourceURL=webpack://test-webpack-wasm/./node_modules/es6-object-assign/index.js?");

/***/ }),

/***/ "./node_modules/foreach/index.js":
/*!***************************************!*\
  !*** ./node_modules/foreach/index.js ***!
  \***************************************/
/***/ ((module) => {

eval("\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar toString = Object.prototype.toString;\n\nmodule.exports = function forEach (obj, fn, ctx) {\n    if (toString.call(fn) !== '[object Function]') {\n        throw new TypeError('iterator must be a function');\n    }\n    var l = obj.length;\n    if (l === +l) {\n        for (var i = 0; i < l; i++) {\n            fn.call(ctx, obj[i], i, obj);\n        }\n    } else {\n        for (var k in obj) {\n            if (hasOwn.call(obj, k)) {\n                fn.call(ctx, obj[k], k, obj);\n            }\n        }\n    }\n};\n\n\n\n//# sourceURL=webpack://test-webpack-wasm/./node_modules/foreach/index.js?");

/***/ }),

/***/ "./node_modules/function-bind/implementation.js":
/*!******************************************************!*\
  !*** ./node_modules/function-bind/implementation.js ***!
  \******************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* eslint no-invalid-this: 1 */\n\nvar ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';\nvar slice = Array.prototype.slice;\nvar toStr = Object.prototype.toString;\nvar funcType = '[object Function]';\n\nmodule.exports = function bind(that) {\n    var target = this;\n    if (typeof target !== 'function' || toStr.call(target) !== funcType) {\n        throw new TypeError(ERROR_MESSAGE + target);\n    }\n    var args = slice.call(arguments, 1);\n\n    var bound;\n    var binder = function () {\n        if (this instanceof bound) {\n            var result = target.apply(\n                this,\n                args.concat(slice.call(arguments))\n            );\n            if (Object(result) === result) {\n                return result;\n            }\n            return this;\n        } else {\n            return target.apply(\n                that,\n                args.concat(slice.call(arguments))\n            );\n        }\n    };\n\n    var boundLength = Math.max(0, target.length - args.length);\n    var boundArgs = [];\n    for (var i = 0; i < boundLength; i++) {\n        boundArgs.push('$' + i);\n    }\n\n    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);\n\n    if (target.prototype) {\n        var Empty = function Empty() {};\n        Empty.prototype = target.prototype;\n        bound.prototype = new Empty();\n        Empty.prototype = null;\n    }\n\n    return bound;\n};\n\n\n//# sourceURL=webpack://test-webpack-wasm/./node_modules/function-bind/implementation.js?");

/***/ }),

/***/ "./node_modules/function-bind/index.js":
/*!*********************************************!*\
  !*** ./node_modules/function-bind/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar implementation = __webpack_require__(/*! ./implementation */ \"./node_modules/function-bind/implementation.js\");\n\nmodule.exports = Function.prototype.bind || implementation;\n\n\n//# sourceURL=webpack://test-webpack-wasm/./node_modules/function-bind/index.js?");

/***/ }),

/***/ "./node_modules/get-intrinsic/index.js":
/*!*********************************************!*\
  !*** ./node_modules/get-intrinsic/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar undefined;\n\nvar $SyntaxError = SyntaxError;\nvar $Function = Function;\nvar $TypeError = TypeError;\n\n// eslint-disable-next-line consistent-return\nvar getEvalledConstructor = function (expressionSyntax) {\n\ttry {\n\t\treturn $Function('\"use strict\"; return (' + expressionSyntax + ').constructor;')();\n\t} catch (e) {}\n};\n\nvar $gOPD = Object.getOwnPropertyDescriptor;\nif ($gOPD) {\n\ttry {\n\t\t$gOPD({}, '');\n\t} catch (e) {\n\t\t$gOPD = null; // this is IE 8, which has a broken gOPD\n\t}\n}\n\nvar throwTypeError = function () {\n\tthrow new $TypeError();\n};\nvar ThrowTypeError = $gOPD\n\t? (function () {\n\t\ttry {\n\t\t\t// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties\n\t\t\targuments.callee; // IE 8 does not throw here\n\t\t\treturn throwTypeError;\n\t\t} catch (calleeThrows) {\n\t\t\ttry {\n\t\t\t\t// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')\n\t\t\t\treturn $gOPD(arguments, 'callee').get;\n\t\t\t} catch (gOPDthrows) {\n\t\t\t\treturn throwTypeError;\n\t\t\t}\n\t\t}\n\t}())\n\t: throwTypeError;\n\nvar hasSymbols = __webpack_require__(/*! has-symbols */ \"./node_modules/has-symbols/index.js\")();\n\nvar getProto = Object.getPrototypeOf || function (x) { return x.__proto__; }; // eslint-disable-line no-proto\n\nvar needsEval = {};\n\nvar TypedArray = typeof Uint8Array === 'undefined' ? undefined : getProto(Uint8Array);\n\nvar INTRINSICS = {\n\t'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,\n\t'%Array%': Array,\n\t'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,\n\t'%ArrayIteratorPrototype%': hasSymbols ? getProto([][Symbol.iterator]()) : undefined,\n\t'%AsyncFromSyncIteratorPrototype%': undefined,\n\t'%AsyncFunction%': needsEval,\n\t'%AsyncGenerator%': needsEval,\n\t'%AsyncGeneratorFunction%': needsEval,\n\t'%AsyncIteratorPrototype%': needsEval,\n\t'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,\n\t'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,\n\t'%Boolean%': Boolean,\n\t'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,\n\t'%Date%': Date,\n\t'%decodeURI%': decodeURI,\n\t'%decodeURIComponent%': decodeURIComponent,\n\t'%encodeURI%': encodeURI,\n\t'%encodeURIComponent%': encodeURIComponent,\n\t'%Error%': Error,\n\t'%eval%': eval, // eslint-disable-line no-eval\n\t'%EvalError%': EvalError,\n\t'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,\n\t'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,\n\t'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,\n\t'%Function%': $Function,\n\t'%GeneratorFunction%': needsEval,\n\t'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,\n\t'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,\n\t'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,\n\t'%isFinite%': isFinite,\n\t'%isNaN%': isNaN,\n\t'%IteratorPrototype%': hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined,\n\t'%JSON%': typeof JSON === 'object' ? JSON : undefined,\n\t'%Map%': typeof Map === 'undefined' ? undefined : Map,\n\t'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols ? undefined : getProto(new Map()[Symbol.iterator]()),\n\t'%Math%': Math,\n\t'%Number%': Number,\n\t'%Object%': Object,\n\t'%parseFloat%': parseFloat,\n\t'%parseInt%': parseInt,\n\t'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,\n\t'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,\n\t'%RangeError%': RangeError,\n\t'%ReferenceError%': ReferenceError,\n\t'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,\n\t'%RegExp%': RegExp,\n\t'%Set%': typeof Set === 'undefined' ? undefined : Set,\n\t'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols ? undefined : getProto(new Set()[Symbol.iterator]()),\n\t'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,\n\t'%String%': String,\n\t'%StringIteratorPrototype%': hasSymbols ? getProto(''[Symbol.iterator]()) : undefined,\n\t'%Symbol%': hasSymbols ? Symbol : undefined,\n\t'%SyntaxError%': $SyntaxError,\n\t'%ThrowTypeError%': ThrowTypeError,\n\t'%TypedArray%': TypedArray,\n\t'%TypeError%': $TypeError,\n\t'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,\n\t'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,\n\t'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,\n\t'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,\n\t'%URIError%': URIError,\n\t'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,\n\t'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,\n\t'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet\n};\n\nvar doEval = function doEval(name) {\n\tvar value;\n\tif (name === '%AsyncFunction%') {\n\t\tvalue = getEvalledConstructor('async function () {}');\n\t} else if (name === '%GeneratorFunction%') {\n\t\tvalue = getEvalledConstructor('function* () {}');\n\t} else if (name === '%AsyncGeneratorFunction%') {\n\t\tvalue = getEvalledConstructor('async function* () {}');\n\t} else if (name === '%AsyncGenerator%') {\n\t\tvar fn = doEval('%AsyncGeneratorFunction%');\n\t\tif (fn) {\n\t\t\tvalue = fn.prototype;\n\t\t}\n\t} else if (name === '%AsyncIteratorPrototype%') {\n\t\tvar gen = doEval('%AsyncGenerator%');\n\t\tif (gen) {\n\t\t\tvalue = getProto(gen.prototype);\n\t\t}\n\t}\n\n\tINTRINSICS[name] = value;\n\n\treturn value;\n};\n\nvar LEGACY_ALIASES = {\n\t'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],\n\t'%ArrayPrototype%': ['Array', 'prototype'],\n\t'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],\n\t'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],\n\t'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],\n\t'%ArrayProto_values%': ['Array', 'prototype', 'values'],\n\t'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],\n\t'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],\n\t'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],\n\t'%BooleanPrototype%': ['Boolean', 'prototype'],\n\t'%DataViewPrototype%': ['DataView', 'prototype'],\n\t'%DatePrototype%': ['Date', 'prototype'],\n\t'%ErrorPrototype%': ['Error', 'prototype'],\n\t'%EvalErrorPrototype%': ['EvalError', 'prototype'],\n\t'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],\n\t'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],\n\t'%FunctionPrototype%': ['Function', 'prototype'],\n\t'%Generator%': ['GeneratorFunction', 'prototype'],\n\t'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],\n\t'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],\n\t'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],\n\t'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],\n\t'%JSONParse%': ['JSON', 'parse'],\n\t'%JSONStringify%': ['JSON', 'stringify'],\n\t'%MapPrototype%': ['Map', 'prototype'],\n\t'%NumberPrototype%': ['Number', 'prototype'],\n\t'%ObjectPrototype%': ['Object', 'prototype'],\n\t'%ObjProto_toString%': ['Object', 'prototype', 'toString'],\n\t'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],\n\t'%PromisePrototype%': ['Promise', 'prototype'],\n\t'%PromiseProto_then%': ['Promise', 'prototype', 'then'],\n\t'%Promise_all%': ['Promise', 'all'],\n\t'%Promise_reject%': ['Promise', 'reject'],\n\t'%Promise_resolve%': ['Promise', 'resolve'],\n\t'%RangeErrorPrototype%': ['RangeError', 'prototype'],\n\t'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],\n\t'%RegExpPrototype%': ['RegExp', 'prototype'],\n\t'%SetPrototype%': ['Set', 'prototype'],\n\t'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],\n\t'%StringPrototype%': ['String', 'prototype'],\n\t'%SymbolPrototype%': ['Symbol', 'prototype'],\n\t'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],\n\t'%TypedArrayPrototype%': ['TypedArray', 'prototype'],\n\t'%TypeErrorPrototype%': ['TypeError', 'prototype'],\n\t'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],\n\t'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],\n\t'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],\n\t'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],\n\t'%URIErrorPrototype%': ['URIError', 'prototype'],\n\t'%WeakMapPrototype%': ['WeakMap', 'prototype'],\n\t'%WeakSetPrototype%': ['WeakSet', 'prototype']\n};\n\nvar bind = __webpack_require__(/*! function-bind */ \"./node_modules/function-bind/index.js\");\nvar hasOwn = __webpack_require__(/*! has */ \"./node_modules/has/src/index.js\");\nvar $concat = bind.call(Function.call, Array.prototype.concat);\nvar $spliceApply = bind.call(Function.apply, Array.prototype.splice);\nvar $replace = bind.call(Function.call, String.prototype.replace);\nvar $strSlice = bind.call(Function.call, String.prototype.slice);\n\n/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */\nvar rePropName = /[^%.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|%$))/g;\nvar reEscapeChar = /\\\\(\\\\)?/g; /** Used to match backslashes in property paths. */\nvar stringToPath = function stringToPath(string) {\n\tvar first = $strSlice(string, 0, 1);\n\tvar last = $strSlice(string, -1);\n\tif (first === '%' && last !== '%') {\n\t\tthrow new $SyntaxError('invalid intrinsic syntax, expected closing `%`');\n\t} else if (last === '%' && first !== '%') {\n\t\tthrow new $SyntaxError('invalid intrinsic syntax, expected opening `%`');\n\t}\n\tvar result = [];\n\t$replace(string, rePropName, function (match, number, quote, subString) {\n\t\tresult[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;\n\t});\n\treturn result;\n};\n/* end adaptation */\n\nvar getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {\n\tvar intrinsicName = name;\n\tvar alias;\n\tif (hasOwn(LEGACY_ALIASES, intrinsicName)) {\n\t\talias = LEGACY_ALIASES[intrinsicName];\n\t\tintrinsicName = '%' + alias[0] + '%';\n\t}\n\n\tif (hasOwn(INTRINSICS, intrinsicName)) {\n\t\tvar value = INTRINSICS[intrinsicName];\n\t\tif (value === needsEval) {\n\t\t\tvalue = doEval(intrinsicName);\n\t\t}\n\t\tif (typeof value === 'undefined' && !allowMissing) {\n\t\t\tthrow new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');\n\t\t}\n\n\t\treturn {\n\t\t\talias: alias,\n\t\t\tname: intrinsicName,\n\t\t\tvalue: value\n\t\t};\n\t}\n\n\tthrow new $SyntaxError('intrinsic ' + name + ' does not exist!');\n};\n\nmodule.exports = function GetIntrinsic(name, allowMissing) {\n\tif (typeof name !== 'string' || name.length === 0) {\n\t\tthrow new $TypeError('intrinsic name must be a non-empty string');\n\t}\n\tif (arguments.length > 1 && typeof allowMissing !== 'boolean') {\n\t\tthrow new $TypeError('\"allowMissing\" argument must be a boolean');\n\t}\n\n\tvar parts = stringToPath(name);\n\tvar intrinsicBaseName = parts.length > 0 ? parts[0] : '';\n\n\tvar intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);\n\tvar intrinsicRealName = intrinsic.name;\n\tvar value = intrinsic.value;\n\tvar skipFurtherCaching = false;\n\n\tvar alias = intrinsic.alias;\n\tif (alias) {\n\t\tintrinsicBaseName = alias[0];\n\t\t$spliceApply(parts, $concat([0, 1], alias));\n\t}\n\n\tfor (var i = 1, isOwn = true; i < parts.length; i += 1) {\n\t\tvar part = parts[i];\n\t\tvar first = $strSlice(part, 0, 1);\n\t\tvar last = $strSlice(part, -1);\n\t\tif (\n\t\t\t(\n\t\t\t\t(first === '\"' || first === \"'\" || first === '`')\n\t\t\t\t|| (last === '\"' || last === \"'\" || last === '`')\n\t\t\t)\n\t\t\t&& first !== last\n\t\t) {\n\t\t\tthrow new $SyntaxError('property names with quotes must have matching quotes');\n\t\t}\n\t\tif (part === 'constructor' || !isOwn) {\n\t\t\tskipFurtherCaching = true;\n\t\t}\n\n\t\tintrinsicBaseName += '.' + part;\n\t\tintrinsicRealName = '%' + intrinsicBaseName + '%';\n\n\t\tif (hasOwn(INTRINSICS, intrinsicRealName)) {\n\t\t\tvalue = INTRINSICS[intrinsicRealName];\n\t\t} else if (value != null) {\n\t\t\tif (!(part in value)) {\n\t\t\t\tif (!allowMissing) {\n\t\t\t\t\tthrow new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');\n\t\t\t\t}\n\t\t\t\treturn void undefined;\n\t\t\t}\n\t\t\tif ($gOPD && (i + 1) >= parts.length) {\n\t\t\t\tvar desc = $gOPD(value, part);\n\t\t\t\tisOwn = !!desc;\n\n\t\t\t\t// By convention, when a data property is converted to an accessor\n\t\t\t\t// property to emulate a data property that does not suffer from\n\t\t\t\t// the override mistake, that accessor's getter is marked with\n\t\t\t\t// an `originalValue` property. Here, when we detect this, we\n\t\t\t\t// uphold the illusion by pretending to see that original data\n\t\t\t\t// property, i.e., returning the value rather than the getter\n\t\t\t\t// itself.\n\t\t\t\tif (isOwn && 'get' in desc && !('originalValue' in desc.get)) {\n\t\t\t\t\tvalue = desc.get;\n\t\t\t\t} else {\n\t\t\t\t\tvalue = value[part];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tisOwn = hasOwn(value, part);\n\t\t\t\tvalue = value[part];\n\t\t\t}\n\n\t\t\tif (isOwn && !skipFurtherCaching) {\n\t\t\t\tINTRINSICS[intrinsicRealName] = value;\n\t\t\t}\n\t\t}\n\t}\n\treturn value;\n};\n\n\n//# sourceURL=webpack://test-webpack-wasm/./node_modules/get-intrinsic/index.js?");

/***/ }),

/***/ "./node_modules/has-symbols/index.js":
/*!*******************************************!*\
  !*** ./node_modules/has-symbols/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar origSymbol = typeof Symbol !== 'undefined' && Symbol;\nvar hasSymbolSham = __webpack_require__(/*! ./shams */ \"./node_modules/has-symbols/shams.js\");\n\nmodule.exports = function hasNativeSymbols() {\n\tif (typeof origSymbol !== 'function') { return false; }\n\tif (typeof Symbol !== 'function') { return false; }\n\tif (typeof origSymbol('foo') !== 'symbol') { return false; }\n\tif (typeof Symbol('bar') !== 'symbol') { return false; }\n\n\treturn hasSymbolSham();\n};\n\n\n//# sourceURL=webpack://test-webpack-wasm/./node_modules/has-symbols/index.js?");

/***/ }),

/***/ "./node_modules/has-symbols/shams.js":
/*!*******************************************!*\
  !*** ./node_modules/has-symbols/shams.js ***!
  \*******************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* eslint complexity: [2, 18], max-statements: [2, 33] */\nmodule.exports = function hasSymbols() {\n\tif (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }\n\tif (typeof Symbol.iterator === 'symbol') { return true; }\n\n\tvar obj = {};\n\tvar sym = Symbol('test');\n\tvar symObj = Object(sym);\n\tif (typeof sym === 'string') { return false; }\n\n\tif (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }\n\tif (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }\n\n\t// temp disabled per https://github.com/ljharb/object.assign/issues/17\n\t// if (sym instanceof Symbol) { return false; }\n\t// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4\n\t// if (!(symObj instanceof Symbol)) { return false; }\n\n\t// if (typeof Symbol.prototype.toString !== 'function') { return false; }\n\t// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }\n\n\tvar symVal = 42;\n\tobj[sym] = symVal;\n\tfor (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop\n\tif (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }\n\n\tif (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }\n\n\tvar syms = Object.getOwnPropertySymbols(obj);\n\tif (syms.length !== 1 || syms[0] !== sym) { return false; }\n\n\tif (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }\n\n\tif (typeof Object.getOwnPropertyDescriptor === 'function') {\n\t\tvar descriptor = Object.getOwnPropertyDescriptor(obj, sym);\n\t\tif (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }\n\t}\n\n\treturn true;\n};\n\n\n//# sourceURL=webpack://test-webpack-wasm/./node_modules/has-symbols/shams.js?");

/***/ }),

/***/ "./node_modules/has-tostringtag/shams.js":
/*!***********************************************!*\
  !*** ./node_modules/has-tostringtag/shams.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar hasSymbols = __webpack_require__(/*! has-symbols/shams */ \"./node_modules/has-symbols/shams.js\");\n\nmodule.exports = function hasToStringTagShams() {\n\treturn hasSymbols() && !!Symbol.toStringTag;\n};\n\n\n//# sourceURL=webpack://test-webpack-wasm/./node_modules/has-tostringtag/shams.js?");

/***/ }),

/***/ "./node_modules/has/src/index.js":
/*!***************************************!*\
  !*** ./node_modules/has/src/index.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar bind = __webpack_require__(/*! function-bind */ \"./node_modules/function-bind/index.js\");\n\nmodule.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);\n\n\n//# sourceURL=webpack://test-webpack-wasm/./node_modules/has/src/index.js?");

/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n//# sourceURL=webpack://test-webpack-wasm/./node_modules/ieee754/index.js?");

/***/ }),

/***/ "./node_modules/inherits/inherits_browser.js":
/*!***************************************************!*\
  !*** ./node_modules/inherits/inherits_browser.js ***!
  \***************************************************/
/***/ ((module) => {

eval("if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      })\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      var TempCtor = function () {}\n      TempCtor.prototype = superCtor.prototype\n      ctor.prototype = new TempCtor()\n      ctor.prototype.constructor = ctor\n    }\n  }\n}\n\n\n//# sourceURL=webpack://test-webpack-wasm/./node_modules/inherits/inherits_browser.js?");

/***/ }),

/***/ "./node_modules/is-arguments/index.js":
/*!********************************************!*\
  !*** ./node_modules/is-arguments/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar hasToStringTag = __webpack_require__(/*! has-tostringtag/shams */ \"./node_modules/has-tostringtag/shams.js\")();\nvar callBound = __webpack_require__(/*! call-bind/callBound */ \"./node_modules/call-bind/callBound.js\");\n\nvar $toString = callBound('Object.prototype.toString');\n\nvar isStandardArguments = function isArguments(value) {\n\tif (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {\n\t\treturn false;\n\t}\n\treturn $toString(value) === '[object Arguments]';\n};\n\nvar isLegacyArguments = function isArguments(value) {\n\tif (isStandardArguments(value)) {\n\t\treturn true;\n\t}\n\treturn value !== null &&\n\t\ttypeof value === 'object' &&\n\t\ttypeof value.length === 'number' &&\n\t\tvalue.length >= 0 &&\n\t\t$toString(value) !== '[object Array]' &&\n\t\t$toString(value.callee) === '[object Function]';\n};\n\nvar supportsStandardArguments = (function () {\n\treturn isStandardArguments(arguments);\n}());\n\nisStandardArguments.isLegacyArguments = isLegacyArguments; // for tests\n\nmodule.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;\n\n\n//# sourceURL=webpack://test-webpack-wasm/./node_modules/is-arguments/index.js?");

/***/ }),

/***/ "./node_modules/is-generator-function/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/is-generator-function/index.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar toStr = Object.prototype.toString;\nvar fnToStr = Function.prototype.toString;\nvar isFnRegex = /^\\s*(?:function)?\\*/;\nvar hasToStringTag = __webpack_require__(/*! has-tostringtag/shams */ \"./node_modules/has-tostringtag/shams.js\")();\nvar getProto = Object.getPrototypeOf;\nvar getGeneratorFunc = function () { // eslint-disable-line consistent-return\n\tif (!hasToStringTag) {\n\t\treturn false;\n\t}\n\ttry {\n\t\treturn Function('return function*() {}')();\n\t} catch (e) {\n\t}\n};\nvar GeneratorFunction;\n\nmodule.exports = function isGeneratorFunction(fn) {\n\tif (typeof fn !== 'function') {\n\t\treturn false;\n\t}\n\tif (isFnRegex.test(fnToStr.call(fn))) {\n\t\treturn true;\n\t}\n\tif (!hasToStringTag) {\n\t\tvar str = toStr.call(fn);\n\t\treturn str === '[object GeneratorFunction]';\n\t}\n\tif (!getProto) {\n\t\treturn false;\n\t}\n\tif (typeof GeneratorFunction === 'undefined') {\n\t\tvar generatorFunc = getGeneratorFunc();\n\t\tGeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;\n\t}\n\treturn getProto(fn) === GeneratorFunction;\n};\n\n\n//# sourceURL=webpack://test-webpack-wasm/./node_modules/is-generator-function/index.js?");

/***/ }),

/***/ "./node_modules/is-nan/implementation.js":
/*!***********************************************!*\
  !*** ./node_modules/is-nan/implementation.js ***!
  \***********************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */\n\nmodule.exports = function isNaN(value) {\n\treturn value !== value;\n};\n\n\n//# sourceURL=webpack://test-webpack-wasm/./node_modules/is-nan/implementation.js?");

/***/ }),

/***/ "./node_modules/is-nan/index.js":
/*!**************************************!*\
  !*** ./node_modules/is-nan/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar callBind = __webpack_require__(/*! call-bind */ \"./node_modules/call-bind/index.js\");\nvar define = __webpack_require__(/*! define-properties */ \"./node_modules/define-properties/index.js\");\n\nvar implementation = __webpack_require__(/*! ./implementation */ \"./node_modules/is-nan/implementation.js\");\nvar getPolyfill = __webpack_require__(/*! ./polyfill */ \"./node_modules/is-nan/polyfill.js\");\nvar shim = __webpack_require__(/*! ./shim */ \"./node_modules/is-nan/shim.js\");\n\nvar polyfill = callBind(getPolyfill(), Number);\n\n/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */\n\ndefine(polyfill, {\n\tgetPolyfill: getPolyfill,\n\timplementation: implementation,\n\tshim: shim\n});\n\nmodule.exports = polyfill;\n\n\n//# sourceURL=webpack://test-webpack-wasm/./node_modules/is-nan/index.js?");

/***/ }),

/***/ "./node_modules/is-nan/polyfill.js":
/*!*****************************************!*\
  !*** ./node_modules/is-nan/polyfill.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar implementation = __webpack_require__(/*! ./implementation */ \"./node_modules/is-nan/implementation.js\");\n\nmodule.exports = function getPolyfill() {\n\tif (Number.isNaN && Number.isNaN(NaN) && !Number.isNaN('a')) {\n\t\treturn Number.isNaN;\n\t}\n\treturn implementation;\n};\n\n\n//# sourceURL=webpack://test-webpack-wasm/./node_modules/is-nan/polyfill.js?");

/***/ }),

/***/ "./node_modules/is-nan/shim.js":
/*!*************************************!*\
  !*** ./node_modules/is-nan/shim.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar define = __webpack_require__(/*! define-properties */ \"./node_modules/define-properties/index.js\");\nvar getPolyfill = __webpack_require__(/*! ./polyfill */ \"./node_modules/is-nan/polyfill.js\");\n\n/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */\n\nmodule.exports = function shimNumberIsNaN() {\n\tvar polyfill = getPolyfill();\n\tdefine(Number, { isNaN: polyfill }, {\n\t\tisNaN: function testIsNaN() {\n\t\t\treturn Number.isNaN !== polyfill;\n\t\t}\n\t});\n\treturn polyfill;\n};\n\n\n//# sourceURL=webpack://test-webpack-wasm/./node_modules/is-nan/shim.js?");

/***/ }),

/***/ "./node_modules/is-typed-array/index.js":
/*!**********************************************!*\
  !*** ./node_modules/is-typed-array/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar forEach = __webpack_require__(/*! foreach */ \"./node_modules/foreach/index.js\");\nvar availableTypedArrays = __webpack_require__(/*! available-typed-arrays */ \"./node_modules/available-typed-arrays/index.js\");\nvar callBound = __webpack_require__(/*! call-bind/callBound */ \"./node_modules/call-bind/callBound.js\");\n\nvar $toString = callBound('Object.prototype.toString');\nvar hasToStringTag = __webpack_require__(/*! has-tostringtag/shams */ \"./node_modules/has-tostringtag/shams.js\")();\n\nvar g = typeof globalThis === 'undefined' ? __webpack_require__.g : globalThis;\nvar typedArrays = availableTypedArrays();\n\nvar $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {\n\tfor (var i = 0; i < array.length; i += 1) {\n\t\tif (array[i] === value) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n};\nvar $slice = callBound('String.prototype.slice');\nvar toStrTags = {};\nvar gOPD = __webpack_require__(/*! es-abstract/helpers/getOwnPropertyDescriptor */ \"./node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js\");\nvar getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');\nif (hasToStringTag && gOPD && getPrototypeOf) {\n\tforEach(typedArrays, function (typedArray) {\n\t\tvar arr = new g[typedArray]();\n\t\tif (Symbol.toStringTag in arr) {\n\t\t\tvar proto = getPrototypeOf(arr);\n\t\t\tvar descriptor = gOPD(proto, Symbol.toStringTag);\n\t\t\tif (!descriptor) {\n\t\t\t\tvar superProto = getPrototypeOf(proto);\n\t\t\t\tdescriptor = gOPD(superProto, Symbol.toStringTag);\n\t\t\t}\n\t\t\ttoStrTags[typedArray] = descriptor.get;\n\t\t}\n\t});\n}\n\nvar tryTypedArrays = function tryAllTypedArrays(value) {\n\tvar anyTrue = false;\n\tforEach(toStrTags, function (getter, typedArray) {\n\t\tif (!anyTrue) {\n\t\t\ttry {\n\t\t\t\tanyTrue = getter.call(value) === typedArray;\n\t\t\t} catch (e) { /**/ }\n\t\t}\n\t});\n\treturn anyTrue;\n};\n\nmodule.exports = function isTypedArray(value) {\n\tif (!value || typeof value !== 'object') { return false; }\n\tif (!hasToStringTag || !(Symbol.toStringTag in value)) {\n\t\tvar tag = $slice($toString(value), 8, -1);\n\t\treturn $indexOf(typedArrays, tag) > -1;\n\t}\n\tif (!gOPD) { return false; }\n\treturn tryTypedArrays(value);\n};\n\n\n//# sourceURL=webpack://test-webpack-wasm/./node_modules/is-typed-array/index.js?");

/***/ }),

/***/ "./node_modules/object-is/implementation.js":
/*!**************************************************!*\
  !*** ./node_modules/object-is/implementation.js ***!
  \**************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar numberIsNaN = function (value) {\n\treturn value !== value;\n};\n\nmodule.exports = function is(a, b) {\n\tif (a === 0 && b === 0) {\n\t\treturn 1 / a === 1 / b;\n\t}\n\tif (a === b) {\n\t\treturn true;\n\t}\n\tif (numberIsNaN(a) && numberIsNaN(b)) {\n\t\treturn true;\n\t}\n\treturn false;\n};\n\n\n\n//# sourceURL=webpack://test-webpack-wasm/./node_modules/object-is/implementation.js?");

/***/ }),

/***/ "./node_modules/object-is/index.js":
/*!*****************************************!*\
  !*** ./node_modules/object-is/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar define = __webpack_require__(/*! define-properties */ \"./node_modules/define-properties/index.js\");\nvar callBind = __webpack_require__(/*! call-bind */ \"./node_modules/call-bind/index.js\");\n\nvar implementation = __webpack_require__(/*! ./implementation */ \"./node_modules/object-is/implementation.js\");\nvar getPolyfill = __webpack_require__(/*! ./polyfill */ \"./node_modules/object-is/polyfill.js\");\nvar shim = __webpack_require__(/*! ./shim */ \"./node_modules/object-is/shim.js\");\n\nvar polyfill = callBind(getPolyfill(), Object);\n\ndefine(polyfill, {\n\tgetPolyfill: getPolyfill,\n\timplementation: implementation,\n\tshim: shim\n});\n\nmodule.exports = polyfill;\n\n\n//# sourceURL=webpack://test-webpack-wasm/./node_modules/object-is/index.js?");

/***/ }),

/***/ "./node_modules/object-is/polyfill.js":
/*!********************************************!*\
  !*** ./node_modules/object-is/polyfill.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar implementation = __webpack_require__(/*! ./implementation */ \"./node_modules/object-is/implementation.js\");\n\nmodule.exports = function getPolyfill() {\n\treturn typeof Object.is === 'function' ? Object.is : implementation;\n};\n\n\n//# sourceURL=webpack://test-webpack-wasm/./node_modules/object-is/polyfill.js?");

/***/ }),

/***/ "./node_modules/object-is/shim.js":
/*!****************************************!*\
  !*** ./node_modules/object-is/shim.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar getPolyfill = __webpack_require__(/*! ./polyfill */ \"./node_modules/object-is/polyfill.js\");\nvar define = __webpack_require__(/*! define-properties */ \"./node_modules/define-properties/index.js\");\n\nmodule.exports = function shimObjectIs() {\n\tvar polyfill = getPolyfill();\n\tdefine(Object, { is: polyfill }, {\n\t\tis: function testObjectIs() {\n\t\t\treturn Object.is !== polyfill;\n\t\t}\n\t});\n\treturn polyfill;\n};\n\n\n//# sourceURL=webpack://test-webpack-wasm/./node_modules/object-is/shim.js?");

/***/ }),

/***/ "./node_modules/object-keys/implementation.js":
/*!****************************************************!*\
  !*** ./node_modules/object-keys/implementation.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar keysShim;\nif (!Object.keys) {\n\t// modified from https://github.com/es-shims/es5-shim\n\tvar has = Object.prototype.hasOwnProperty;\n\tvar toStr = Object.prototype.toString;\n\tvar isArgs = __webpack_require__(/*! ./isArguments */ \"./node_modules/object-keys/isArguments.js\"); // eslint-disable-line global-require\n\tvar isEnumerable = Object.prototype.propertyIsEnumerable;\n\tvar hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');\n\tvar hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');\n\tvar dontEnums = [\n\t\t'toString',\n\t\t'toLocaleString',\n\t\t'valueOf',\n\t\t'hasOwnProperty',\n\t\t'isPrototypeOf',\n\t\t'propertyIsEnumerable',\n\t\t'constructor'\n\t];\n\tvar equalsConstructorPrototype = function (o) {\n\t\tvar ctor = o.constructor;\n\t\treturn ctor && ctor.prototype === o;\n\t};\n\tvar excludedKeys = {\n\t\t$applicationCache: true,\n\t\t$console: true,\n\t\t$external: true,\n\t\t$frame: true,\n\t\t$frameElement: true,\n\t\t$frames: true,\n\t\t$innerHeight: true,\n\t\t$innerWidth: true,\n\t\t$onmozfullscreenchange: true,\n\t\t$onmozfullscreenerror: true,\n\t\t$outerHeight: true,\n\t\t$outerWidth: true,\n\t\t$pageXOffset: true,\n\t\t$pageYOffset: true,\n\t\t$parent: true,\n\t\t$scrollLeft: true,\n\t\t$scrollTop: true,\n\t\t$scrollX: true,\n\t\t$scrollY: true,\n\t\t$self: true,\n\t\t$webkitIndexedDB: true,\n\t\t$webkitStorageInfo: true,\n\t\t$window: true\n\t};\n\tvar hasAutomationEqualityBug = (function () {\n\t\t/* global window */\n\t\tif (typeof window === 'undefined') { return false; }\n\t\tfor (var k in window) {\n\t\t\ttry {\n\t\t\t\tif (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tequalsConstructorPrototype(window[k]);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}());\n\tvar equalsConstructorPrototypeIfNotBuggy = function (o) {\n\t\t/* global window */\n\t\tif (typeof window === 'undefined' || !hasAutomationEqualityBug) {\n\t\t\treturn equalsConstructorPrototype(o);\n\t\t}\n\t\ttry {\n\t\t\treturn equalsConstructorPrototype(o);\n\t\t} catch (e) {\n\t\t\treturn false;\n\t\t}\n\t};\n\n\tkeysShim = function keys(object) {\n\t\tvar isObject = object !== null && typeof object === 'object';\n\t\tvar isFunction = toStr.call(object) === '[object Function]';\n\t\tvar isArguments = isArgs(object);\n\t\tvar isString = isObject && toStr.call(object) === '[object String]';\n\t\tvar theKeys = [];\n\n\t\tif (!isObject && !isFunction && !isArguments) {\n\t\t\tthrow new TypeError('Object.keys called on a non-object');\n\t\t}\n\n\t\tvar skipProto = hasProtoEnumBug && isFunction;\n\t\tif (isString && object.length > 0 && !has.call(object, 0)) {\n\t\t\tfor (var i = 0; i < object.length; ++i) {\n\t\t\t\ttheKeys.push(String(i));\n\t\t\t}\n\t\t}\n\n\t\tif (isArguments && object.length > 0) {\n\t\t\tfor (var j = 0; j < object.length; ++j) {\n\t\t\t\ttheKeys.push(String(j));\n\t\t\t}\n\t\t} else {\n\t\t\tfor (var name in object) {\n\t\t\t\tif (!(skipProto && name === 'prototype') && has.call(object, name)) {\n\t\t\t\t\ttheKeys.push(String(name));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (hasDontEnumBug) {\n\t\t\tvar skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);\n\n\t\t\tfor (var k = 0; k < dontEnums.length; ++k) {\n\t\t\t\tif (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {\n\t\t\t\t\ttheKeys.push(dontEnums[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn theKeys;\n\t};\n}\nmodule.exports = keysShim;\n\n\n//# sourceURL=webpack://test-webpack-wasm/./node_modules/object-keys/implementation.js?");

/***/ }),

/***/ "./node_modules/object-keys/index.js":
/*!*******************************************!*\
  !*** ./node_modules/object-keys/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar slice = Array.prototype.slice;\nvar isArgs = __webpack_require__(/*! ./isArguments */ \"./node_modules/object-keys/isArguments.js\");\n\nvar origKeys = Object.keys;\nvar keysShim = origKeys ? function keys(o) { return origKeys(o); } : __webpack_require__(/*! ./implementation */ \"./node_modules/object-keys/implementation.js\");\n\nvar originalKeys = Object.keys;\n\nkeysShim.shim = function shimObjectKeys() {\n\tif (Object.keys) {\n\t\tvar keysWorksWithArguments = (function () {\n\t\t\t// Safari 5.0 bug\n\t\t\tvar args = Object.keys(arguments);\n\t\t\treturn args && args.length === arguments.length;\n\t\t}(1, 2));\n\t\tif (!keysWorksWithArguments) {\n\t\t\tObject.keys = function keys(object) { // eslint-disable-line func-name-matching\n\t\t\t\tif (isArgs(object)) {\n\t\t\t\t\treturn originalKeys(slice.call(object));\n\t\t\t\t}\n\t\t\t\treturn originalKeys(object);\n\t\t\t};\n\t\t}\n\t} else {\n\t\tObject.keys = keysShim;\n\t}\n\treturn Object.keys || keysShim;\n};\n\nmodule.exports = keysShim;\n\n\n//# sourceURL=webpack://test-webpack-wasm/./node_modules/object-keys/index.js?");

/***/ }),

/***/ "./node_modules/object-keys/isArguments.js":
/*!*************************************************!*\
  !*** ./node_modules/object-keys/isArguments.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar toStr = Object.prototype.toString;\n\nmodule.exports = function isArguments(value) {\n\tvar str = toStr.call(value);\n\tvar isArgs = str === '[object Arguments]';\n\tif (!isArgs) {\n\t\tisArgs = str !== '[object Array]' &&\n\t\t\tvalue !== null &&\n\t\t\ttypeof value === 'object' &&\n\t\t\ttypeof value.length === 'number' &&\n\t\t\tvalue.length >= 0 &&\n\t\t\ttoStr.call(value.callee) === '[object Function]';\n\t}\n\treturn isArgs;\n};\n\n\n//# sourceURL=webpack://test-webpack-wasm/./node_modules/object-keys/isArguments.js?");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/***/ ((module) => {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack://test-webpack-wasm/./node_modules/process/browser.js?");

/***/ }),

/***/ "./node_modules/util/support/isBufferBrowser.js":
/*!******************************************************!*\
  !*** ./node_modules/util/support/isBufferBrowser.js ***!
  \******************************************************/
/***/ ((module) => {

eval("module.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}\n\n//# sourceURL=webpack://test-webpack-wasm/./node_modules/util/support/isBufferBrowser.js?");

/***/ }),

/***/ "./node_modules/util/support/types.js":
/*!********************************************!*\
  !*** ./node_modules/util/support/types.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("// Currently in sync with Node.js lib/internal/util/types.js\n// https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9\n\n\n\nvar isArgumentsObject = __webpack_require__(/*! is-arguments */ \"./node_modules/is-arguments/index.js\");\nvar isGeneratorFunction = __webpack_require__(/*! is-generator-function */ \"./node_modules/is-generator-function/index.js\");\nvar whichTypedArray = __webpack_require__(/*! which-typed-array */ \"./node_modules/which-typed-array/index.js\");\nvar isTypedArray = __webpack_require__(/*! is-typed-array */ \"./node_modules/is-typed-array/index.js\");\n\nfunction uncurryThis(f) {\n  return f.call.bind(f);\n}\n\nvar BigIntSupported = typeof BigInt !== 'undefined';\nvar SymbolSupported = typeof Symbol !== 'undefined';\n\nvar ObjectToString = uncurryThis(Object.prototype.toString);\n\nvar numberValue = uncurryThis(Number.prototype.valueOf);\nvar stringValue = uncurryThis(String.prototype.valueOf);\nvar booleanValue = uncurryThis(Boolean.prototype.valueOf);\n\nif (BigIntSupported) {\n  var bigIntValue = uncurryThis(BigInt.prototype.valueOf);\n}\n\nif (SymbolSupported) {\n  var symbolValue = uncurryThis(Symbol.prototype.valueOf);\n}\n\nfunction checkBoxedPrimitive(value, prototypeValueOf) {\n  if (typeof value !== 'object') {\n    return false;\n  }\n  try {\n    prototypeValueOf(value);\n    return true;\n  } catch(e) {\n    return false;\n  }\n}\n\nexports.isArgumentsObject = isArgumentsObject;\nexports.isGeneratorFunction = isGeneratorFunction;\nexports.isTypedArray = isTypedArray;\n\n// Taken from here and modified for better browser support\n// https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js\nfunction isPromise(input) {\n\treturn (\n\t\t(\n\t\t\ttypeof Promise !== 'undefined' &&\n\t\t\tinput instanceof Promise\n\t\t) ||\n\t\t(\n\t\t\tinput !== null &&\n\t\t\ttypeof input === 'object' &&\n\t\t\ttypeof input.then === 'function' &&\n\t\t\ttypeof input.catch === 'function'\n\t\t)\n\t);\n}\nexports.isPromise = isPromise;\n\nfunction isArrayBufferView(value) {\n  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {\n    return ArrayBuffer.isView(value);\n  }\n\n  return (\n    isTypedArray(value) ||\n    isDataView(value)\n  );\n}\nexports.isArrayBufferView = isArrayBufferView;\n\n\nfunction isUint8Array(value) {\n  return whichTypedArray(value) === 'Uint8Array';\n}\nexports.isUint8Array = isUint8Array;\n\nfunction isUint8ClampedArray(value) {\n  return whichTypedArray(value) === 'Uint8ClampedArray';\n}\nexports.isUint8ClampedArray = isUint8ClampedArray;\n\nfunction isUint16Array(value) {\n  return whichTypedArray(value) === 'Uint16Array';\n}\nexports.isUint16Array = isUint16Array;\n\nfunction isUint32Array(value) {\n  return whichTypedArray(value) === 'Uint32Array';\n}\nexports.isUint32Array = isUint32Array;\n\nfunction isInt8Array(value) {\n  return whichTypedArray(value) === 'Int8Array';\n}\nexports.isInt8Array = isInt8Array;\n\nfunction isInt16Array(value) {\n  return whichTypedArray(value) === 'Int16Array';\n}\nexports.isInt16Array = isInt16Array;\n\nfunction isInt32Array(value) {\n  return whichTypedArray(value) === 'Int32Array';\n}\nexports.isInt32Array = isInt32Array;\n\nfunction isFloat32Array(value) {\n  return whichTypedArray(value) === 'Float32Array';\n}\nexports.isFloat32Array = isFloat32Array;\n\nfunction isFloat64Array(value) {\n  return whichTypedArray(value) === 'Float64Array';\n}\nexports.isFloat64Array = isFloat64Array;\n\nfunction isBigInt64Array(value) {\n  return whichTypedArray(value) === 'BigInt64Array';\n}\nexports.isBigInt64Array = isBigInt64Array;\n\nfunction isBigUint64Array(value) {\n  return whichTypedArray(value) === 'BigUint64Array';\n}\nexports.isBigUint64Array = isBigUint64Array;\n\nfunction isMapToString(value) {\n  return ObjectToString(value) === '[object Map]';\n}\nisMapToString.working = (\n  typeof Map !== 'undefined' &&\n  isMapToString(new Map())\n);\n\nfunction isMap(value) {\n  if (typeof Map === 'undefined') {\n    return false;\n  }\n\n  return isMapToString.working\n    ? isMapToString(value)\n    : value instanceof Map;\n}\nexports.isMap = isMap;\n\nfunction isSetToString(value) {\n  return ObjectToString(value) === '[object Set]';\n}\nisSetToString.working = (\n  typeof Set !== 'undefined' &&\n  isSetToString(new Set())\n);\nfunction isSet(value) {\n  if (typeof Set === 'undefined') {\n    return false;\n  }\n\n  return isSetToString.working\n    ? isSetToString(value)\n    : value instanceof Set;\n}\nexports.isSet = isSet;\n\nfunction isWeakMapToString(value) {\n  return ObjectToString(value) === '[object WeakMap]';\n}\nisWeakMapToString.working = (\n  typeof WeakMap !== 'undefined' &&\n  isWeakMapToString(new WeakMap())\n);\nfunction isWeakMap(value) {\n  if (typeof WeakMap === 'undefined') {\n    return false;\n  }\n\n  return isWeakMapToString.working\n    ? isWeakMapToString(value)\n    : value instanceof WeakMap;\n}\nexports.isWeakMap = isWeakMap;\n\nfunction isWeakSetToString(value) {\n  return ObjectToString(value) === '[object WeakSet]';\n}\nisWeakSetToString.working = (\n  typeof WeakSet !== 'undefined' &&\n  isWeakSetToString(new WeakSet())\n);\nfunction isWeakSet(value) {\n  return isWeakSetToString(value);\n}\nexports.isWeakSet = isWeakSet;\n\nfunction isArrayBufferToString(value) {\n  return ObjectToString(value) === '[object ArrayBuffer]';\n}\nisArrayBufferToString.working = (\n  typeof ArrayBuffer !== 'undefined' &&\n  isArrayBufferToString(new ArrayBuffer())\n);\nfunction isArrayBuffer(value) {\n  if (typeof ArrayBuffer === 'undefined') {\n    return false;\n  }\n\n  return isArrayBufferToString.working\n    ? isArrayBufferToString(value)\n    : value instanceof ArrayBuffer;\n}\nexports.isArrayBuffer = isArrayBuffer;\n\nfunction isDataViewToString(value) {\n  return ObjectToString(value) === '[object DataView]';\n}\nisDataViewToString.working = (\n  typeof ArrayBuffer !== 'undefined' &&\n  typeof DataView !== 'undefined' &&\n  isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1))\n);\nfunction isDataView(value) {\n  if (typeof DataView === 'undefined') {\n    return false;\n  }\n\n  return isDataViewToString.working\n    ? isDataViewToString(value)\n    : value instanceof DataView;\n}\nexports.isDataView = isDataView;\n\n// Store a copy of SharedArrayBuffer in case it's deleted elsewhere\nvar SharedArrayBufferCopy = typeof SharedArrayBuffer !== 'undefined' ? SharedArrayBuffer : undefined;\nfunction isSharedArrayBufferToString(value) {\n  return ObjectToString(value) === '[object SharedArrayBuffer]';\n}\nfunction isSharedArrayBuffer(value) {\n  if (typeof SharedArrayBufferCopy === 'undefined') {\n    return false;\n  }\n\n  if (typeof isSharedArrayBufferToString.working === 'undefined') {\n    isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());\n  }\n\n  return isSharedArrayBufferToString.working\n    ? isSharedArrayBufferToString(value)\n    : value instanceof SharedArrayBufferCopy;\n}\nexports.isSharedArrayBuffer = isSharedArrayBuffer;\n\nfunction isAsyncFunction(value) {\n  return ObjectToString(value) === '[object AsyncFunction]';\n}\nexports.isAsyncFunction = isAsyncFunction;\n\nfunction isMapIterator(value) {\n  return ObjectToString(value) === '[object Map Iterator]';\n}\nexports.isMapIterator = isMapIterator;\n\nfunction isSetIterator(value) {\n  return ObjectToString(value) === '[object Set Iterator]';\n}\nexports.isSetIterator = isSetIterator;\n\nfunction isGeneratorObject(value) {\n  return ObjectToString(value) === '[object Generator]';\n}\nexports.isGeneratorObject = isGeneratorObject;\n\nfunction isWebAssemblyCompiledModule(value) {\n  return ObjectToString(value) === '[object WebAssembly.Module]';\n}\nexports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;\n\nfunction isNumberObject(value) {\n  return checkBoxedPrimitive(value, numberValue);\n}\nexports.isNumberObject = isNumberObject;\n\nfunction isStringObject(value) {\n  return checkBoxedPrimitive(value, stringValue);\n}\nexports.isStringObject = isStringObject;\n\nfunction isBooleanObject(value) {\n  return checkBoxedPrimitive(value, booleanValue);\n}\nexports.isBooleanObject = isBooleanObject;\n\nfunction isBigIntObject(value) {\n  return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);\n}\nexports.isBigIntObject = isBigIntObject;\n\nfunction isSymbolObject(value) {\n  return SymbolSupported && checkBoxedPrimitive(value, symbolValue);\n}\nexports.isSymbolObject = isSymbolObject;\n\nfunction isBoxedPrimitive(value) {\n  return (\n    isNumberObject(value) ||\n    isStringObject(value) ||\n    isBooleanObject(value) ||\n    isBigIntObject(value) ||\n    isSymbolObject(value)\n  );\n}\nexports.isBoxedPrimitive = isBoxedPrimitive;\n\nfunction isAnyArrayBuffer(value) {\n  return typeof Uint8Array !== 'undefined' && (\n    isArrayBuffer(value) ||\n    isSharedArrayBuffer(value)\n  );\n}\nexports.isAnyArrayBuffer = isAnyArrayBuffer;\n\n['isProxy', 'isExternal', 'isModuleNamespaceObject'].forEach(function(method) {\n  Object.defineProperty(exports, method, {\n    enumerable: false,\n    value: function() {\n      throw new Error(method + ' is not supported in userland');\n    }\n  });\n});\n\n\n//# sourceURL=webpack://test-webpack-wasm/./node_modules/util/support/types.js?");

/***/ }),

/***/ "./node_modules/util/util.js":
/*!***********************************!*\
  !*** ./node_modules/util/util.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* provided dependency */ var process = __webpack_require__(/*! ./node_modules/process/browser.js */ \"./node_modules/process/browser.js\");\n/* provided dependency */ var console = __webpack_require__(/*! ./node_modules/console-browserify/index.js */ \"./node_modules/console-browserify/index.js\");\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||\n  function getOwnPropertyDescriptors(obj) {\n    var keys = Object.keys(obj);\n    var descriptors = {};\n    for (var i = 0; i < keys.length; i++) {\n      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);\n    }\n    return descriptors;\n  };\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  if (typeof process !== 'undefined' && process.noDeprecation === true) {\n    return fn;\n  }\n\n  // Allow for deprecating things in the process of starting up.\n  if (typeof process === 'undefined') {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnvRegex = /^$/;\n\nif (process.env.NODE_DEBUG) {\n  var debugEnv = process.env.NODE_DEBUG;\n  debugEnv = debugEnv.replace(/[|\\\\{}()[\\]^$+?.]/g, '\\\\$&')\n    .replace(/\\*/g, '.*')\n    .replace(/,/g, '$|^')\n    .toUpperCase();\n  debugEnvRegex = new RegExp('^' + debugEnv + '$', 'i');\n}\nexports.debuglog = function(set) {\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (debugEnvRegex.test(set)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nexports.types = __webpack_require__(/*! ./support/types */ \"./node_modules/util/support/types.js\");\n\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\nexports.types.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\nexports.types.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\nexports.types.isNativeError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = __webpack_require__(/*! ./support/isBuffer */ \"./node_modules/util/support/isBufferBrowser.js\");\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nvar kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;\n\nexports.promisify = function promisify(original) {\n  if (typeof original !== 'function')\n    throw new TypeError('The \"original\" argument must be of type Function');\n\n  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {\n    var fn = original[kCustomPromisifiedSymbol];\n    if (typeof fn !== 'function') {\n      throw new TypeError('The \"util.promisify.custom\" argument must be of type Function');\n    }\n    Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n      value: fn, enumerable: false, writable: false, configurable: true\n    });\n    return fn;\n  }\n\n  function fn() {\n    var promiseResolve, promiseReject;\n    var promise = new Promise(function (resolve, reject) {\n      promiseResolve = resolve;\n      promiseReject = reject;\n    });\n\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n    args.push(function (err, value) {\n      if (err) {\n        promiseReject(err);\n      } else {\n        promiseResolve(value);\n      }\n    });\n\n    try {\n      original.apply(this, args);\n    } catch (err) {\n      promiseReject(err);\n    }\n\n    return promise;\n  }\n\n  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));\n\n  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n    value: fn, enumerable: false, writable: false, configurable: true\n  });\n  return Object.defineProperties(\n    fn,\n    getOwnPropertyDescriptors(original)\n  );\n}\n\nexports.promisify.custom = kCustomPromisifiedSymbol\n\nfunction callbackifyOnRejected(reason, cb) {\n  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).\n  // Because `null` is a special error value in callbacks which means \"no error\n  // occurred\", we error-wrap so the callback consumer can distinguish between\n  // \"the promise rejected with null\" or \"the promise fulfilled with undefined\".\n  if (!reason) {\n    var newReason = new Error('Promise was rejected with a falsy value');\n    newReason.reason = reason;\n    reason = newReason;\n  }\n  return cb(reason);\n}\n\nfunction callbackify(original) {\n  if (typeof original !== 'function') {\n    throw new TypeError('The \"original\" argument must be of type Function');\n  }\n\n  // We DO NOT return the promise as it gives the user a false sense that\n  // the promise is actually somehow related to the callback's execution\n  // and that the callback throwing will reject the promise.\n  function callbackified() {\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n\n    var maybeCb = args.pop();\n    if (typeof maybeCb !== 'function') {\n      throw new TypeError('The last argument must be of type Function');\n    }\n    var self = this;\n    var cb = function() {\n      return maybeCb.apply(self, arguments);\n    };\n    // In true node style we process the callback on `nextTick` with all the\n    // implications (stack, `uncaughtException`, `async_hooks`)\n    original.apply(this, args)\n      .then(function(ret) { process.nextTick(cb.bind(null, null, ret)) },\n            function(rej) { process.nextTick(callbackifyOnRejected.bind(null, rej, cb)) });\n  }\n\n  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));\n  Object.defineProperties(callbackified,\n                          getOwnPropertyDescriptors(original));\n  return callbackified;\n}\nexports.callbackify = callbackify;\n\n\n//# sourceURL=webpack://test-webpack-wasm/./node_modules/util/util.js?");

/***/ }),

/***/ "./node_modules/which-typed-array/index.js":
/*!*************************************************!*\
  !*** ./node_modules/which-typed-array/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar forEach = __webpack_require__(/*! foreach */ \"./node_modules/foreach/index.js\");\nvar availableTypedArrays = __webpack_require__(/*! available-typed-arrays */ \"./node_modules/available-typed-arrays/index.js\");\nvar callBound = __webpack_require__(/*! call-bind/callBound */ \"./node_modules/call-bind/callBound.js\");\n\nvar $toString = callBound('Object.prototype.toString');\nvar hasToStringTag = __webpack_require__(/*! has-tostringtag/shams */ \"./node_modules/has-tostringtag/shams.js\")();\n\nvar g = typeof globalThis === 'undefined' ? __webpack_require__.g : globalThis;\nvar typedArrays = availableTypedArrays();\n\nvar $slice = callBound('String.prototype.slice');\nvar toStrTags = {};\nvar gOPD = __webpack_require__(/*! es-abstract/helpers/getOwnPropertyDescriptor */ \"./node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js\");\nvar getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');\nif (hasToStringTag && gOPD && getPrototypeOf) {\n\tforEach(typedArrays, function (typedArray) {\n\t\tif (typeof g[typedArray] === 'function') {\n\t\t\tvar arr = new g[typedArray]();\n\t\t\tif (Symbol.toStringTag in arr) {\n\t\t\t\tvar proto = getPrototypeOf(arr);\n\t\t\t\tvar descriptor = gOPD(proto, Symbol.toStringTag);\n\t\t\t\tif (!descriptor) {\n\t\t\t\t\tvar superProto = getPrototypeOf(proto);\n\t\t\t\t\tdescriptor = gOPD(superProto, Symbol.toStringTag);\n\t\t\t\t}\n\t\t\t\ttoStrTags[typedArray] = descriptor.get;\n\t\t\t}\n\t\t}\n\t});\n}\n\nvar tryTypedArrays = function tryAllTypedArrays(value) {\n\tvar foundName = false;\n\tforEach(toStrTags, function (getter, typedArray) {\n\t\tif (!foundName) {\n\t\t\ttry {\n\t\t\t\tvar name = getter.call(value);\n\t\t\t\tif (name === typedArray) {\n\t\t\t\t\tfoundName = name;\n\t\t\t\t}\n\t\t\t} catch (e) {}\n\t\t}\n\t});\n\treturn foundName;\n};\n\nvar isTypedArray = __webpack_require__(/*! is-typed-array */ \"./node_modules/is-typed-array/index.js\");\n\nmodule.exports = function whichTypedArray(value) {\n\tif (!isTypedArray(value)) { return false; }\n\tif (!hasToStringTag || !(Symbol.toStringTag in value)) { return $slice($toString(value), 8, -1); }\n\treturn tryTypedArrays(value);\n};\n\n\n//# sourceURL=webpack://test-webpack-wasm/./node_modules/which-typed-array/index.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__) => {\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _emurgo_cardano_serialization_lib_browser_cardano_serialization_lib_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @emurgo/cardano-serialization-lib-browser/cardano_serialization_lib.js */ \"./node_modules/@emurgo/cardano-serialization-lib-browser/cardano_serialization_lib_bg.js\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! ./node_modules/buffer/index.js */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n/* provided dependency */ var console = __webpack_require__(/*! ./node_modules/console-browserify/index.js */ \"./node_modules/console-browserify/index.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_emurgo_cardano_serialization_lib_browser_cardano_serialization_lib_js__WEBPACK_IMPORTED_MODULE_0__]);\n_emurgo_cardano_serialization_lib_browser_cardano_serialization_lib_js__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? await __webpack_async_dependencies__ : __webpack_async_dependencies__)[0];\n\n\n// console.log(Address.from_bech32(\"\"));\nvar paymentAddr =\n// \"addr_test1qpu5vlrf4xkxv2qpwngf6cjhtw542ayty80v8dyr49rf5ewvxwdrt70qlcpeeagscasafhffqsxy36t90ldv06wqrk2qum8x5w\";\n\"addr_test1qqk3gxl2puy90jv6u5hfpj9khz3va9ljhxs4eaur5tjk7fnraj5378zauu6wlg85g6nkp9w35kfjlxa645yd7jeraf0qpguk3d\";\n\nconst foobar = async () => {\n  const baseAddr = _emurgo_cardano_serialization_lib_browser_cardano_serialization_lib_js__WEBPACK_IMPORTED_MODULE_0__.BaseAddress.from_address(\n    _emurgo_cardano_serialization_lib_browser_cardano_serialization_lib_js__WEBPACK_IMPORTED_MODULE_0__.Address.from_bech32(paymentAddr)\n  );\n  const paymentKeyHash = Buffer.from(\n    baseAddr.payment_cred().to_keyhash().to_bytes()\n  ).toString('hex');\n  const stakeKeyHash = Buffer.from(\n    baseAddr.stake_cred().to_keyhash().to_bytes()\n  ).toString('hex');\n\n  console.log(paymentKeyHash);\n  console.log(stakeKeyHash);\n};\n\n// TODO: this should be retrieved instead of hardcoded\nconst getProtocolParameters = async () => {\n  return {\n    linearFee: {\n      minFeeA: p.min_fee_a.toString(),\n      minFeeB: p.min_fee_b.toString(),\n    },\n    minUtxo: \"1000000\",\n    poolDeposit: \"500000000\",\n    keyDeposit: \"2000000\",\n    maxValSize: \"5000\",\n    maxTxSize: 16384,\n    priceMem: 5.77e-2,\n    priceStep: 7.21e-5,\n  };\n};\n\nconst balanceTx = async (txCBOR) => {\n  const tx = _emurgo_cardano_serialization_lib_browser_cardano_serialization_lib_js__WEBPACK_IMPORTED_MODULE_0__.Transaction.from_bytes(Buffer.from(txCBOR, 'hex'));\n  const protocolParameters = getProtocolParameters();\n\n  const utxos = (await window.cardano.getUtxos()).map((utxo) =>\n    _emurgo_cardano_serialization_lib_browser_cardano_serialization_lib_js__WEBPACK_IMPORTED_MODULE_0__.TransactionUnspentOutput.from_bytes(fromHex(utxo))\n  );\n\n  return tx;\n};\n\n/*  submitTxRes <- return $ ffor dynHexWitness $ \\(hexWitness :: Text) -> do\n/  submitTx <- eval(\"txWitness = buffer.Buffer.from(\"<> hexWitness <> \", 'hex'); \\\n/  txVkeyWitnesses = CardanoWasm.TransactionWitnessSet.from_bytes(txWitness); \\\n/  transactionWitnessSet = CardanoWasm.TransactionWitnessSet.new(); \\\n/  transactionWitnessSet.set_plutus_scripts(\" <> contract <> \"); \\\n/  transactionWitnessSet.set_plutus_data(\" <> datum <> \"); \\\n/  transactionWitnessSet.set_redeemers(\" <> redeemer <> \"); \\\n/  transactionWitnessSet.set_vkeys(txVkeyWitnesses.vkeys()); \\\n/  const signedTx = Loader.Cardano.Transaction.new( \\\n/  tx.body(), \\\n/  transactionWitnessSet, \\\n/  tx.auxiliary_data()); \\\n/  txHash = Buffer.from(signedTx.to_bytes()).toString('hex'); \\\n/  window.cardano.submitTx(txHash);\") */\n\n\nconst appendAndSubmit = async (txCBOR, witnessSetCBOR) => {\n  const tx = _emurgo_cardano_serialization_lib_browser_cardano_serialization_lib_js__WEBPACK_IMPORTED_MODULE_0__.Transaction.from_bytes(\n    Buffer.from(txCBOR, 'hex')\n  );\n  const initWitnessSet = tx.witness_set();\n  const signedWitnessSet = _emurgo_cardano_serialization_lib_browser_cardano_serialization_lib_js__WEBPACK_IMPORTED_MODULE_0__.TransactionWitnessSet.from_bytes(\n    Buffer.from(witnessSetCBOR, 'hex')\n  );\n\t// TODO: Ensure initial vkeys are included\n  initWitnessSet.set_vkeys(signedWitnessSet.vkeys());\n\n  const transaction = _emurgo_cardano_serialization_lib_browser_cardano_serialization_lib_js__WEBPACK_IMPORTED_MODULE_0__.Transaction[\"new\"](tx.body(), initWitnessSet);\n  const txHash = await window.cardano.submitTx(\n    Buffer.from(transaction.to_bytes(), 'hex').toString('hex')\n  );\n  console.log(txHash);\n};\n\nwindow[\"appendAndSubmit\"] = appendAndSubmit;\nwindow[\"balanceTx\"] = balanceTx;\nwindow[\"foobar\"] = foobar;\nwindow[\"getProtocolParameters\"] = getProtocolParameters;\n\n// import { _Z4facti } from './factorial.wasm';\n// console.log('---- Sync Wasm Module');\n// const factorial = _Z4facti;\n// console.log(factorial); // [native code]\n// console.log(factorial(1));\n// console.log(factorial(2));\n// console.log(factorial(3));\n\n// import('./factorial.wasm').then(({ _Z4facti: AsyncFactorial }) => {\n//   console.log('---- Async Wasm Module');\n//   console.log(AsyncFactorial); // [native code]\n//   console.log(AsyncFactorial(1));\n//   console.log(AsyncFactorial(2));\n//   console.log(AsyncFactorial(3));\n// });\n\n});\n\n//# sourceURL=webpack://test-webpack-wasm/./src/index.js?");

/***/ }),

/***/ "./node_modules/available-typed-arrays/index.js":
/*!******************************************************!*\
  !*** ./node_modules/available-typed-arrays/index.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar possibleNames = [\n\t'BigInt64Array',\n\t'BigUint64Array',\n\t'Float32Array',\n\t'Float64Array',\n\t'Int16Array',\n\t'Int32Array',\n\t'Int8Array',\n\t'Uint16Array',\n\t'Uint32Array',\n\t'Uint8Array',\n\t'Uint8ClampedArray'\n];\n\nvar g = typeof globalThis === 'undefined' ? __webpack_require__.g : globalThis;\n\nmodule.exports = function availableTypedArrays() {\n\tvar out = [];\n\tfor (var i = 0; i < possibleNames.length; i++) {\n\t\tif (typeof g[possibleNames[i]] === 'function') {\n\t\t\tout[out.length] = possibleNames[i];\n\t\t}\n\t}\n\treturn out;\n};\n\n\n//# sourceURL=webpack://test-webpack-wasm/./node_modules/available-typed-arrays/index.js?");

/***/ }),

/***/ "./node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js":
/*!**********************************************************************!*\
  !*** ./node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar GetIntrinsic = __webpack_require__(/*! get-intrinsic */ \"./node_modules/get-intrinsic/index.js\");\n\nvar $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);\nif ($gOPD) {\n\ttry {\n\t\t$gOPD([], 'length');\n\t} catch (e) {\n\t\t// IE 8 has a broken gOPD\n\t\t$gOPD = null;\n\t}\n}\n\nmodule.exports = $gOPD;\n\n\n//# sourceURL=webpack://test-webpack-wasm/./node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js?");

/***/ }),

/***/ "./node_modules/@emurgo/cardano-serialization-lib-browser/cardano_serialization_lib_bg.wasm":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@emurgo/cardano-serialization-lib-browser/cardano_serialization_lib_bg.wasm ***!
  \**************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("var __webpack_instantiate__ = ([WEBPACK_IMPORTED_MODULE_0]) => {\n\treturn __webpack_require__.v(exports, module.id, \"2ec26af91630ae46e691\", {\n\t\t\"./cardano_serialization_lib_bg.js\": {\n\t\t\t\"__wbindgen_object_drop_ref\": WEBPACK_IMPORTED_MODULE_0.__wbindgen_object_drop_ref,\n\t\t\t\"__wbindgen_string_new\": WEBPACK_IMPORTED_MODULE_0.__wbindgen_string_new,\n\t\t\t\"__wbg_getRandomValues_98117e9a7e993920\": WEBPACK_IMPORTED_MODULE_0.__wbg_getRandomValues_98117e9a7e993920,\n\t\t\t\"__wbg_randomFillSync_64cc7d048f228ca8\": WEBPACK_IMPORTED_MODULE_0.__wbg_randomFillSync_64cc7d048f228ca8,\n\t\t\t\"__wbg_process_2f24d6544ea7b200\": WEBPACK_IMPORTED_MODULE_0.__wbg_process_2f24d6544ea7b200,\n\t\t\t\"__wbindgen_is_object\": WEBPACK_IMPORTED_MODULE_0.__wbindgen_is_object,\n\t\t\t\"__wbg_versions_6164651e75405d4a\": WEBPACK_IMPORTED_MODULE_0.__wbg_versions_6164651e75405d4a,\n\t\t\t\"__wbg_node_4b517d861cbcb3bc\": WEBPACK_IMPORTED_MODULE_0.__wbg_node_4b517d861cbcb3bc,\n\t\t\t\"__wbg_crypto_98fc271021c7d2ad\": WEBPACK_IMPORTED_MODULE_0.__wbg_crypto_98fc271021c7d2ad,\n\t\t\t\"__wbg_msCrypto_a2cdb043d2bfe57f\": WEBPACK_IMPORTED_MODULE_0.__wbg_msCrypto_a2cdb043d2bfe57f,\n\t\t\t\"__wbg_modulerequire_3440a4bcf44437db\": WEBPACK_IMPORTED_MODULE_0.__wbg_modulerequire_3440a4bcf44437db,\n\t\t\t\"__wbg_newnoargs_9fdd8f3961dd1bee\": WEBPACK_IMPORTED_MODULE_0.__wbg_newnoargs_9fdd8f3961dd1bee,\n\t\t\t\"__wbg_call_ba36642bd901572b\": WEBPACK_IMPORTED_MODULE_0.__wbg_call_ba36642bd901572b,\n\t\t\t\"__wbg_self_bb69a836a72ec6e9\": WEBPACK_IMPORTED_MODULE_0.__wbg_self_bb69a836a72ec6e9,\n\t\t\t\"__wbg_window_3304fc4b414c9693\": WEBPACK_IMPORTED_MODULE_0.__wbg_window_3304fc4b414c9693,\n\t\t\t\"__wbg_globalThis_e0d21cabc6630763\": WEBPACK_IMPORTED_MODULE_0.__wbg_globalThis_e0d21cabc6630763,\n\t\t\t\"__wbg_global_8463719227271676\": WEBPACK_IMPORTED_MODULE_0.__wbg_global_8463719227271676,\n\t\t\t\"__wbindgen_is_undefined\": WEBPACK_IMPORTED_MODULE_0.__wbindgen_is_undefined,\n\t\t\t\"__wbg_buffer_9e184d6f785de5ed\": WEBPACK_IMPORTED_MODULE_0.__wbg_buffer_9e184d6f785de5ed,\n\t\t\t\"__wbg_new_e8101319e4cf95fc\": WEBPACK_IMPORTED_MODULE_0.__wbg_new_e8101319e4cf95fc,\n\t\t\t\"__wbg_set_e8ae7b27314e8b98\": WEBPACK_IMPORTED_MODULE_0.__wbg_set_e8ae7b27314e8b98,\n\t\t\t\"__wbg_length_2d56cb37075fcfb1\": WEBPACK_IMPORTED_MODULE_0.__wbg_length_2d56cb37075fcfb1,\n\t\t\t\"__wbg_newwithlength_a8d1dbcbe703a5c6\": WEBPACK_IMPORTED_MODULE_0.__wbg_newwithlength_a8d1dbcbe703a5c6,\n\t\t\t\"__wbg_subarray_901ede8318da52a6\": WEBPACK_IMPORTED_MODULE_0.__wbg_subarray_901ede8318da52a6,\n\t\t\t\"__wbindgen_object_clone_ref\": WEBPACK_IMPORTED_MODULE_0.__wbindgen_object_clone_ref,\n\t\t\t\"__wbg_new_3a746f2619705add\": WEBPACK_IMPORTED_MODULE_0.__wbg_new_3a746f2619705add,\n\t\t\t\"__wbg_call_f54d3a6dadb199ca\": WEBPACK_IMPORTED_MODULE_0.__wbg_call_f54d3a6dadb199ca,\n\t\t\t\"__wbindgen_jsval_eq\": WEBPACK_IMPORTED_MODULE_0.__wbindgen_jsval_eq,\n\t\t\t\"__wbg_self_ac379e780a0d8b94\": WEBPACK_IMPORTED_MODULE_0.__wbg_self_ac379e780a0d8b94,\n\t\t\t\"__wbg_crypto_1e4302b85d4f64a2\": WEBPACK_IMPORTED_MODULE_0.__wbg_crypto_1e4302b85d4f64a2,\n\t\t\t\"__wbg_getRandomValues_1b4ba144162a5c9e\": WEBPACK_IMPORTED_MODULE_0.__wbg_getRandomValues_1b4ba144162a5c9e,\n\t\t\t\"__wbg_require_6461b1e9a0d7c34a\": WEBPACK_IMPORTED_MODULE_0.__wbg_require_6461b1e9a0d7c34a,\n\t\t\t\"__wbg_randomFillSync_1b52c8482374c55b\": WEBPACK_IMPORTED_MODULE_0.__wbg_randomFillSync_1b52c8482374c55b,\n\t\t\t\"__wbg_getRandomValues_1ef11e888e5228e9\": WEBPACK_IMPORTED_MODULE_0.__wbg_getRandomValues_1ef11e888e5228e9,\n\t\t\t\"__wbindgen_is_string\": WEBPACK_IMPORTED_MODULE_0.__wbindgen_is_string,\n\t\t\t\"__wbindgen_string_get\": WEBPACK_IMPORTED_MODULE_0.__wbindgen_string_get,\n\t\t\t\"__wbindgen_debug_string\": WEBPACK_IMPORTED_MODULE_0.__wbindgen_debug_string,\n\t\t\t\"__wbindgen_throw\": WEBPACK_IMPORTED_MODULE_0.__wbindgen_throw,\n\t\t\t\"__wbindgen_rethrow\": WEBPACK_IMPORTED_MODULE_0.__wbindgen_rethrow,\n\t\t\t\"__wbindgen_memory\": WEBPACK_IMPORTED_MODULE_0.__wbindgen_memory\n\t\t}\n\t});\n}\n__webpack_require__.a(module, (__webpack_handle_async_dependencies__) => {\n\t/* harmony import */ var WEBPACK_IMPORTED_MODULE_0 = __webpack_require__(/*! ./cardano_serialization_lib_bg.js */ \"./node_modules/@emurgo/cardano-serialization-lib-browser/cardano_serialization_lib_bg.js\");\n\tvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([WEBPACK_IMPORTED_MODULE_0]);\n\treturn __webpack_async_dependencies__.then ? __webpack_async_dependencies__.then(__webpack_instantiate__) : __webpack_instantiate__(__webpack_async_dependencies__);\n}, 1);\n\n//# sourceURL=webpack://test-webpack-wasm/./node_modules/@emurgo/cardano-serialization-lib-browser/cardano_serialization_lib_bg.wasm?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/async module */
/******/ 	(() => {
/******/ 		var webpackThen = typeof Symbol === "function" ? Symbol("webpack then") : "__webpack_then__";
/******/ 		var webpackExports = typeof Symbol === "function" ? Symbol("webpack exports") : "__webpack_exports__";
/******/ 		var completeQueue = (queue) => {
/******/ 			if(queue) {
/******/ 				queue.forEach((fn) => (fn.r--));
/******/ 				queue.forEach((fn) => (fn.r-- ? fn.r++ : fn()));
/******/ 			}
/******/ 		}
/******/ 		var completeFunction = (fn) => (!--fn.r && fn());
/******/ 		var queueFunction = (queue, fn) => (queue ? queue.push(fn) : completeFunction(fn));
/******/ 		var wrapDeps = (deps) => (deps.map((dep) => {
/******/ 			if(dep !== null && typeof dep === "object") {
/******/ 				if(dep[webpackThen]) return dep;
/******/ 				if(dep.then) {
/******/ 					var queue = [];
/******/ 					dep.then((r) => {
/******/ 						obj[webpackExports] = r;
/******/ 						completeQueue(queue);
/******/ 						queue = 0;
/******/ 					});
/******/ 					var obj = {};
/******/ 												obj[webpackThen] = (fn, reject) => (queueFunction(queue, fn), dep['catch'](reject));
/******/ 					return obj;
/******/ 				}
/******/ 			}
/******/ 			var ret = {};
/******/ 								ret[webpackThen] = (fn) => (completeFunction(fn));
/******/ 								ret[webpackExports] = dep;
/******/ 								return ret;
/******/ 		}));
/******/ 		__webpack_require__.a = (module, body, hasAwait) => {
/******/ 			var queue = hasAwait && [];
/******/ 			var exports = module.exports;
/******/ 			var currentDeps;
/******/ 			var outerResolve;
/******/ 			var reject;
/******/ 			var isEvaluating = true;
/******/ 			var nested = false;
/******/ 			var whenAll = (deps, onResolve, onReject) => {
/******/ 				if (nested) return;
/******/ 				nested = true;
/******/ 				onResolve.r += deps.length;
/******/ 				deps.map((dep, i) => (dep[webpackThen](onResolve, onReject)));
/******/ 				nested = false;
/******/ 			};
/******/ 			var promise = new Promise((resolve, rej) => {
/******/ 				reject = rej;
/******/ 				outerResolve = () => (resolve(exports), completeQueue(queue), queue = 0);
/******/ 			});
/******/ 			promise[webpackExports] = exports;
/******/ 			promise[webpackThen] = (fn, rejectFn) => {
/******/ 				if (isEvaluating) { return completeFunction(fn); }
/******/ 				if (currentDeps) whenAll(currentDeps, fn, rejectFn);
/******/ 				queueFunction(queue, fn);
/******/ 				promise['catch'](rejectFn);
/******/ 			};
/******/ 			module.exports = promise;
/******/ 			body((deps) => {
/******/ 				if(!deps) return outerResolve();
/******/ 				currentDeps = wrapDeps(deps);
/******/ 				var fn, result;
/******/ 				var promise = new Promise((resolve, reject) => {
/******/ 					fn = () => (resolve(result = currentDeps.map((d) => (d[webpackExports]))));
/******/ 					fn.r = 0;
/******/ 					whenAll(currentDeps, fn, reject);
/******/ 				});
/******/ 				return fn.r ? promise : result;
/******/ 			}).then(outerResolve, reject);
/******/ 			isEvaluating = false;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/wasm loading */
/******/ 	(() => {
/******/ 		__webpack_require__.v = (exports, wasmModuleId, wasmModuleHash, importsObj) => {
/******/ 			var req = fetch(__webpack_require__.p + "" + wasmModuleHash + ".module.wasm");
/******/ 			if (typeof WebAssembly.instantiateStreaming === 'function') {
/******/ 				return WebAssembly.instantiateStreaming(req, importsObj)
/******/ 					.then((res) => (Object.assign(exports, res.instance.exports)));
/******/ 			}
/******/ 			return req
/******/ 				.then((x) => (x.arrayBuffer()))
/******/ 				.then((bytes) => (WebAssembly.instantiate(bytes, importsObj)))
/******/ 				.then((res) => (Object.assign(exports, res.instance.exports)));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) scriptUrl = scripts[scripts.length - 1].src
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;